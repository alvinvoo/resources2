https://mlochbaum.github.io/BQN/doc/index.html

Types:
1.Number
2.Character (Unicode code point)
3.Array
4.Function
5.1-Modifier
6.2-Modifier
7.Namespace

First 3 types are data types and are immutable; the rest are mutable
Function + the 2 modifiers are operation types
Other than Array, the 6 other types are atomic types, and their values are called atoms

--
An atom has depth 0 and does not have shape
But, primitives promote atoms by enclosing them to get rank-0 or unit array
For e.g. Rank and Shape
So an atom can be considered to have same dimensions as unit array: rank 0 and shape ‚ü®‚ü©

    3    # Atom , Rank 0, Depth 0
3
    <3   # Array (Unit)  , Rank 0, Depth 1
‚îå¬∑   
¬∑ 3  
    ‚îò
    '3'  # Atom , Rank 0, Depth 0
'3'

hierachy
depth‚Üírank‚Üíshape

Unit Array
A unit array is an array with no axes, Rank 0, Depth 1, Shape ‚ü®‚ü©
same shape as an atom like 137
    ‚â¢ 123
‚ü®‚ü©


Enclose <



Enclost vs Enlist:

    < "enclose"
‚îå¬∑           
¬∑ "enclose"      # wraps it in unit array
            ‚îò

Enlist or Pair ‚ãà /Z 
    ‚ãà "enlist"    # ‚ü®ùï©‚ü©
‚ü® "enlist" ‚ü©     # wraps it in an array

    "pa" ‚ãà "ir"   # ‚ü®ùï®,ùï©‚ü©  - dyadic is Pair
‚ü® "pa" "ir" ‚ü©

    2‚Äø4‚Äø1 ‚ãà‚åú "north"‚Äø"south"  # Cartesian product
‚îå‚îÄ                             
‚ïµ ‚ü® 2 "north" ‚ü© ‚ü® 2 "south" ‚ü©  
  ‚ü® 4 "north" ‚ü© ‚ü® 4 "south" ‚ü©  
  ‚ü® 1 "north" ‚ü© ‚ü® 1 "south" ‚ü©  
                              ‚îò

    ‚ãà¬® "+-√ó√∑"  # Glyphs to strings
‚ü® "+" "-" "√ó" "√∑" ‚ü©

    'c' (+‚ãà-)  1‚Äø2
‚ü® "de" "ba" ‚ü©

    "e0" <‚ä∏‚àæ "e1" <‚ä∏‚àæ "e2" ‚ãà "e3"
‚ü® "e0" "e1" "e2" "e3" ‚ü©
#breakdown: 
# Join always join at first-axis
    "e1" ‚àæ "e2" ‚ãà "e3"
‚ü® 'e' '1' "e2" "e3" ‚ü©
# we can enclose it, before joining 
    (<"e1") ‚àæ "e2" ‚ãà "e3"
‚ü® "e1" "e2" "e3" ‚ü©
# which is same as enlisting it, before joining
    ‚ü®"e12"‚ü© ‚àæ "e2" ‚ãà "e3"
‚ü® "e12" "e2" "e3" ‚ü©
    (‚ãà"e123") ‚àæ "e2" ‚ãà "e3"
‚ü® "e123" "e2" "e3" ‚ü©
# but fundamentally different, enlisting will have Rank 1 and a shape; while
# enclosing have Rank 0 and an empty shape
‚â° (‚ãà"e123")
2
‚â° (<"e123")
2
= (‚ãà"e123")
1
= (<"e123")
0
‚â¢ (‚ãà"e123")
‚ü® 1 ‚ü©
‚â¢ (<"e123")
‚ü®‚ü©
# tedious way to join a long list; but notice how the multiple trains are working
    6 (+ <‚ä∏‚àæ - <‚ä∏‚àæ √ó ‚ãà √∑) 3
‚ü® 9 3 18 2 ‚ü©
# easier way; extract out the Functions as right operand
    {6ùïè3}¬® +‚Äø-‚Äø√ó‚Äø√∑
‚ü® 9 3 18 2 ‚ü©

Pair vs Couple
    "abc" ‚âç "def"  # treats arguments as Cells and add a dimension (axis) 
‚îå‚îÄ     
‚ïµ"abc  
  def" 
      ‚îò

    "abc" ‚ãà "def"  # treats arguments as elements and add depth
‚ü® "abc" "def" ‚ü©


https://mlochbaum.github.io/BQN/doc/primitive.html

# for spec reference
https://github.com/mlochbaum/BQN/blob/c747cbab2847d454615712403f495f73823db917/spec/reference.bqn
-**
√ó 	\=  Multiply
√∑ 	\- 	Reciprocal 	Divide
œÄ 	\p 	Pi
‚àû 	\8 	Infinity
‚ãÜ 	\+ 	Exponential 	Power
‚àö 	\_ 	Square Root 	Root
' 		Character
@ 		Null character
Àú 	\` 	Swap 	Self
‚Åº 	\3 	Undo
Àô 	\" 	Constant
‚àò 	\j 	Atop


Swap Àú , swap the arguments
    2 -Àú 'd'  # Subtract from
'b'
    +Àú 3      # Add to itself
6
    √óÀú 4    # 2 ways to square a number
16
    2 ‚ãÜÀú 4
16
--
Undo ‚Åº , undo the function
    ‚àö‚Åº 4 , undo the ‚àö function, ‚àöx = 4, x = ?
16
    ‚ãÜ‚Åº 10, natural e ‚ãÜ ? = 10
2.302585092994046
    2 ‚ãÜ‚Åº 32    # Log base 2
5
    2 ‚ãÜ 2 ‚ãÜ‚Åº 32
32
    10 ‚ãÜ‚Åº 1e4  # Log base 10 of a number in scientific notation
4
-
    2 ‚åΩ "abcde"
"cdeab"

    2 ‚åΩ‚Åº 2 ‚åΩ "abcde"
"abcde"

    √óÀú ¬Ø3
9
    √óÀú‚Åº √óÀú ¬Ø3  # It's not the same!
3

Undo doesnt always satisfy ùï© ‚â° ùîΩ‚Åº ùîΩ ùï©, 
but it does obey ùï© ‚â° ùîΩ ùîΩ‚Åº ùï©

That is, it gives one possible argument that could have been passed to ùîΩ, just not necessarily the one that actually was. 

--
Àô , Constant
    2 3Àô 4 # turns operand into a constant function that always return the operand
3
--
‚àò, Atop
it combine (or compose) 2 functions (or actually AKA 2-trains)
it produces a derived function which uses the left operand monadically to post-processes the result of the ambivalent right operand.

    3 √óÀú‚àò+ 4  # Square of 3 plus 4
49
    -‚àò(√óÀú) 5  # Negative square of 5
¬Ø25


--
Arithmetic

    3‚Äø4‚Äø5‚Äø6 ‚â§ 5
‚ü® 1 1 1 0 ‚ü©

    'c' < "acbz"
‚ü® 0 0 0 1 ‚ü©<‚àò/Àò

    ¬Ø‚àû‚ÄøœÄ‚Äø‚àû ‚â• @‚Äø'0'‚Äø'?'
‚ü® 0 0 0 ‚ü©

#Comparisons test for `atomic equality` 
    +‚Äø-‚Äø√ó‚Äø√∑ = ‚äë‚ü®-‚ü©
‚ü® 0 1 0 0 ‚ü©

    'b' ‚â† "abacba"
‚ü® 1 0 1 1 0 1 ‚ü©

--
Modifiers is NOT function
Literal (characters and numbers) or a primitive (functions and modifiers), and has a fixed value. Primitive 1-modifiers have superscript characters and 2-modifiers contain unbroken circles. Other primitives are always functions.

Role 	    Types
Subject 	Number, Character
Function 	Function
1-modifier 	1-modifier
2-modifier 	2-modifier

Every primitive 1-modifer is a superscript character Àú‚ÅºÀô, and the remaining array-based modifiers Àò¬®‚åú¬¥Àù`

The 2-modifiers in BQN are the combinators ‚àò‚óã‚ä∏‚üú‚äò, the sort-of-combinators ‚åæ‚ó∂‚çü, and the not-at-all-combinators ‚éâ‚öá‚éä. And the functions that make that unbroken circle rule necessary are written ‚åΩ‚çâ.



-**
"		String
‚ü®	\(	Start list
‚ü©	\)	End list
‚ãÑ	\;	Separator
,		Separator

(zoom in if you cannot see the diamond shape ‚ãÑ)	
‚ãÑ	,  (and also newline) are completely interchangeable	

‚ü®
  "putting"         # This is a comment
  "a",              # That , wasn't needed
  "list"
                    # An extra newline won't hurt anything
  "on","multiple"   # Two elements here
  "lines"
‚ü©

#		Comment
‚Äø	\ 	Strand    (\ followed by a space)

ligature ‚Äø has a higher precedence than either functions or operator

#below 2 expressions are equivalent
‚ü®2,+,-‚ü©
2‚Äø+‚Äø-

#use brackets to nest ligatures
    0‚Äø1‚Äø2
‚ü® 0 1 2 ‚ü©
    (0‚Äø1)‚Äø2
‚ü® ‚ü® 0 1 ‚ü© 2 ‚ü©
    0‚Äø(1‚Äø2)
‚ü® 0 ‚ü® 1 2 ‚ü© ‚ü©

--
Data types - Number Character Array
Operation types - Function 1-modifier 2-modifier
Atom - Number Character, Function 1-modifier 2-modifier

#arithmetic functions are pervasive
    2 √ó ‚ü®0‚Äø2 ‚ãÑ 1‚Äø3‚Äø5‚ü©
‚ü® ‚ü® 0 4 ‚ü© ‚ü® 2 6 10 ‚ü© ‚ü©

    ‚ü® 10, 20‚Äø30 ‚ü© + ‚ü® 1‚Äø2, 3 ‚ü©
‚ü® ‚ü® 11 12 ‚ü© ‚ü® 23 33 ‚ü© ‚ü©

-**
list functions 
        1-arg   2-args
‚âç	\.	Solo	Couple
‚àæ	\,		    Join To
‚åΩ	\q	Reverse	Rotate

modifiers
¬®	\2	Each
¬¥	\5	Fold
‚àæ	\,	Join	Join To

‚Üï	\d	Range	
‚ä∏	\h	Bind?	

Couple
    ‚âç 4
‚ü® 4 ‚ü©
    2 ‚âç 4
‚ü® 2 4 ‚ü©

Join To (Dyadic)
Join (Monad)

# Join to combine arguments along first axis
    ‚ü®1,2,3‚ü© ‚àæ "abc"
‚ü® 1 2 3 'a' 'b' 'c' ‚ü©

    0 ‚àæ ‚ü®1,2,3‚ü©
‚ü® 0 1 2 3 ‚ü©

    "plural" ‚àæ 's'
"plurals"

#Notice the difference between couple and join
‚ü®1,2‚ü© ‚âç ‚ü®3,4‚ü©
‚îå‚îÄ     
‚ïµ 1 2  
  3 4  
      ‚îò
‚ü®1,2‚ü© ‚âç ‚ü®3,4,5‚ü©
>ùï©: Elements of ùï© must have matching shapes

‚ü®1,2‚ü© ‚àæ ‚ü®3,4‚ü©
‚ü® 1 2 3 4 ‚ü©

#For arrays with rank 2 or more, arguments will joined "vertically"
    ‚ä¢ a ‚Üê 3 +‚åú‚óã‚Üï 4
‚îå‚îÄ         
‚ïµ 0 1 2 3  
  1 2 3 4  
  2 3 4 5  
          ‚îò
    ‚ä¢ b ‚Üê 2‚Äø4 ‚•ä ‚Üï8
‚îå‚îÄ         
‚ïµ 0 1 2 3  
  4 5 6 7  
          ‚îò
    a ‚àæ b
‚îå‚îÄ         
‚ïµ 0 1 2 3  
  1 2 3 4  
  2 3 4 5  
  0 1 2 3  
  4 5 6 7  
          ‚îò

# Join To needs major cells to have same shape
# in above example major cells (row wise) shape is 4
    ‚äë‚â¢Àò2‚Äø4 ‚•ä ‚Üï8
4

Reverse / Rotate
    ‚åΩ "drawer"
"reward"
    2 ‚åΩ ‚ü®0,1,2,3,4‚ü©
‚ü® 2 3 4 0 1 ‚ü©
    ¬Ø1 ‚åΩ "bcdea"
"abcde"

--
like how Reverse move element in a list from front to back
transpose ‚çâ move axis from front to back

   ‚Üï2‚Äø3‚Äø4
‚îå‚îÄ
‚ïé ‚ü® 0 0 0 ‚ü© ‚ü® 0 0 1 ‚ü© ‚ü® 0 0 2 ‚ü© ‚ü® 0 0 3 ‚ü©
  ‚ü® 0 1 0 ‚ü© ‚ü® 0 1 1 ‚ü© ‚ü® 0 1 2 ‚ü© ‚ü® 0 1 3 ‚ü©
  ‚ü® 0 2 0 ‚ü© ‚ü® 0 2 1 ‚ü© ‚ü® 0 2 2 ‚ü© ‚ü® 0 2 3 ‚ü©

  ‚ü® 1 0 0 ‚ü© ‚ü® 1 0 1 ‚ü© ‚ü® 1 0 2 ‚ü© ‚ü® 1 0 3 ‚ü©
  ‚ü® 1 1 0 ‚ü© ‚ü® 1 1 1 ‚ü© ‚ü® 1 1 2 ‚ü© ‚ü® 1 1 3 ‚ü©
  ‚ü® 1 2 0 ‚ü© ‚ü® 1 2 1 ‚ü© ‚ü® 1 2 2 ‚ü© ‚ü® 1 2 3 ‚ü©
                                          ‚îò
   ‚çâ‚Üï2‚Äø3‚Äø4
‚îå‚îÄ
‚ïé ‚ü® 0 0 0 ‚ü© ‚ü® 1 0 0 ‚ü©
  ‚ü® 0 0 1 ‚ü© ‚ü® 1 0 1 ‚ü©
  ‚ü® 0 0 2 ‚ü© ‚ü® 1 0 2 ‚ü©
  ‚ü® 0 0 3 ‚ü© ‚ü® 1 0 3 ‚ü©

  ‚ü® 0 1 0 ‚ü© ‚ü® 1 1 0 ‚ü©
  ‚ü® 0 1 1 ‚ü© ‚ü® 1 1 1 ‚ü©
  ‚ü® 0 1 2 ‚ü© ‚ü® 1 1 2 ‚ü©
  ‚ü® 0 1 3 ‚ü© ‚ü® 1 1 3 ‚ü©

  ‚ü® 0 2 0 ‚ü© ‚ü® 1 2 0 ‚ü©
  ‚ü® 0 2 1 ‚ü© ‚ü® 1 2 1 ‚ü©
  ‚ü® 0 2 2 ‚ü© ‚ü® 1 2 2 ‚ü©
  ‚ü® 0 2 3 ‚ü© ‚ü® 1 2 3 ‚ü©
                      ‚îò
   ‚â¢‚çâ‚Üï2‚Äø3‚Äø4
‚ü® 3 4 2 ‚ü©   # moved first axis to back

    ‚â¢ a23456 ‚Üê ‚Üï2‚Äø3‚Äø4‚Äø5‚Äø6
‚ü® 2 3 4 5 6 ‚ü©

    ‚â¢ ‚çâ a23456
‚ü® 3 4 5 6 2 ‚ü©

# but, to exchange multiple axes, use Repeat modifier
# can use negative power to move axes in other direction, just like how Rotate
# works on list
    ‚â¢ ‚çâ‚çü3 a23456
‚ü® 5 6 2 3 4 ‚ü©

    ‚â¢ ‚çâ‚Åº a23456   # same as ‚çâ¬Ø1
‚ü® 6 2 3 4 5 ‚ü©
   
   ‚â¢‚çâ‚çü¬Ø1‚Üï2‚Äø3‚Äø4
‚ü® 4 2 3 ‚ü©

in fact, ‚â¢‚çâ‚çük a ‚Üê‚Üí k‚åΩ‚â¢a

To move axes other than first, use Rank modifier
    ‚â¢ ‚çâ‚éâ3 a23456
‚ü® 2 3 5 6 4 ‚ü©  # k > 0; transpose only last k axes, in this case 4,5,6

    ‚â¢ ‚çâ‚Åº‚éâ¬Ø1 a23456
‚ü® 2 6 3 4 5 ‚ü©  # k < 0; ignore first |k axes, in this case, ignore 2

But is not friendly to use when we want to reorder multiple axes, so we have dyadic ‚çâ

# For each index p‚Üêi‚äëùï® in the left argument, axis i of ùï© is used for axis p of the result.
# think of the ùï® as the NEW axes' indices
    ‚â¢ 1‚Äø3‚Äø2‚Äø0‚Äø4 ‚çâ a23456
‚ü® 5 2 4 3 6 ‚ü©
# simplify: take 
indices 0 1 2 3 4    0 1 2 3 4 
        1 3 2 0 4    2 3 4 5 6
so, ùï©'s index 0's 2 goes to new axes index 1, index 1's 3, goes to 3, etc

# if we want to specify all axes, the inverse transpose might be more
# intuitive
# it directly refer to ùï© (old axes) indices (instead of new axes indices)
    ‚â¢ 1‚Äø3‚Äø2‚Äø0‚Äø4 ‚çâ‚Åº a23456
‚ü® 3 5 4 2 6 ‚ü©

# BQN extension allows only some axes to be specified, and the remaining
# unspecified axes will be placed in order into the gaps 

    ‚â¢ 0‚Äø2‚Äø4 ‚çâ a23456  # here, only new axes indices 0,2 and 4 are specified
‚ü® 2 5 3 6 4 ‚ü© 

    ‚â¢ 2 ‚çâ a23456  # Restrict Transpose to the first three axes
‚ü® 3 4 2 5 6 ‚ü© # only need to specify new axes index for first axis 2

Interesting to note that, the monadic ‚çâ, is simply the dyadic Transpose with left argument of (=-1Àô)
   ‚â¢ ‚çâ ‚Üï1‚Äø2‚Äø3‚Äø4
‚ü® 2 3 4 1 ‚ü©
   ‚â¢(=-1Àô)‚ä∏‚çâ ‚Üï1‚Äø2‚Äø3‚Äø4
‚ü® 2 3 4 1 ‚ü©

# notice that (=-1Àô) is a fork, it takes the = Rank of ùï© and minus it by 1
1Àô returns constant 1
so above is essentially ‚â¢ 3‚çâ ‚Üï1‚Äø2‚Äø3‚Äø4 ; means move the first one to the last index position of the new axes

--
Join
    ‚àæ"time"‚Äø"to"‚Äø"join"‚Äø"some"‚Äø"words"
"timetojoinsomewords"

Merge (>) does to Couple (‚âç): a‚âçb is >a‚Äøb as Join does to Join To: a‚àæb is ‚àæa‚Äøb. 
While Merge and Couple combine arrays (the elements of Merge's argument, or the arguments themselves for Couple) along a new leading axis, Join and Join to combine them along the existing leading axis.

# to join a separator between each words
# prepend the separator to each string, join, then remove the leading separator
    1‚Üì‚àæ' '‚àæ¬®"time"‚Äø"to"‚Äø"join"‚Äø"some"‚Äø"words"
"time to join some words"

# as long as the major cells length matches
    ‚ä¢ m ‚Üê (3‚Äø1‚âç‚åú4‚Äø2‚Äø5) ‚•ä¬® 2‚Äø3‚•ä‚Üï6
‚îå‚îÄ                                   
‚ïµ ‚îå‚îÄ          ‚îå‚îÄ      ‚îå‚îÄ             
  ‚ïµ 0 0 0 0   ‚ïµ 1 1   ‚ïµ 2 2 2 2 2    
    0 0 0 0     1 1     2 2 2 2 2    
    0 0 0 0     1 1     2 2 2 2 2    
            ‚îò       ‚îò             ‚îò  
  ‚îå‚îÄ          ‚îå‚îÄ      ‚îå‚îÄ             
  ‚ïµ 3 3 3 3   ‚ïµ 4 4   ‚ïµ 5 5 5 5 5    
            ‚îò       ‚îò             ‚îò  
                                    ‚îò
    ‚àæ m  # Join all that together
‚îå‚îÄ                       
‚ïµ 0 0 0 0 1 1 2 2 2 2 2  
  0 0 0 0 1 1 2 2 2 2 2  
  0 0 0 0 1 1 2 2 2 2 2  
  3 3 3 3 4 4 5 5 5 5 5  
                        ‚îò

    ‚ä¢ n ‚Üê 2‚Äø4‚Äø6 √ó{‚ü®ùïó,ùï©‚ü©‚âç‚ü®ùï®,ùï®ùîΩ‚åúùï©‚ü©} 5‚Äø6‚Äø7‚Äø8
‚îå‚îÄ                           
‚ïµ √ó         ‚ü® 5 6 7 8 ‚ü©      
  ‚ü® 2 4 6 ‚ü© ‚îå‚îÄ               
            ‚ïµ 10 12 14 16    
              20 24 28 32    
              30 36 42 48    
                          ‚îò  
                            ‚îò

    ‚â¢¬® n  # Different ranks but compatible shapes
‚îå‚îÄ               
‚ïµ ‚ü®‚ü©    ‚ü® 4 ‚ü©    
  ‚ü® 3 ‚ü© ‚ü® 3 4 ‚ü©  
                ‚îò

# a multiplication table
    ‚àæ n
‚îå‚îÄ               
‚ïµ √ó 5  6  7  8   
  2 10 12 14 16  
  4 20 24 28 32  
  6 30 36 42 48  
                ‚îò

How to `revert` back a higher rank merged array?
   d ‚Üê 2‚Äø2‚•ä‚Üï4
‚îå‚îÄ     
‚ïµ 0 1  
  2 3  
      ‚îò
   <Àòd    # so opposite of > is <Àò
‚ü® ‚ü® 0 1 ‚ü© ‚ü® 2 3 ‚ü© ‚ü©

---
Each
    ‚åΩ¬® "abcd"‚Äø"ABCDEF"‚Äø"01"
‚ü® "dcba" "FEDCBA" "10" ‚ü©

    "string"‚Äø"list"‚Äø"array" ‚àæ¬® 's'  # can see Each can apply to both ùï® ùï© arguments
‚ü® "strings" "lists" "arrays" ‚ü©

    "abc" ‚âç¬® ‚åΩ "abc"  #this is like a zip 
‚ü® "ac" "bb" "ca" ‚ü©

Depth of an array is the greatest level of array nesting it attains, or, put another way, the greatest number of times you can pick an element starting from the original array before reaching an atom
Depth 2-modifier (‚öá) is a generalization of Each that allows diving deeper into an array

    n ‚Üê <‚éâ1‚çü2 4‚Äø3‚Äø2‚Äø2‚•ä‚Üï48
‚îå‚îÄ                                                                         
‚ïµ ‚ü® ‚ü® 0 1 ‚ü© ‚ü® 2 3 ‚ü© ‚ü©     ‚ü® ‚ü® 4 5 ‚ü© ‚ü® 6 7 ‚ü© ‚ü©     ‚ü® ‚ü® 8 9 ‚ü© ‚ü® 10 11 ‚ü© ‚ü©    
  ‚ü® ‚ü® 12 13 ‚ü© ‚ü® 14 15 ‚ü© ‚ü© ‚ü® ‚ü® 16 17 ‚ü© ‚ü® 18 19 ‚ü© ‚ü© ‚ü® ‚ü® 20 21 ‚ü© ‚ü® 22 23 ‚ü© ‚ü©  
  ‚ü® ‚ü® 24 25 ‚ü© ‚ü® 26 27 ‚ü© ‚ü© ‚ü® ‚ü® 28 29 ‚ü© ‚ü® 30 31 ‚ü© ‚ü© ‚ü® ‚ü® 32 33 ‚ü© ‚ü® 34 35 ‚ü© ‚ü©  
  ‚ü® ‚ü® 36 37 ‚ü© ‚ü® 38 39 ‚ü© ‚ü© ‚ü® ‚ü® 40 41 ‚ü© ‚ü® 42 43 ‚ü© ‚ü© ‚ü® ‚ü® 44 45 ‚ü© ‚ü® 46 47 ‚ü© ‚ü©  
                                                                          ‚îò
    ‚â° n
3
#n is a 4 x 3 matrix of list of list
# apply
    ‚åΩ‚öá¬Ø1 n  # equivalent to ‚åΩ¬®n and ‚åΩ‚öá2 n, reverse the larger list
‚îå‚îÄ                                                                         
‚ïµ ‚ü® ‚ü® 2 3 ‚ü© ‚ü® 0 1 ‚ü© ‚ü©     ‚ü® ‚ü® 6 7 ‚ü© ‚ü® 4 5 ‚ü© ‚ü©     ‚ü® ‚ü® 10 11 ‚ü© ‚ü® 8 9 ‚ü© ‚ü©    
  ‚ü® ‚ü® 14 15 ‚ü© ‚ü® 12 13 ‚ü© ‚ü© ‚ü® ‚ü® 18 19 ‚ü© ‚ü® 16 17 ‚ü© ‚ü© ‚ü® ‚ü® 22 23 ‚ü© ‚ü® 20 21 ‚ü© ‚ü©  
  ‚ü® ‚ü® 26 27 ‚ü© ‚ü® 24 25 ‚ü© ‚ü© ‚ü® ‚ü® 30 31 ‚ü© ‚ü® 28 29 ‚ü© ‚ü© ‚ü® ‚ü® 34 35 ‚ü© ‚ü® 32 33 ‚ü© ‚ü©  
  ‚ü® ‚ü® 38 39 ‚ü© ‚ü® 36 37 ‚ü© ‚ü© ‚ü® ‚ü® 42 43 ‚ü© ‚ü® 40 41 ‚ü© ‚ü© ‚ü® ‚ü® 46 47 ‚ü© ‚ü® 44 45 ‚ü© ‚ü©  
                                                                          ‚îò
    ‚åΩ‚öá¬Ø2 n  # equivalent to ‚åΩ‚öá1 n, apply Each twice, reverse larger list and smaller list
‚îå‚îÄ                                                                         
‚ïµ ‚ü® ‚ü® 1 0 ‚ü© ‚ü® 3 2 ‚ü© ‚ü©     ‚ü® ‚ü® 5 4 ‚ü© ‚ü® 7 6 ‚ü© ‚ü©     ‚ü® ‚ü® 9 8 ‚ü© ‚ü® 11 10 ‚ü© ‚ü©    
  ‚ü® ‚ü® 13 12 ‚ü© ‚ü® 15 14 ‚ü© ‚ü© ‚ü® ‚ü® 17 16 ‚ü© ‚ü® 19 18 ‚ü© ‚ü© ‚ü® ‚ü® 21 20 ‚ü© ‚ü® 23 22 ‚ü© ‚ü©  
  ‚ü® ‚ü® 25 24 ‚ü© ‚ü® 27 26 ‚ü© ‚ü© ‚ü® ‚ü® 29 28 ‚ü© ‚ü® 31 30 ‚ü© ‚ü© ‚ü® ‚ü® 33 32 ‚ü© ‚ü® 35 34 ‚ü© ‚ü©  
  ‚ü® ‚ü® 37 36 ‚ü© ‚ü® 39 38 ‚ü© ‚ü© ‚ü® ‚ü® 41 40 ‚ü© ‚ü® 43 42 ‚ü© ‚ü© ‚ü® ‚ü® 45 44 ‚ü© ‚ü® 47 46 ‚ü© ‚ü©  
                                                                          ‚îò
    ‚ü®'a',"bc"‚ü© ‚âç‚öá0 ‚ü®2‚Äø3,4‚ü© # depth of 0 means apply pervasively
‚îå‚îÄ                                                 
¬∑ ‚ü® ‚ü® 'a' 2 ‚ü© ‚ü® 'a' 3 ‚ü© ‚ü© ‚ü® ‚ü® 'b' 4 ‚ü© ‚ü® 'c' 4 ‚ü© ‚ü©  
                                                  ‚îò

when n is positive, it means, apply until THIS depth

----
Fold  \5 (Right fold)
    +¬¥ 2‚Äø3‚Äø4
9
    √ó¬¥ 2‚Äø3‚Äø4
24
  #alternating sum, execution order from right to left
    -¬¥ 1‚Äø2‚Äø3‚Äø4‚Äø5
3
    1-2-3-4-5
3
    ‚àæ¬¥ ‚ü® "con", "cat", "enat", "e" ‚ü©
"concatenate"
# but shouldn't need the Each, just Join is enough
    ‚àæ ‚ü® "con", "cat", "enat", "e" ‚ü©
"concatenate"

# can see right fold in action
    ‚ãà¬¥ "abcd"
‚ü® 'a' ‚ü® 'b' "cd" ‚ü© ‚ü©

    'a' ‚ãà 'b' ‚ãà 'c' ‚ãà 'd'  # Expanded form
‚ü® 'a' ‚ü® 'b' "cd" ‚ü© ‚ü©

# left Fold 
    ‚ãàÀú¬¥ ‚åΩ "abcd"
‚ü® ‚ü® "ab" 'c' ‚ü© 'd' ‚ü©
Can specify an initial element for Fold: simply pass it as ùï®
    +¬¥1‚Äø2‚Äø3
6
    5+¬¥1‚Äø2‚Äø3
11
    ‚àæ‚óã‚•ä¬¥ ‚ü®2‚Äø4‚âç6‚Äø8,"abcd",0‚ü©
‚ü® 2 4 6 8 'a' 'b' 'c' 'd' 0 ‚ü©

    ‚àæ‚óã‚•ä¬¥ ‚ü®2‚Äø4‚âç6‚Äø8,"abcd"‚ü©
‚ü® 2 4 6 8 'a' 'b' 'c' 'd' ‚ü©
# the one-element case, when ‚àæ‚óã‚•ä is never applied and can't deshape anything
    ‚àæ‚óã‚•ä¬¥ ‚ü®2‚Äø4‚âç6‚Äø8‚ü©
‚îå‚îÄ     
‚ïµ 2 4  
  6 8  
      ‚îò
# when initial element, ‚àæ‚óã‚•ä is applied at least once (with the initial element
# 'added' to the end of the list)
    ‚ü®‚ü© ‚àæ‚óã‚•ä¬¥ ‚ü®2‚Äø4‚âç6‚Äø8‚ü©
‚ü® 2 4 6 8 ‚ü©

    "end" ‚àæ‚óã‚•ä¬¥ ‚ü®"start","middle"‚ü©
"startmiddleend"

A function P can be applied to each element of ùï© before operating using ùï®P‚ä∏F¬¥ùï©, which is equivalent to ùï® F¬¥ P¬®ùï©

    "STOP" ‚åΩ‚ä∏‚àæ¬¥ "ABCDE"‚Äø"012"‚Äø"abcd"
"EDCBA210dcbaSTOP"

----
Insert \6 Àù (similar to APL ‚åø)

    ‚ä¢ tab ‚Üê (2+‚Üï5) |‚åú 9+‚Üï3
‚îå‚îÄ       
‚ïµ 1 0 1  
  0 1 2  
  1 2 3  
  4 0 1  
  3 4 5  
        ‚îò

#Insert works on the leading axis of the argument
    +Àù tab
‚ü® 9 7 12 ‚ü©

#sum each row (second axis)
    +ÀùÀò tab
‚ü® 2 3 6 5 12 ‚ü©

# a tricky case
because +¬¥Àò tab yields the same result but is actually unsound‚Äîif tab contains arrays then they will be merged together at the end. Remember that if you want to reduce along one axis of an array but get an array of results out, you should use Insert (possibly adding Each to work on elements instead of cells).

#An Insert ùîΩÀù is roughly equals to {ùï®ùîΩ¬¥<Àòùï©}
#but it takes the argument shape into account
    +¬¥<Àò 0‚Äø4‚•ä0
0
    +Àù   0‚Äø4‚•ä0
‚ü® 0 0 0 0 ‚ü©


    "id" ‚ãàÀù "row0 "‚àæ"row1 "‚âç"row2 "
‚îå‚îÄ                                      
¬∑ "row0 " ‚ü® "row1 " ‚ü® "row2 " "id" ‚ü© ‚ü©  
                                       ‚îò
breakdown:
    "row0 "‚àæ"row1 "‚âç"row2 "
‚îå‚îÄ       
‚ïµ"row0   
  row1   
  row2 " 
        ‚îò
#and then initial "id" is paired along the first axis

One trick involving Insert is ‚àæÀù, which merges the first two axes of ùï© into one long axis.

    ‚ä¢ let ‚Üê ("AHW"-'A') +‚åú "aA" +‚åú ‚Üï4
‚îå‚îÄ      
‚ïé"abcd  
  ABCD  
        
 ¬∑hijk  
  HIJK  
        
 ¬∑wxyz  
  WXYZ" 
       ‚îò

    ‚àæÀù let
‚îå‚îÄ      
‚ïµ"abcd  
  ABCD  
  hijk  
  HIJK  
  wxyz  
  WXYZ" 
       ‚îò

    ‚â¢ ‚àæÀù ‚Üï3‚Äø2‚Äø4
‚ü® 6 4 ‚ü©

    ‚â¢ ‚àæÀù ‚Üï0‚Äø2‚Äø4  # The identity is an empty cell
‚ü® 0 4 ‚ü©


----
Scan `
    ‚åà` 2‚Äø0‚Äø0‚Äø4‚Äø1
‚ü® 2 2 2 4 4 ‚ü©
#traverses the array in forward (left to right) rather than reverse index order
#includes all intermediate results of ùîΩ in its output instead of just the final one

    -` 1‚Äø2‚Äø3‚Äø4‚Äø5
‚ü® 1 ¬Ø1 ¬Ø4 ¬Ø8 ¬Ø13 ‚ü©


Shift  (or called Nudge - when move by 1 cell)
¬ª - add major cells to beginning
¬´ - add major cells to end

    0‚Äø0 ¬ª 3‚Äø2‚Äø1             # Shift Before
‚ü® 0 0 3 ‚ü©
    "end" ¬´ "add to the "   # Shift After
" to the end"

    ¬ª "abcd"   # Nudge
" abc"
    ¬´ 1‚Äø2‚Äø3    # Nudge Back
‚ü® 2 3 0 ‚ü©





--
e.g.
how to decode binary string to decimal: e.g. "1001" -> 9
    2 ‚ãÜ ‚Üï4
‚ü® 1 2 4 8 ‚ü©

    ‚åΩ2‚ãÜ‚Üï4
‚ü® 8 4 2 1 ‚ü©

    (‚åΩ2‚ãÜ‚Üï4) √ó "1001"-'0'
‚ü® 8 0 0 1 ‚ü©

    +¬¥ (‚åΩ2‚ãÜ‚Üï4) √ó "1001"-'0'
9

how about given a list of binary strings?
    '0' -Àú "01001110"‚Äø"01100101"‚Äø"01110010"‚Äø"01100100"‚Äø"00100001"
‚ü® ‚ü® 0 1 0 0 1 1 1 0 ‚ü© ‚ü® 0 1 1 0 0 1 0 1 ‚ü© ‚ü® 0 1 1 1 0 0 1 0 ‚ü© ‚ü® 0 1 1 0 0 1 0 0 ‚ü© ‚ü® 0 0 1 0 0 0 0 1 ‚ü© ‚ü©

# use Bind ‚ä∏ 	
# to 'pack' the data
    # like zip, take atom from LHS to zip with higher rank list on RHS e.g. 'a' ‚àæ "cd" ..
    "ab" ‚àæ¬® ‚ü® "cd", "ut" ‚ü© 
‚ü® "acd" "but" ‚ü© 
    # but, we can 'pack' "ab" as one thing, so "ab" ‚àæ "cd" instead
    "ab"‚ä∏‚àæ¬® ‚ü® "cd", "ut" ‚ü©
‚ü® "abcd" "abut" ‚ü©

    +¬¥¬® (‚åΩ2‚ãÜ‚Üï8)‚ä∏√ó¬® '0' -Àú "01001110"‚Äø"01100101"‚Äø"01110010"‚Äø"01100100"‚Äø"00100001"
‚ü® 78 101 114 100 33 ‚ü©

   # small breakdown for first element
+¬¥ ‚ü® 128 64 32 16 8 4 2 1 ‚ü© √ó ‚ü® 0 1 0 0 1 1 1 0 ‚ü©
   # =78


functions: take 1 or 2 data types as arguments
modifiers: modify the basic behaviour of function(s)

Precedence	Role	Associativity
0       	()‚ü®‚ü©	    (none)
1       	‚Äø	        Non-binary
2       	Modifier	Left-to-right
3       	Function	Right-to-left


--
Tacit programming

    |‚àò- 6
6

    7 |‚àò- 9
2

# |‚àò- is the absolute difference
    14‚Äø8 |‚àò- 19‚Äø6
‚ü® 5 2 ‚ü©
# sum of absolute differences in the Manhattan distance
    14‚Äø8 +¬¥‚àò|‚àò- 19‚Äø6
7

-**Combinators
        1-arg   2-arg
Àú	\`	Self	Swap
Àô	\"	Constant
‚àò	\j	Atop

-**Comparisons
<			    Less Than
>			    Greater Than
‚â†	\/	Length	Not Equals
=		Rank	Equals
‚â§	\<		    Less Than or Equal to
‚â•	\>		    Greater Than or Equal to

    3 < 4
1
    4 > ‚àû
0
    ‚àû < @  # Characters are always considered greater than numbers
1

    'e' = "George Boole"
‚ü® 0 1 0 0 0 1 0 0 0 0 0 1 ‚ü©

    +¬¥ 'e' = "George Boole"
3

    'e' +¬¥‚àò= "George Boole"  # With a combinator
3

-- Length and Rank
# Length - number of elements in a list
    ‚â† "testing"
7
    ‚â† ‚ü®‚ü©
0
    ‚â† ‚ü® œÄ, ‚àò, "element" ‚ãÑ ‚ü®'l',1,5,'t'‚ü© ‚ü©
4
    ‚â† 4
1

# Rank
    = 0.5
0
    = ‚Üï3
1
    = 'a'
0
    = "a"
1

# Depth (‚â°) gives the recursive nesting depth of its argument: the greatest number of times you can take an element before reaching an atom.
    ‚â° "dream"                  # An ordinary dream
1
    ‚â° "d"‚Äø"r"‚Äø"e"‚Äø"a"‚Äø"m"      # What if the letters were strings?
2
    ‚â° ‚ü® "d"‚Äø"r"‚Äø"e"‚Äø"a"‚Äø"m" ‚ü©  # We have to go deeper
3

-** Whole array comparisons
‚â°	\m	Depth	Match
‚â¢	\M	Shape	Not Match

    "abcd" ‚â° "abdd"
0
    "abc"‚Äø"de" ‚â° "abc"‚Äø"de"
1
    2‚Äø3‚Äø4‚Äø2 ‚â† 3‚Äø3‚Äø2‚Äø2  # compare individual atoms
‚ü® 1 0 1 0 ‚ü©
    2‚Äø3‚Äø4‚Äø2 ‚â¢ 3‚Äø3‚Äø2‚Äø2  # compare whole array
1

# How to test whether 2 arrays have same length?
    (‚â†"string") = ‚â†"sting"  # yes.. but ugly 
0

# Introduce another composition modifier
‚óã	\k	Over

    "string" =‚óã‚â† "sting"
0

Over calls its right operand on each argument individually. The results are then all used as arguments to the left operand. If there's only one argument, Atop and Over turn out to be the same: both of them call the right operand, then the left.
       Atop
    ùîΩ         ùîΩ
    |         |
    ùîæ         ùîæ
    |       /   \
    ùï©      ùï®     ùï©

  ùîΩ‚àòùîæ ùï©     ùï® ùîΩ‚àòùîæ ùï©     => ùîΩ (ùï® ùîæ ùï©)

       Over

    ùîΩ         ùîΩ
    |       /   \
    ùîæ      ùîæ     ùîæ
    |      |     |    
    ùï©      ùï®     ùï©

  ùîΩ‚óãùîæ ùï©     ùï® ùîΩ‚óãùîæ ùï©    => (ùîæ ùï®) ùîΩ (ùîæ ùï©)

--
Before and after
‚ä∏	\h	Before/Bind
‚üú	\l	After/Bind

Before ùîΩ‚ä∏ùîæ ùï©, ùï® ùîΩ‚ä∏ùîæ ùï©   # Left ùîΩ executes first
After ùîΩ‚üúùîæ ùï©, ùï® ùîΩ‚üúùîæ ùï©    # Right ùîæ  executes first

https://mlochbaum.github.io/BQN/doc/primitive.html

After	  Before
2 ‚ãÜ‚üú- 3	  2  ‚ãÜ‚ä∏-  3
2 ‚ãÜ - 3	  (‚ãÜ 2) - 3

    4 -‚ä∏‚åΩ " before"  # Rotate to the right by four
"fore be"
    4 ‚åΩ‚Åº  " before"  # Okay this time Undo is better
"fore be"
#actually can also be simply
¬Ø4‚åΩ" before"

# for one argument case, the one argument is used in both input positions
e.g.
‚Üï8 gives us eight equally-spaced numbers, but to rescale them we'd want to divide by 8. That's (‚Üï8)√∑8, but it's nicer to use Before again.

    ‚Üï‚ä∏√∑ 8   #one argument case, same as (‚Üï8)‚ä∏√∑8
‚ü® 0 0.125 0.25 0.375 0.5 0.625 0.75 0.875 ‚ü©

    ¬¨‚ä∏√ó ‚Üï‚ä∏√∑ 8    #  ¬¨‚ä∏√ó is y = x √ó ( 1 - x)
‚ü® 0 0.109375 0.1875 0.234375 0.25 0.234375 0.1875 0.109375 ‚ü©

# The below are all same
Before		    After
2‚ä∏‚ãÜ 5	2 ‚ãÜ 5	‚ãÜ‚üú5 2

only slight confusion is the 'After' case, the `5 2` is treated as the 5Àô2, with 2 being the data type input
this 2 only gets used in LHS, hence it becomes
2 ‚ãÜ 5Àô2  = 2 ‚ãÜ 5 = 32

--
*Side note
Constant modifier Àô

"hi"Àô 5
"hi"

4Àô5
4

Swap modifier also exhibit this property
    "const"Àú 5
"const"
    @ "const"Àú 6
"const"

The modifier Àú applies its operand function to the arguments, after swapping them around or whatever. In this case, the operand function is a data type (not a function or modifier), so it ignores those arguments

so, the below works, as applying data type as operand will ignore the argument
    1‚ä∏+ 5 # also (1 5) + 5 = 1 + 5
6
    +‚üú1 5 # also, 5 + (1 5) = 5 + 1
6

--
Exercise:

# how to do tacit programming which accepts 8 as an argument?
    (‚Üï8) √∑ 7
‚ü® 0 0.1428571428571428 0.2857142857142857 0.4285714285714285 0.5714285714285714 0.7142857142857143 0.8571428571428571 1 ‚ü©

    -‚üú1 8
7

    ‚Üï‚ä∏√∑‚üú(-‚üú1) 8
‚ü® 0 0.1428571428571428 0.2857142857142857 0.4285714285714285 0.5714285714285714 0.7142857142857143 0.8571428571428571 1 ‚ü©

# some deconstruction
    ‚Üï‚ä∏ √∑ ‚üú F 8
# 8 gets 'dup/bind over' to LHS by middle right bind‚üú
    8 ‚Üï‚ä∏ √∑  F 8
# 8 ‚Üï‚ä∏ left bind becomes (‚Üï 8)
    (‚Üï 8) √∑  F 8
    (‚Üï 8) √∑  7

# the big expression above can also be shorten into a 3-train (a fork)
    (‚Üï√∑-‚üú1) 8
‚ü® 0 0.1428571428571428 0.2857142857142857 0.4285714285714285 0.5714285714285714 0.7142857142857143 0.8571428571428571 1 ‚ü©

# basically execute (f g h) 8 => (f 8) g (h 8)
# (‚Üï 8) √∑ ((-‚üú1) 8)
# when a bunch of isolated functions / modifiers are jammed together, the
# association is from left to right
--
the APL ‚ç¥ , shape, reshape operator is split into 

   1-arg   2-arg
‚•ä  deshape reshape  (\z)
‚â¢  shape   not match (\M)

‚Üï4‚Äø5
‚îå‚îÄ                                         
‚ïµ ‚ü® 0 0 ‚ü© ‚ü® 0 1 ‚ü© ‚ü® 0 2 ‚ü© ‚ü® 0 3 ‚ü© ‚ü® 0 4 ‚ü©  
  ‚ü® 1 0 ‚ü© ‚ü® 1 1 ‚ü© ‚ü® 1 2 ‚ü© ‚ü® 1 3 ‚ü© ‚ü® 1 4 ‚ü©  
  ‚ü® 2 0 ‚ü© ‚ü® 2 1 ‚ü© ‚ü® 2 2 ‚ü© ‚ü® 2 3 ‚ü© ‚ü® 2 4 ‚ü©  
  ‚ü® 3 0 ‚ü© ‚ü® 3 1 ‚ü© ‚ü® 3 2 ‚ü© ‚ü® 3 3 ‚ü© ‚ü® 3 4 ‚ü©  
                                          ‚îò
‚â¢‚Üï4‚Äø5
‚ü® 4 5 ‚ü©

4‚Äø2‚•ä‚Üï4‚Äø5
‚îå‚îÄ                 
‚ïµ ‚ü® 0 0 ‚ü© ‚ü® 0 1 ‚ü©  
  ‚ü® 0 2 ‚ü© ‚ü® 0 3 ‚ü©  
  ‚ü® 0 4 ‚ü© ‚ü® 1 0 ‚ü©  
  ‚ü® 1 1 ‚ü© ‚ü® 1 2 ‚ü©  
                  ‚îò
‚•ä4‚Äø2‚•ä‚Üï4‚Äø5
‚ü® ‚ü® 0 0 ‚ü© ‚ü® 0 1 ‚ü© ‚ü® 0 2 ‚ü© ‚ü® 0 3 ‚ü© ‚ü® 0 4 ‚ü© ‚ü® 1 0 ‚ü© ‚ü® 1 1 ‚ü© ‚ü® 1 2 ‚ü© ‚ü©

--
Train
BQN trains are same as Dyalog APL with the addition of Nothing (¬∑)

--
Dot product


# uses the Atop ‚àò in BQN.. doesnt need a special . syntax like in APL
1‚Äø2‚Äø3 +¬¥‚àò√ó 4‚Äø5‚Äø6
32

# favourite 3 x 4 matrix
3‚Äø4‚•ä‚Üï12
‚îå‚îÄ           
‚ïµ 0 1  2  3  
  4 5  6  7  
  8 9 10 11  
            ‚îò

--
Define ‚Üê \[
A variable cannot be defined twice in the same scope

    pi‚Äøe‚Äøten ‚Üê ‚ü® œÄ, ‚ãÜ1, 10 ‚ü©
‚ü® 3.141592653589793 2.718281828459045 10 ‚ü©

    ten √ó pi
31.41592653589793

    three ‚âç ten - three ‚Üê 3
‚ü® 3 7 ‚ü©

    three ‚Üê 4
ERROR

Change (Reassign) ‚Ü© \'

    three ‚Ü© 4

    three = 3   # Wait why did I do that
0

    3 = three ‚Ü© 3
1

    four ‚Ü© 3    # four isn't defined yet
ERROR

If you're coming from a typical curly-brace language, you'd say that ‚Üê both declares and assigns a variable, while ‚Ü© only assigns it.
-
    a ‚Üê 4            # First it's a number
    a
4

    a ‚Ü© 4‚Äø5‚Äø6        # Now it's a list!
    a
‚ü® 4 5 6 ‚ü©

    a ‚Ü© a - 1
    a
‚ü® 3 4 5 ‚ü©

    a -‚Ü© 1 # shorthand - modified assignment, looks like -= or +=
‚ü® 2 3 4 ‚ü©

    a ‚àæÀú‚Ü© 0‚Äø1 # a ‚Üê a ‚àæÀú 0‚Äø1
‚ü® 0 1 2 3 4 ‚ü©

--
1‚Äø2 (4‚ä∏-) ‚àò ‚ä£ @
‚ü® 3 2 ‚ü©
  
#remember Atop

   ùîΩ   (4‚ä∏-)
   |
   ùîæ   ‚ä£    # left identity, only return left arg if there's one
  / \
 ùï®   ùï©
1‚Äø2  @
--
#so, how about function with only one argument?
    a ‚åΩ‚àò‚ä£‚Ü© @
‚ü® 4 3 2 1 0 ‚ü©
# but BQN has a simpler syntax
# sort of like a reversed way of saying: "a reversed is"
    a ‚åΩ‚Ü©
‚ü® 0 1 2 3 4 ‚ü©

    a 4‚ä∏-‚Ü©           # And back again
‚ü® 4 3 2 1 0 ‚ü©
# no need parentheses on the 2-train (4‚ä∏-) becoz modifiers bind stronger
than assignment character

# with this
    -‚üú4‚åæ(¬Ø2‚ä∏‚Üë) a
‚ü® 4 3 2 ¬Ø3 ¬Ø4 ‚ü©
# we can reassign like this
    a -‚üú4‚åæ(¬Ø2‚ä∏‚Üë)‚Ü©
‚ü® 4 3 2 ¬Ø3 ¬Ø4 ‚ü©


--
Role

Spelling	       Role	        Purpose
lowercase	       Subject	    Argument or operand
Uppercase	       Function	    Function call or operand
_leftUnderscore	   1-modifier	1-modifier call
_twoUnderscores_   2-modifier	2-modifier call

The role only depends on the first character of the name, and the last one if the first one was an underscore.

---
Variable are case insensitive

three ‚Üê 3

ThReE
3

---
Function assignment

    Base2 ‚Üê +‚üú(2‚ä∏√ó)¬¥‚àò‚åΩ

    Base2 1‚Äø0‚Äø1‚Äø0
10

    Base2 "01010001"-'0'
81

    @ + Base2¬® '0' -Àú "01000010"‚Äø"01010001"‚Äø"01001110"
"BQN"

--
    Base2
+‚üú(2‚ä∏√ó)¬¥‚àò‚åΩ

    base2 ‚Ü© 16   # Change it to a number

    Base2
16

    Base2 6  # constant function
16

---
Modifiers
‚åæ	\K	Under (only 2-arg, right arg is a function)
‚äë	\I	First	Pick

‚äë "BQN"
'B'
1 ‚äë "BQN"
'Q'

    ‚ä¢ a ‚Üê 'a' + ‚•ä‚üú(‚Üï√ó¬¥) 4‚Äø5
‚îå‚îÄ       
‚ïµ"abcde  
  fghij  
  klmno  
  pqrst" 
        ‚îò
    2‚Äø0 ‚äë a
'k'
    1‚Äø¬Ø1 ‚äë a
'j'

# Pick accepts a list of indices
# a is 2D matrix
    ‚ü®2‚Äø0, 1‚Äø¬Ø1, 3‚Äø1, ¬Ø1‚Äø¬Ø1‚ü© ‚äë a
"kjqt"

--
    ‚ü®2,1,0,¬Ø1‚ü© ‚äë "abc"  # ùï© doesn't have rank 4! i.e ùï© need to be 4D
ERROR

    ‚ü®2,1,0,¬Ø1‚ü© ‚•ä¬®‚ä∏‚äë "abc"
"cbac"

#Breakdown
    (‚•ä¬®‚ü®2,1,0,¬Ø1‚ü©) ‚äë "abc"
#note, ‚•ä2 = ‚ü®2‚ü©
    ‚ü® ‚ü® 2 ‚ü© ‚ü® 1 ‚ü© ‚ü® 0 ‚ü© ‚ü® ¬Ø1 ‚ü© ‚ü© ‚äë "abc"
"cbac"

    ‚ü®2,1,0,¬Ø1‚ü© ‚äè "abc"  # Better way `‚äè` is select 
"cbac"

    ‚ü®2‚Äø0, ‚ü®‚ü®1‚Äø¬Ø1, 3‚Äø1‚ü©, ¬Ø1‚Äø¬Ø1‚ü©‚ü© ‚äë a
‚ü® 'k' ‚ü® "jq" 't' ‚ü© ‚ü©

    (‚ü®2‚Äø0, 1‚Äø¬Ø1‚ü©‚âç‚ü®3‚Äø1, ¬Ø1‚Äø¬Ø1‚ü©) ‚äë a
‚îå‚îÄ    
‚ïµ"kj  
  qt" 
     ‚îò

    (‚ü®2‚Äø0, <1‚Äø¬Ø1‚ü©‚âç‚ü®<3‚Äø1, ¬Ø1‚Äø¬Ø1‚ü©) ‚äë a  # `<` is encase
‚îå‚îÄ             
‚ïµ 'k'   ‚îå¬∑     
        ¬∑'j'   
            ‚îò  
  ‚îå¬∑    't'    
  ¬∑'q'         
      ‚îò        
              ‚îò
---
difference
   2‚Äø0‚äè‚Üï4‚Äø5 # select major axis
‚îå‚îÄ
‚ïµ ‚ü® 2 0 ‚ü© ‚ü® 2 1 ‚ü© ‚ü® 2 2 ‚ü© ‚ü® 2 3 ‚ü© ‚ü® 2 4 ‚ü©
  ‚ü® 0 0 ‚ü© ‚ü® 0 1 ‚ü© ‚ü® 0 2 ‚ü© ‚ü® 0 3 ‚ü© ‚ü® 0 4 ‚ü©
                                          ‚îò
   2‚Äø0‚äë‚Üï4‚Äø5 # pick element
‚ü® 2 0 ‚ü©

   ‚ü®<2,<0‚ü©‚äè‚Üï4‚Äø5 # like this also can, but awkward
‚îå¬∑
¬∑ ‚ü® 2 0 ‚ü©
          ‚îò


--
Under ‚åæ	
    8‚åæ‚äë "BQN"        # Change the first element to 8
‚ü® 8 'Q' 'N' ‚ü©

‚Üë	\r Prefixes Take
‚Üì	\c Suffixes Drop
--
Use before combinator ‚ä∏ to make a standalone function (2 or 3-train)

2 ‚Üë "abcde"
"ab"
#what if i want to single out (2 ‚Üë) as a function itself?
Func1 ‚Üê 2 ‚Üë
Second-level parts of a train must be functions
Func1 ‚Üê 2 ‚Üë
        ^
# this happens becoz we are defining a 2-train, but `2` here is not a
# function
Func2 ‚Üê √∑√ó #this works, 2 functions here
Func2 100 #take the sign of the right arg and then the reciprocal of it
1
2 Func2 5 # 1 √∑ (2 √ó 5)
0.1

#so, we can use the before combinator ‚ä∏
#becoz 2‚ä∏ will execute first and give 2
Func1 ‚Üê 2‚ä∏‚Üë
Func1 "abcde"
"ab"

#some variations
Func1 ‚Üê 2‚üú‚Üë   # the right `after` part execute first, and then 2 just const
Func1 "abcde"
2
Func1 ‚Üê 2Àô‚Üë  # its same as this
Func1 "abcde"
2

Prefixes / Suffixes (different from APL)
    ‚Üë ‚Üï5
‚ü® ‚ü®‚ü© ‚ü® 0 ‚ü© ‚ü® 0 1 ‚ü© ‚ü® 0 1 2 ‚ü© ‚ü® 0 1 2 3 ‚ü© ‚ü® 0 1 2 3 4 ‚ü© ‚ü©

    ‚Üì ‚Üï5
‚ü® ‚ü® 0 1 2 3 4 ‚ü© ‚ü® 1 2 3 4 ‚ü© ‚ü® 2 3 4 ‚ü© ‚ü® 3 4 ‚ü© ‚ü® 4 ‚ü© ‚ü®‚ü© ‚ü©

--
Back to Under ‚åæ	
Right operand - some selection functions
    8‚åæ‚äë "BQN"        # Change the first element to 8
‚ü® 8 'Q' 'N' ‚ü©
    ‚Üï7
‚ü® 0 1 2 3 4 5 6 ‚ü©

    4 ‚Üë ‚Üï7           # The first four elements
‚ü® 0 1 2 3 ‚ü©

    ‚åΩ‚åæ(4‚ä∏‚Üë) ‚Üï7       # And reverse them
‚ü® 3 2 1 0 4 5 6 ‚ü©

    ‚åΩ‚åæ(¬Ø4‚ä∏‚Üë) ‚Üï7      # Or reverse the last four
‚ü® 0 1 2 6 5 4 3 ‚ü©

# ‚åæ seems to take either a data value (which it replaces) or an operation on the Left (i.e an operand)

# 2 2-trains below
    2‚ä∏‚åΩ‚åæ(1‚ä∏‚äë) "xyz"‚Äø"ABCDE"‚Äø"wxyz"‚Äø"yz"
‚ü® "xyz" "CDEAB" "wxyz" "yz" ‚ü©

    2‚ä∏‚åΩ‚åæ(2‚ä∏‚Üì) "XYabcde"
"XYcdeab"

# slice a list at point 2, length 2
    2 ‚Üë 4 ‚Üì "abcdefgh"
"ef"

# convert that slice to Uppercase
# ('A'-'a')‚ä∏+ is a 2-trains
    ('A'-'a')‚ä∏+ ‚åæ (2 ‚Üë 4‚ä∏‚Üì)  "abcdefgh"
"abcdEFgh"
# "ef" - 32 = "EF"
--
What Under is actually doing
1.
F‚åæG y	Under: apply G, then F, then undo G
(1‚ä∏+) ‚åæ (1‚ä∏-) ‚Üï3
‚ü® ¬Ø1 0 1 ‚ü©
# first apply (1‚ä∏-) ‚Üï3
# 1 - ‚ü® 0 1 2 ‚ü©
‚ü® 1 0 -1 ‚ü©
# then apply (1‚ä∏+) on this
‚ü® 2 1 0 ‚ü©
# then Undo G on this
# (1‚ä∏-)‚Åº ‚ü® 2 1 0 ‚ü©
‚ü® ¬Ø1 0 1 ‚ü©
# for Undo, need to think of
ùï© ‚â° ùîΩ ùîΩ‚Åº ùï©
# that is, the {..} block needs to give an ans which satisfy 
# the below eq
‚ü® 2 1 0 ‚ü© ‚â° (1‚ä∏-) {(1‚ä∏-)‚Åº ‚ü® 2 1 0 ‚ü©} 
# so the ans is ‚ü® ¬Ø1 0 1 ‚ü©

2.
x F‚åæG y	Under: apply F‚óãG, then undo G # notice is F Over G
# that means, G‚Åº [(G x) F (G y)]
e.g.
2 √ó‚åæ(1‚ä∏-) ‚Üï3
‚ü® 2 1 0 ‚ü©

G‚Üê1‚ä∏-
F‚Üê√ó

(G 2) F (G ‚Üï3) 
‚ü® ¬Ø1 0 1 ‚ü©

G‚Åº ¬Ø1‚Äø0‚Äø1
‚ü® 2 1 0 ‚ü©


--
Difference btw Pick and Take

1‚äë"abced"
'b'  # pick an element based on index

1‚Üë"abced"
"a"  # take part of the list (or array)

#‚åæ takes 2 operands 
#below, both operands are 2-trains
(1‚ä∏+) ‚åæ (1‚ä∏‚äë) "abced"
"acced"
#if we use `take`, we need to replace with an equivalent rank list
"z"‚åæ (1‚ä∏‚Üë) "bqn"

---
Logical operation

Not ‚Üê 1+-  # also Span
And ‚Üê √ó
Or  ‚Üê √ó‚åæ¬¨

for Or, the definition is 
    A ‚à® B = ¬¨(¬¨A ‚àß ¬¨B)
so for above,
    ùï® √ó‚åæ¬¨ ùï© =  ¬¨‚Åº(¬¨ùï® √ó ¬¨ùï©)
# but ¬¨‚Åº ‚Üê‚Üí ¬¨, (an so is -‚Åº ‚Üê‚Üí -)
so,
    ùï® √ó‚åæ¬¨ ùï© =  ¬¨(¬¨ùï® √ó ¬¨ùï©)
Another definition is
Or  ‚Üê +-√ó

----
Namespace

#file.bqn
‚ü®something, DoThing‚ü©‚áê     # Declare exports
abbreviation ‚áê "sth"      # Define and export
_something ‚Üê {ùïó}          # Separate definition
DoThing ‚Üê "TODO"‚ä∏!

#some other file at same folder
ns ‚Üê ‚Ä¢Import "file.bqn"
‚ü®something, abbr‚áêabbreviation‚ü© ‚Üê ns  # Destructure
ns.DoThing 6   


#exports
example ‚Üê {
  b‚Äøc‚áê   # Non-definition exports can go anywhere
  a‚áê2    # Define and export
  b‚Üê1+a
  c‚Üêb‚Äø"str"
}

#imports
‚ü®alias‚áêa, b, c0‚Äøc1‚áêc, b2‚áêb‚ü© ‚Üê example

#another example of imports (without using ‚áê)
c‚Äøa ‚Üê example

#using dot .
example.b

{n‚áê7}.n

--
Block

    a‚Üêb‚Üê"outer"
"outer"
    { a‚Üê"inner" ‚ãÑ a‚Äøb } # block here, with local scoping & a separator, executed from L to R
‚ü® "inner" "outer" ‚ü©
    a
"outer"
--
Lowercase	Uppercase	Meaning
ùï©	        ùïè	        Right argument
ùï®	        ùïé	        Left argument, or Nothing (¬∑)
ùï§	        ùïä	        Function self-reference
ùïó	        ùîΩ	        Left operand
ùïò	        ùîæ	        Right operand
ùï£	        none	    Modifier self-reference

ùï©, ùï® => right, left data argument
ùïè, ùïé => right, left function argument

    {'c'=ùï©} "abcd"
‚ü® 0 0 1 0 ‚ü©
    { ùï©+‚Ü©2 ‚ãÑ 0‚âçùï© } 3  # change of value for ùï©
‚ü® 0 5 ‚ü©
    4 { ‚ü®ùï©‚ãÑ-ùï®‚ü© } 5
‚ü® 5 ¬Ø4 ‚ü©

--
    3 { (2√óùï®)-ùï© } 1
5
      { (2√óùï®)-ùï© } 1  # left argument is ¬∑ Nothing  
¬Ø1
--
    "abc" { (ùï®‚âç‚åΩ) ùï© } "def"
‚îå‚îÄ     
‚ïµ"abc  
  fed" 
      ‚îò
          { (ùï®‚âç‚åΩ) ùï© } "def" # ùï® behaves just like ¬∑ Nothing
‚îå‚îÄ     
‚ïµ"fed" 
      ‚îò

    { ùï® ‚ãÜ‚ä∏- ùï© } 5 # this behaves as { ¬∑ ‚ãÜ‚ä∏- ùï© } 5, which is ‚ãÜ‚ä∏- ùï©
143.4131591025766

--
ùïó	        ùîΩ	        Left operand
ùïò	        ùîæ	        Right operand

--
# doesnt really make sense to use data type as operands
# but it will just return itself
    4 {√óÀúùïó}
16
    2 {ùïó+ùïò} 3
5

# if try to pass in a function with lowercase ùïó, it will error out
    √ó {√óÀúùïó}
Error: √ó: Unexpected argument types
# Uppercase ùîΩ is ok
    √ó {√óÀúùîΩ}
√óÀú√ó
    _dot_ ‚Üê {ùîΩ¬¥‚àòùîæ}   #_dot_ is a 'deferred modifier', it's content is only evaluate when the modifier is called
    1‚Äø2‚Äø3 +_dot_√ó 1‚Äø0‚Äø1
4

    +{ùï©ùîΩùï©} 6
12
    2 ‚•ä{‚ü®ùîΩùï®,ùîæùï©‚ü©}- 5
‚ü® ‚ü® 2 ‚ü© ¬Ø5 ‚ü©

--
Self-reference
If a block is assigned a name after it is created, this name can be used for recursion:

# (0‚ä∏<)‚ó∂1‚ÄøFact ùï©-1, based on breakdown below is return Fact(ùï© - 1) if ùï© - 1 is > 0;
# else return 1 (this is the base case)
# Fact(ùï© - 1) .. is essentially { (ùï© - 1) √ó Fact (ùï© - 2) .. √ó 1 }
    Fact ‚Üê { ùï© √ó (0‚ä∏<)‚ó∂1‚ÄøFact ùï©-1 } 
    Fact 7
5040
    (√ó¬¥1+‚Üï) 7  # There's often a simpler solution than recursion
5040

# we can use self reference ùïä to refer to the function it appears in
#this allows for anonymous recursive function
    { ùï© √ó (0‚ä∏<)‚ó∂1‚Äøùïä ùï©-1 } 7
5040

--
Self-reference modifier ùï£
Refers to the 'containing modifier', while ùïä refers to the 'entire' function it appears in
Only refers to 1-modifier or 2-modifier, so can only be written as _ùï£ or _ùï£_
    Fact_mod ‚Üê 1 { (0‚ä∏<)‚ó∂‚ü®ùïó, (ùïó√óùï©)_ùï£‚ü© ùï©-1 }
    Fact_mod 7
5040



There must be a space in between the Left operand and _ùï£
    Fact2 ‚Üê 1 { (0‚ä∏<)‚ó∂‚ü®ùïó, ùïó√óùï© _ùï£‚ü© ùï©-1 }   # this is valid
1(1-modifier block)
    Fact2 7
5040



--
Block headers

Fact ‚Üê { F n:   # F is only defined inside {} while Fact can be used inside or outside
  n √ó (0‚ä∏<)‚ó∂1‚ÄøF n-1
}

# A dyadic function that refers to itself as Func
{ l Func r:
  ‚Ä¶

# A deferred 1-modifier with a list argument
{ Fn _apply ‚ü®a,b‚ü©:
  ‚Ä¶

# A monadic function with no names given
{ ùïäùï©:
  ‚Ä¶

# An immediate (??) or deferred 2-modifier
{ F _op_ val:
  ‚Ä¶

# for the example above; a header is the same as a series of assignments for a
# headless block
{ # Fn _apply ‚ü®a,b‚ü©:
  Fn ‚Üê ùîΩ
  _apply ‚Üê _ùï£    # this monadic 1-modifier cannot take a right operand ùîæ or left argument ùï®
  ‚ü®a,b‚ü© ‚Üê ùï©
  ‚Ä¶

# header destructuring
    Destruct ‚Üê { ùïä a‚Äø1‚Äø‚ü®b,2‚ü©: a‚âçb }
    Destruct       5‚Äø1‚Äø‚ü®7,2‚ü©
‚ü® 5 7 ‚ü©

# nameless block is possible by incoorporating all the special names
# most vague header
ùï® ùîΩ_ùï£_ùîæ ùï©:

--
Short headers (without inputs specified) - AKA 'label'

{ b:   # Block
{ ùïä:   # Function
{ _ùï£:  # 1-Modifier
{ _ùï£_: # 2-Modifier

Label doesnt restrict inputs; but already specify the type of block

--
Multiple bodies; will execute depending on arguments provided
    Ambiv ‚Üê { ‚ü®1,ùï©‚ü© ; ‚ü®2,ùï®,ùï©‚ü© }
    Ambiv 'a'
‚ü® 1 'a' ‚ü©
    'a' Ambiv 'b'
‚ü® 2 'a' 'b' ‚ü©

    CaseAdd ‚Üê { 2ùïä3:0‚Äø5 ; 2ùïäùï©:‚ü®1,2+ùï©‚ü© ; ùïäùï©:2‚Äøùï© }
    2 CaseAdd 3
‚ü® 0 5 ‚ü©
    2 CaseAdd 4
‚ü® 1 6 ‚ü©
      CaseAdd 4
‚ü® 2 4 ‚ü©

# Below, the function name ùïä  is ommited
Test ‚Üê {
  "abc": "string" ;
  ‚ü®2,b‚ü©: ‚åΩùï©       ;
  5:     "number" ;
  ùï©:     "default"
}

Test "abc"
"string"

Test ‚ü®2,5‚ü©
‚ü®5 2‚ü©

---
Predicate ?(and also ;) (** need to be INSIDE a block)

    CheckPair ‚Üê { ùïä‚ü®a,b‚ü©: a<b? "ok" ; "not ok" }

    CheckPair ‚ü®3,8‚ü©    # Fails destructuring
"ok"
    CheckPair ‚ü®1,4,5‚ü©  # Not a pair
"not ok"
    CheckPair ‚ü®3,¬Ø1‚ü©   # Not ascending
"not ok"

#it works similarily like a ternary statement
#doesnt necessary have to start with a header

    { r‚Üê‚åΩùï© ‚ãÑ 't'=‚äër ? r ; ùï© }¬® "test"‚Äø"this"
‚ü® "tset" "this" ‚ü©

{ a<b ? a ; b } is just computing a‚åäb

?; can support any number of options

#the structure below is "if _ and _ then _; else if _ then _; else _".
    Thing ‚Üê { ùï©‚â•3? ùï©‚â§8? 2|ùï© ; ùï©=0? @ ; ‚àû }

    (‚ä¢ ‚âç Thing¬®) ‚Üï10  # Table of arguments and results
‚îå‚îÄ                     
‚ïµ 0 1 2 3 4 5 6 7 8 9  
  @ ‚àû ‚àû 1 0 1 0 1 0 ‚àû  
                      ‚îò
#Same as this actually
#but due to precendece of ?, need to group (ùï©‚â•3)
#else, it would be ùï© ‚â• (3 ‚àß ùï©‚â§8)
Thing ‚Üê { (ùï©‚â•3) ‚àß ùï©‚â§8 ? 2|ùï© ; ùï©=0? @ ; ‚àû }

# at its simplest
   {1=1?‚Ä¢Show "yes"}
"yes"

# but if no `else` condition, it will throw if no matched `header`
   {1=0?‚Ä¢Show "yes"}
Error: No header matched arguments
at {1=0?‚Ä¢Show "yes"}


----
Valences
‚äò \%

{ùîΩùï©;ùï®ùîæùï©}	2-Modifier, Apply ùîΩ if there's one argument but ùîæ if there are two
# Blocks that define functions and deferred modifiers can include more than one body, separated by semicolons ;

Usage:
    5√ó‚äò-2
3
    √ó‚äò-2
1

--
Choose
‚ó∂ \$

{f‚Üê(ùï®ùîΩùï©)‚äëùïò ‚ãÑ ùï®Fùï©} 2-modifier, Select one of the functions in list ùïò based on ùîΩ

Usage:

    Func ‚Üê (0‚ä∏<)‚ó∂1‚Äø2
0‚ä∏<‚ó∂‚ü® 1 2 ‚ü©
    Func 1
2
    Func 0
1
    Func ¬Ø2
1
#breakdown (based on the definition)
    ((0‚ä∏<)1)‚äë1‚Äø2 # if ùï© is 1 or larger, its more than 0, so 1‚äë1‚Äø2 = 2
2
    ((0‚ä∏<)¬Ø2)‚äë1‚Äø2 # if ùï© is lesser than 0, 0‚äë1‚Äø2 = 1, LHS can only be 1 or 0 
1
    for next statement ùï®Fùï©, due to ùï® is nothing, basically just return const Fùï©
    so return 1 if ùï© is larger than 0; else return 2 

----
Fill element
basically 0 for numbers, ' ' for characters, ‚ü®‚ü© for array

    ¬Ø7 ‚Üë 4‚•ä3     # Fill with 0
‚ü® 0 0 0 3 3 3 3 ‚ü©

    ¬Ø7 ‚Üë "qrst"  # Fill with space
"   qrst"

    ¬ª¬® ‚ü®4‚•ä3,"qrst"‚ü©   # nudge right
‚ü® ‚ü® 0 3 3 3 ‚ü© " qrs" ‚ü©

    3‚Üë‚ü®‚ü©  # Fill unknown
‚ü® 0 0 0 ‚ü©

    ¬ª‚ü®‚ü©   # Fill not needed
‚ü®‚ü©

# reshape fill when ùï® contains ‚Üë and the product of the rest of ùï® doesn't evenly divide the number of elements in ùï©
    ‚Üë‚Äø8 ‚•ä "completepart"
‚îå‚îÄ          
‚ïµ"complete  
  part    " 
           ‚îò
    ¬ª "abc" + 4‚Äø3‚Äø2
" ee"

#to find out fill element
# deshape, take one, nudge right, pick first one
    ‚äë¬ª1‚Üë‚•ä"string" 
' '

    6 ‚Üë ‚Üë‚Üï3  # Two fills at the end
‚ü® ‚ü®‚ü© ‚ü® 0 ‚ü© ‚ü® 0 1 ‚ü© ‚ü® 0 1 2 ‚ü© ‚ü®‚ü© ‚ü®‚ü© ‚ü©

    ¬ª¬® 3‚Äø4‚Äø1 /‚ä∏‚äî "abc0123A"
‚ü® " ab" " 012" " " ‚ü©

----
Leading axis refers to the initial axis

Rank (‚éâ) or Cells (Àò) modifier


# about ranks
= 9 # rank 0
= "abcd" # rank 1
= 3‚Äø4‚•ä"abcd" # rank 2
= 3‚Äø3‚Äø4‚•ä‚Üï36 # rank 3

#using the 3‚Äø3‚Äø4‚•ä‚Üï36 example, 

Rank 3 - Rank 2 - Rank 1 - Rank 0
  3    ‚Äø   3    ‚Äø   4      ...
  

    a ‚Üê 3‚Äø2‚•ä (+‚üú'a')‚Üï6
‚îå‚îÄ    
‚ïµ"ab  
  cd  
  ef" 
     ‚îò
    ‚â¢‚âça  #added one axis in front of Rank 2, hence becomes rank 3
‚ü® 1 3 2 ‚ü©
    =‚âça  #use this to confirm no of Rank
3

#added one axis in front Rank 1 (the Rank where it becomes 'Cells')
#Àò operates on Major Cells, which is Rank - 1
    ‚âçÀòa  
‚îå‚îÄ    
‚ïé"ab  
      
 ¬∑cd  
      
 ¬∑ef" 
     ‚îò
    ‚â¢‚âçÀòa    # coupled an empty 'row' on top of each row
‚ü® 3 1 2 ‚ü©
    (3‚Äø2‚•ä‚Üï6)‚âçÀòa
‚îå‚îÄ         
‚ïé 0   1    
  'a' 'b'  
           
  2   3    
  'c' 'd'  
           
  4   5    
  'e' 'f'  
          ‚îò
    ‚â¢(3‚Äø2‚•ä‚Üï6)‚âçÀòa
‚ü® 3 2 2 ‚ü©

# ùîΩÀò is identical to ùîΩ‚éâ1
    (3‚Äø2‚•ä‚Üï6)‚âç‚éâ1 a
‚îå‚îÄ         
‚ïé 0   1    
  'a' 'b'  
           
  2   3    
  'c' 'd'  
           
  4   5    
  'e' 'f'  
          ‚îò

# below two are identical
    ‚â¢(3‚Äø2‚•ä‚Üï6)‚âç‚éâ2 a
‚ü® 2 3 2 ‚ü©
    (3‚Äø2‚•ä‚Üï6)‚âç‚éâ2 a
‚îå‚îÄ         
‚ïé 0   1    
  2   3    
  4   5    
           
  'a' 'b'  
  'c' 'd'  
  'e' 'f'  
          ‚îò
    (3‚Äø2‚•ä‚Üï6)‚âç a
‚îå‚îÄ         
‚ïé 0   1    
  2   3    
  4   5    
           
  'a' 'b'  
  'c' 'd'  
  'e' 'f'  
          ‚îò
# coupling beyong existing Ranks doesnt do anything fancy
    (3‚Äø2‚•ä‚Üï6)‚âç‚éâ3 a  
‚îå‚îÄ         
‚ïé 0   1    
  2   3    
  4   5    
           
  'a' 'b'  
  'c' 'd'  
  'e' 'f'  
          ‚îò

    (3‚Äø2‚•ä‚Üï6)‚âç‚éâ0 a  # create a new Rank 1 axis
‚îå‚îÄ       
‚ïé 0 'a'  
  1 'b'  
         
  2 'c'  
  3 'd'  
         
  4 'e'  
  5 'f'  
        ‚îò
    ‚â¢(3‚Äø2‚•ä‚Üï6)‚âç‚éâ0 a
‚ü® 3 2 2 ‚ü©


#‚éâ¬Ø1 seems same as ‚éâ1
#if the right operand ùïò of ‚éâ is negative, its interpreted as 0‚åàRank+ùïò 
#Therefore, a value of ¬Ø1 selects major cells.
    (3‚Äø2‚•ä‚Üï6)‚âç‚éâ¬Ø1 a
‚îå‚îÄ         
‚ïé 0   1    
  'a' 'b'  
           
  2   3    
  'c' 'd'  
           
  4   5    
  'e' 'f'  
          ‚îò
    ‚â¢‚âç‚éâ¬Ø1 a
‚ü® 3 1 2 ‚ü©

# but going beyond ¬Ø1 is same as ‚éâ0
    ‚â¢‚âç‚éâ¬Ø2 a
‚ü® 3 2 1 ‚ü©
    ‚â¢‚âç‚éâ¬Ø3 a
‚ü® 3 2 1 ‚ü©
    ‚â¢‚âç‚éâ¬Ø100 a
‚ü® 3 2 1 ‚ü©

#what are major cells?
https://help.dyalog.com/18.0/Content/Language/Introduction/Variables/Cells%20and%20Subarrays.htm#CellsSubarrays

#all about Rank ‚éâ (its the same as APL ‚ç§) 
https://help.dyalog.com/18.0/?skinName=Large#Language/Primitive%20Operators/Rank.htm
‚éâ takes a ùïò scalar or vector of up to 3 items

    s
"abracadabra"
    s ‚àæ‚éâ0‚Äø1 "suffix"   # same as 1‚Äø0‚Äø1 "suffix"
‚îå‚îÄ         
‚ïµ"asuffix  
  bsuffix  
  rsuffix  
  asuffix  
  csuffix  
  asuffix  
  dsuffix  
  asuffix  
  bsuffix  
  rsuffix  
  asuffix" 
          ‚îò
breakdown:
 ‚âç‚éâ0 s
‚îå‚îÄ   
‚ïµ"a  
  b  
  r  
  a  
  c  
  a  
  d  
  a  
  b  
  r  
  a" 
    ‚îò    

  ‚âç‚éâ1 "suffix"
‚îå‚îÄ        
‚ïµ"suffix" 
         ‚îò
# so take the Rank 0 of s and join with Rank 1 (major cell) of "suffix"

‚äí is occurence counter, returns the index of leading axis (or called first axis or major cells)
    s ‚Üê "abracadabra"
    ‚äí s
‚ü® 0 0 0 1 0 2 0 3 1 1 4 ‚ü©
    ‚äí ‚âçÀò s
‚ü® 0 0 0 1 0 2 0 3 1 1 4 ‚ü©
    ‚äí s ‚àæ‚éâ0‚Äø1 "suffix"
‚ü® 0 0 0 1 0 2 0 3 1 1 4 ‚ü©

    b ‚Üê 4‚Äø5 ‚•ä ‚Üï4
‚îå‚îÄ           
‚ïµ 0 1 2 3 0  
  1 2 3 0 1  
  2 3 0 1 2  
  3 0 1 2 3  
            ‚îò
    ‚à® b  # sort by cols
‚îå‚îÄ           
‚ïµ 3 0 1 2 3  
  2 3 0 1 2  
  1 2 3 0 1  
  0 1 2 3 0  
            ‚îò

    ‚à®Àòb  # sort by rows (major cells)
‚îå‚îÄ           
‚ïµ 3 2 1 0 0  
  3 2 1 1 0  
  3 2 2 1 0  
  3 3 2 1 0  

    2‚Äø1 ‚åΩ ‚Üï3‚Äø5 # rotate; shift once to left and twice upward
‚îå‚îÄ                                         
‚ïµ ‚ü® 2 1 ‚ü© ‚ü® 2 2 ‚ü© ‚ü® 2 3 ‚ü© ‚ü® 2 4 ‚ü© ‚ü® 2 0 ‚ü©  
  ‚ü® 0 1 ‚ü© ‚ü® 0 2 ‚ü© ‚ü® 0 3 ‚ü© ‚ü® 0 4 ‚ü© ‚ü® 0 0 ‚ü©  
  ‚ü® 1 1 ‚ü© ‚ü® 1 2 ‚ü© ‚ü® 1 3 ‚ü© ‚ü® 1 4 ‚ü© ‚ü® 1 0 ‚ü©  
                                          ‚îò 
    # see how values are matched to leading axes
    # drop below dropped from the larger ranks first
    ‚â¢ 3‚Äø2 ‚Üì 7‚Äø7‚Äø7‚Äø7‚•ä"abc"
‚ü® 4 5 7 7 ‚ü©

--
Use leading axis agreement to match arguments together
Axes of lower-rank argument are matched with leading axes of higher-rank one

    ‚ä¢ x ‚Üê 3‚Äø2‚Äø4 ‚•ä ‚Üï60     # A rank-3 array
‚îå‚îÄ             
‚ïé  0  1  2  3  
   4  5  6  7  
               
   8  9 10 11  
  12 13 14 15  
               
  16 17 18 19  
  20 21 22 23  
              ‚îò
    100‚Äø0‚Äø200 + x         # 0-cells paired with 2-cells
‚îå‚îÄ                 
‚ïé 100 101 102 103  
  104 105 106 107  
                   
    8   9  10  11  
   12  13  14  15  
                   
  216 217 218 219  
  220 221 222 223  
                  ‚îò
    ‚ä¢ c ‚Üê 100 √ó 3 =‚åú‚óã‚Üï 2  # A rank-2 array to add
#breakdown: (‚Üï3) =‚åú (‚Üï2)
‚îå‚îÄ         
‚ïµ 100   0  
    0 100  
    0   0  
          ‚îò
    c + x                 # 0-cells paired with 1-cells
‚îå‚îÄ                 
‚ïé 100 101 102 103  
    4   5   6   7  
                   
    8   9  10  11  
  112 113 114 115  
                   
   16  17  18  19  
   20  21  22  23  
                  ‚îò
    x + x                 # Pairwise addition
‚îå‚îÄ             
‚ïé  0  2  4  6  
   8 10 12 14  
               
  16 18 20 22  
  24 26 28 30  
               
  32 34 36 38  
  40 42 44 46  
              ‚îò
---
Depth
Depth of an array is the greatest level of array nesting it attains, or, put another way, the greatest number of times you can pick an element starting from the original array before reaching an atom

    ‚â° 2‚Äø3‚Äø4
1
    ‚â° "a string is a list of characters"
1

# doesnt care about shape
    ‚â° 3‚Äø4‚•ä"characters"
1
    ‚â° (1+‚Üï10)‚•ä"characters"
1

# care about elements
    ‚â° ‚ü®2,3,4,5‚ü©
1
    ‚â° ‚ü®2,<3,4,5‚ü©
2
    ‚â° ‚ü®2,<3,4,<<<5‚ü©
4
# atom has depth 0
    ‚â°'c'
0
    F‚Üê+‚ãÑ‚â°f
0
    ‚â°‚ü®'c',f,2‚ü©
1
    ‚â°‚ü®5,‚ü®'c',f,2‚ü©‚ü©
2
# an empty array's depth is 1
    ‚â°‚ü®‚ü©
1
    ‚â°2‚Äø0‚Äø3‚•ä0
1

--
For Select, the left argument is a list and its elements correspond to the right
argument axes
    ‚Üï6‚Äø7
‚îå‚îÄ
‚ïµ ‚ü® 0 0 ‚ü© ‚ü® 0 1 ‚ü© ‚ü® 0 2 ‚ü© ‚ü® 0 3 ‚ü© ‚ü® 0 4 ‚ü© ‚ü® 0 5 ‚ü© ‚ü® 0 6 ‚ü©
  ‚ü® 1 0 ‚ü© ‚ü® 1 1 ‚ü© ‚ü® 1 2 ‚ü© ‚ü® 1 3 ‚ü© ‚ü® 1 4 ‚ü© ‚ü® 1 5 ‚ü© ‚ü® 1 6 ‚ü©
  ‚ü® 2 0 ‚ü© ‚ü® 2 1 ‚ü© ‚ü® 2 2 ‚ü© ‚ü® 2 3 ‚ü© ‚ü® 2 4 ‚ü© ‚ü® 2 5 ‚ü© ‚ü® 2 6 ‚ü©
  ‚ü® 3 0 ‚ü© ‚ü® 3 1 ‚ü© ‚ü® 3 2 ‚ü© ‚ü® 3 3 ‚ü© ‚ü® 3 4 ‚ü© ‚ü® 3 5 ‚ü© ‚ü® 3 6 ‚ü©
  ‚ü® 4 0 ‚ü© ‚ü® 4 1 ‚ü© ‚ü® 4 2 ‚ü© ‚ü® 4 3 ‚ü© ‚ü® 4 4 ‚ü© ‚ü® 4 5 ‚ü© ‚ü® 4 6 ‚ü©
  ‚ü® 5 0 ‚ü© ‚ü® 5 1 ‚ü© ‚ü® 5 2 ‚ü© ‚ü® 5 3 ‚ü© ‚ü® 5 4 ‚ü© ‚ü® 5 5 ‚ü© ‚ü® 5 6 ‚ü©
                                                            ‚îò

    ‚ü®3‚Äø2,1‚Äø4‚Äø1‚ü© ‚äè ‚Üï6‚Äø7 # 3‚Äø2 correspond to first axis, which it flips; 1‚Äø4‚Äø1 to 2nd axis, i.e.columns
‚îå‚îÄ                         
‚ïµ ‚ü® 3 1 ‚ü© ‚ü® 3 4 ‚ü© ‚ü® 3 1 ‚ü©  
  ‚ü® 2 1 ‚ü© ‚ü® 2 4 ‚ü© ‚ü® 2 1 ‚ü©  
                          ‚îò
# how do you get depth 1 in left argument?
# use atom

    ‚ü®3‚Äø2,1‚ü© <‚çü(0=‚â°)¬®‚ä∏‚äè ‚Üï6‚Äø7  # get 3‚Äø2 of column-1 
‚ü® ‚ü® 3 1 ‚ü© ‚ü® 2 1 ‚ü© ‚ü©
# breakdown
    s‚Üê<‚çü(0=‚â°)¬® ‚ü®3‚Äø2,1‚ü©
‚îå‚îÄ               
¬∑ ‚ü® 3 2 ‚ü© ‚îå¬∑     
          ¬∑ 1    
              ‚îò  
                ‚îò
    s ‚äè ‚Üï6‚Äø7
‚ü® ‚ü® 3 1 ‚ü© ‚ü® 2 1 ‚ü© ‚ü©

# but Replicate / doesnt have this problem, becoz depth 1 acts on first axis
# only
    3‚Äø2‚Äø1‚Äø2‚Äø3 / "abcde"
"aaabbcddeee"

---
Replicate /
# if single number, applies pervasively
    3 / "copy"
"cccooopppyyy"

# boolean value 0 or 1 to switch on and off
    1‚Äø1‚Äø0‚Äø0‚Äø1‚Äø0 / "filter"
"fie"

    ‚â§‚üú'i' "filter"  # breakdown: "filter" ‚â§ 'i'
‚ü® 1 1 0 0 1 0 ‚ü©

    ‚â§‚üú'i'‚ä∏/ "filter" 
"fie"

# breakdown:
    (‚â§‚üú'i')‚ä∏/ "filter"
    ((‚â§‚üú'i') "filter") / "filter"
    ("filter" ‚â§ 'i') / "filter"

    {1+'"'=ùï©}‚ä∏/ "for ""escaping"" quotes"  # the "" inside the quotes is actually one quote, so here there are 2 quotes
"for """"escaping"""" quotes" # here there are 4 quotes

    ‚ä¢ b ‚Üê 2‚Äø5 ‚•ä ‚Üï10
‚îå‚îÄ           
‚ïµ 0 1 2 3 4  
  5 6 7 8 9  
            ‚îò
# ùï® has depth of 2, gives the amount to copy along each leading axis of ùï©
    ‚ü®2‚Äø0, 1‚Äø0‚Äø0‚Äø1‚Äø1‚ü© / b
‚îå‚îÄ       
‚ïµ 0 3 4  
  0 3 4  
        ‚îò

    2‚Äø0 / 1‚Äø0‚Äø0‚Äø1‚Äø1‚ä∏/Àò b  # here ‚ä∏ is 'pack', its packing 1‚Äø0‚Äø0‚Äø1‚Äø1 to be used on the major cells
‚îå‚îÄ       
‚ïµ 0 3 4  
  0 3 4  
        ‚îò
#breakdown
        1‚Äø0‚Äø0‚Äø1‚Äø1 /Àò b
Error: Àò: Argument lengths don't agree
at  1‚Äø0‚Äø0‚Äø1‚Äø1 /Àò b
^^
        1‚Äø0‚Äø0‚Äø1‚Äø1 ‚ä∏/Àò b
‚îå‚îÄ       
‚ïµ 0 3 4  
  5 8 9  
        ‚îò
# if want to duplicate (using unit number) along each axis
    ‚ü®<2,<3‚ü© / b
‚îå‚îÄ                               
‚ïµ 0 0 0 1 1 1 2 2 2 3 3 3 4 4 4  
  0 0 0 1 1 1 2 2 2 3 3 3 4 4 4  
  5 5 5 6 6 6 7 7 7 8 8 8 9 9 9  
  5 5 5 6 6 6 7 7 7 8 8 8 9 9 9  
                                ‚îò
# careful not to do this, coz this is equivalent to 2‚Äø3 / b (which applies to
# first axis only) 
    ‚ü®2,3‚ü© / b
‚îå‚îÄ           
‚ïµ 0 1 2 3 4  
  0 1 2 3 4  
  5 6 7 8 9  
  5 6 7 8 9  
  5 6 7 8 9  
            ‚îò
# simple case
    b ‚â° ‚ü®‚ü© / b
1

---
Indices - Monadic /
ùï© must be integer and have at least rank 1 (atom not allowed)

    / 3‚Äø0‚Äø1‚Äø2
‚ü® 0 0 0 2 3 3 ‚ü©

# /ùï© is the list ùï©/‚Üï‚â†ùï©

    2‚Äø5‚Äø0‚Äø1 /‚ä∏‚äî "ABCDEFGH"
‚ü® "AB" "CDEFG" ‚ü®‚ü© "H" ‚ü©
#breakdown:
    (/2‚Äø5‚Äø0‚Äø1) ‚äî "ABCDEFGH"
‚ü® 0 0 1 1 1 1 1 3 ‚ü© # notice index 2 is missing

the modification (/‚àæ‚üú1)‚ä∏‚äî ensures the result always has as many elements as ùï®.

    /(‚àæ‚üú1) 2‚Äø5‚Äø0‚Äø1
‚ü® 0 0 1 1 1 1 1 3 4 ‚ü©
#breakdown:
    /(2‚Äø5‚Äø0‚Äø1 ‚àæ 1)  # add one more element to the index vector

# can get indices where 1 appears
    / 0‚Äø1‚Äø0‚Äø1‚Äø0‚Äø0‚Äø0‚Äø0‚Äø1‚Äø0
‚ü® 1 3 8 ‚ü©
# can get the distance from each 1
    -‚üú¬ª / 0‚Äø1‚Äø0‚Äø1‚Äø0‚Äø0‚Äø0‚Äø0‚Äø1‚Äø0
‚ü® 1 2 5 ‚ü©
# breakdown:
‚ü® 1 3 8 ‚ü© -¬ª ‚ü® 1 3 8 ‚ü©


---
Group \u

    0‚Äø1‚Äø2‚Äø0‚Äø1 ‚âç "abcde"  # Corresponding indices and values
‚îå‚îÄ                     
‚ïµ 0   1   2   0   1    
  'a' 'b' 'c' 'd' 'e'  
                      ‚îò
    0‚Äø1‚Äø2‚Äø0‚Äø1 ‚äî "abcde"  # Values grouped by index (so the indices are 0,1,2, so there are 3 values in the list)
‚ü® "ad" "be" "c" ‚ü©

# ¬Ø1 to drop value
    0‚Äø¬Ø1‚Äø2‚Äø2‚Äø¬Ø1 ‚äî "abcde"  # Drop c and e
‚ü® "a" ‚ü®‚ü© "cd" ‚ü©
# extra element to indicate result minimum length
    0‚Äø1‚Äø2‚Äø2‚Äø1‚Äø6 ‚äî "abcde"  # Length-6 result
‚ü® "a" "be" "cd" ‚ü®‚ü© ‚ü®‚ü© ‚ü®‚ü© ‚ü©

# try to group a list of words by length
    phrase ‚Üê "BQN"‚Äø"uses"‚Äø"notation"‚Äø"as"‚Äø"a"‚Äø"tool"‚Äø"of"‚Äø"thought"
    ‚âçÀò ‚â†¬®‚ä∏‚äî phrase  # breakdown: ‚âçÀò ((‚â†¬®) phrase) ‚äî phrase
‚îå‚îÄ                   
‚ïµ ‚ü®‚ü©                 
  ‚ü® "a" ‚ü©            
  ‚ü® "as" "of" ‚ü©      
  ‚ü® "BQN" ‚ü©          
  ‚ü® "uses" "tool" ‚ü©  
  ‚ü®‚ü©                 
  ‚ü®‚ü©                 
  ‚ü® "thought" ‚ü©      
  ‚ü® "notation" ‚ü©     
                    ‚îò

# get diagonals of a table

    ‚ä¢ a ‚Üê 'a'+‚•ä‚üú(‚Üï√ó¬¥)3‚Äø5
‚îå‚îÄ       
‚ïµ"abcde  
  fghij  
  klmno" 
        ‚îò
    (+‚åú¬¥¬∑‚Üï¬®‚â¢)‚ä∏‚äî a
‚ü® "a" "bf" "cgk" "dhl" "eim" "jn" "o" ‚ü© 

# breakdown: ((+‚åú¬¥¬∑‚Üï¬®‚â¢) a) ‚äî a
# 2-Train
    (+‚åú¬¥¬∑‚Üï¬®‚â¢) a
‚îå‚îÄ                                                                                             
‚ïµ 0 1 2 3 4                                                                                    
  1 2 3 4 5                                                                                    
  2 3 4 5 6                                                                                    
             ‚îò
    ‚Üï¬®‚â¢ a 
‚ü® ‚ü® 0 1 2 ‚ü© ‚ü® 0 1 2 3 4 ‚ü© ‚ü©

# the usage of fold, just to fold the list once is smart
    +‚åú¬¥‚ü®‚ü®0,1,2‚ü©,‚ü®0,1,2,3,4‚ü©‚ü©
    ‚ü®0,1,2‚ü© +‚åú ‚ü®0,1,2,3,4‚ü©

# the ¬∑ is Nothing, it does nothing as a Left ùï® to ‚Üï, but its needed to separate
# the Range and the Fold function; else the whole thing gets recognized as a
# Fork

    (+‚åú¬¥‚Üï¬®‚â¢) a
Error: ¬¥: Argument must be a list (3‚Äø5 ‚â° ‚â¢ùï©)
at (+‚åú¬¥‚Üï¬®‚â¢) a
   ^^^^^^^^
3-Train: (+‚åú¬¥)‚Üï¬®(‚â¢), the error shows that the Fold is applied straight to `a`

# in order words, becoz 3-Train is defined as such
# (f g h) ‚çµ -> (f ‚çµ) g (h ‚çµ)
# its not possible for ¬∑‚Üï¬® to be the middle `g` function anymore since its _does
# not_ accept a left argument (Nothing)

--
Using Group for partitioning

# easy splitting
    ' '(+`‚àò=‚äî‚ä¢)"BQN uses notation as a tool of thought"
‚ü® "BQN" " uses" " notation" " as" " a" " tool" " of" " thought" ‚ü©
# breakdown ' '(+`‚àò=)".." ‚äî (' '‚ä¢"..")
# use of scan for running numbers to group
   ' '+`‚àò="BQN uses notation as a tool of thought"
‚ü® 0 0 0 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 4 4 5 5 5 5 5 6 6 6 7 7 7 7 7 7 7 7 ‚ü©
# but, the 'front spacing' is included

# we could remove the 'front spacing' by making it ¬Ø1
    ' '((‚ä¢-Àú¬¨√ó+`)‚àò=‚äî‚ä¢)"BQN uses notation as a tool of thought"
‚ü® "BQN" "uses" "notation" "as" "a" "tool" "of" "thought" ‚ü©
# breakdown of (‚ä¢-Àú¬¨√ó+`) 
# take note this is 3 trains of 3 train
# (f g (f1 g1 h))
   a ‚Üê (' '="BQN uses notation as a tool of thought")
‚ü® 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 ‚ü©
   b ‚Üê (¬¨ a) √ó (+`) a
‚ü® 0 0 0 0 1 1 1 1 0 2 2 2 2 2 2 2 2 0 3 3 0 4 0 5 5 5 5 0 6 6 0 7 7 7 7 7 7 7 ‚ü©
   a -Àú b
‚ü® 0 0 0 ¬Ø1 1 1 1 1 ¬Ø1 2 2 2 2 2 2 2 2 ¬Ø1 3 3 ¬Ø1 4 ¬Ø1 5 5 5 5 ¬Ø1 6 6 ¬Ø1 7 7 7 7 7 7 7 ‚ü©

--
To get rid of (one chunk of space) - more than 1 char - of delimiter

# if use this same method, will have ‚ü®‚ü© empty partitions
' '((‚ä¢-Àú¬¨√ó+`)‚àò=‚äî‚ä¢)"  string with  spaces   "
    ‚ü® ‚ü®‚ü© ‚ü®‚ü© "string" "with" ‚ü®‚ü© "spaces" ‚ü©

# we want only the FIRST leading space of each spacings - to create a group
# the first leading space can be 0, for the 0th group
# we shift and compare
    (‚ä¢‚âç1‚ä∏¬ª<‚ä¢) ' '="  string with  spaces   "  # All, then filtered, spaces
‚îå‚îÄ                                                 
‚ïµ 1 1 0 0 0 0 0 0 1 0 0 0 0 1 1 0 0 0 0 0 0 1 1 1   
  0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0     # this is what we want
                                                  ‚îò
    ‚âç‚üú(‚ä¢-Àú¬¨√ó¬∑+`1‚ä∏¬ª<‚ä¢)' '="  string with  spaces   "  # More processing
‚îå‚îÄ                                                         
‚ïµ  1  1 0 0 0 0 0 0  1 0 0 0 0  1  1 0 0 0 0 0 0  1  1  1  
  ¬Ø1 ¬Ø1 0 0 0 0 0 0 ¬Ø1 1 1 1 1 ¬Ø1 ¬Ø1 2 2 2 2 2 2 ¬Ø1 ¬Ø1 ¬Ø1  
                                                          ‚îò
    ' '((‚ä¢-Àú¬¨√ó¬∑+`1‚ä∏¬ª<‚ä¢)‚àò=‚äî‚ä¢)"  string with  spaces   "  # Final result
‚ü® "string" "with" "spaces" ‚ü©

    ' '((¬¨-Àú‚ä¢√ó¬∑+`¬ª‚ä∏>)‚àò‚â†‚äî‚ä¢)"  string with  spaces   "  # Slightly shorter
‚ü® "string" "with" "spaces" ‚ü©

# breakdown
(‚ä¢-Àú¬¨√ó¬∑+`1‚ä∏¬ª<‚ä¢) a
(‚ä¢-Àú(¬¨√ó(+`(1‚ä∏¬ª<‚ä¢)))) a  # the nothing, separates the plus scan + shift function as one chunk

so
a-Àú(¬¨a)√ó(+`(1‚ä∏¬ª<‚ä¢))a

# infact
   ¬∑+`(1¬ªa)<a
‚ü® 0 0 0 0 0 0 0 0 1 1 1 1 1 2 2 2 2 2 2 2 2 3 3 3 ‚ü©

# we can enhance the function to use `membership of` to search for any "string"
# like so, we can delimit for any arbitary string
   " -> "((‚ä¢-Àú¬¨√ó¬∑+`1‚ä∏¬ª<‚ä¢)‚àò‚àäÀú‚äî‚ä¢) "CH -> B -> CD"
‚ü® "CH" "B" "CD" ‚ü©
   " -> "((¬¨-Àú‚ä¢√ó¬∑+`¬ª‚ä∏>)‚àò(¬¨‚àäÀú)‚äî‚ä¢) "CH -> B -> CD"
‚ü® "CH" "B" "CD" ‚ü©


--
A combinator (or nothing or separator) has higher precendence, it binds more tightly

Using back the above e.g

(+‚åú¬¥‚àò‚Üï¬®‚â¢) a
‚îå‚îÄ              
¬∑ ‚îå¬∑    ‚îå¬∑      
  ¬∑ 3   ¬∑ 10    
      ‚îò      ‚îò  
               ‚îò
#breakdown , ‚àò actually 'binds' ‚Üï as its ùîæ, (+‚åú¬¥‚àò‚Üï)¬®‚â¢ a


# back to `phrase`, if we want to group based on 0-index and also get rid of
# word more than 5 letters (i.e, get from length-1 to length-5)

    1 -Àú ‚â§‚üú5‚ä∏√ó ‚â†¬® phrase
‚ü® 2 3 ¬Ø1 1 0 3 1 ¬Ø1 ‚ü©
    ‚âçÀò {1-Àú‚â§‚üú5‚ä∏√ó‚â†¬®ùï©}‚ä∏‚äî phrase
‚îå‚îÄ                   
‚ïµ ‚ü® "a" ‚ü©            
  ‚ü® "as" "of" ‚ü©      
  ‚ü® "BQN" ‚ü©          
  ‚ü® "uses" "tool" ‚ü©  
                    ‚îò

#breakdown: 1 -Àú (‚â§‚üú5)‚ä∏√ó ‚â†¬® phrase
    np ‚Üê ‚â†¬® phrase
‚ü® 3 4 8 2 1 4 2 7 ‚ü© # want: get rid of 8,7 (turn to ¬Ø1) , and then reduce the rest by 1
    1 -Àú (‚â§‚üú5)‚ä∏√ó np
    1 -Àú ((‚â§‚üú5)np) √ó np
    1 -Àú‚ü® 1,1,0,1,1,1,1,0 ‚ü©√ónp
‚ü® 2 3 ¬Ø1 1 0 3 1 ¬Ø1 ‚ü©

# since we want length 1 to length 5, once way to guarantee there are 5 groups
# is to add a minimum `5` length as the extra element
    ‚âçÀò {5‚àæÀú1-Àú‚â§‚üú5‚ä∏√ó‚â†¬®ùï©}‚ä∏‚äî phrase
‚îå‚îÄ                   
‚ïµ ‚ü® "a" ‚ü©            
  ‚ü® "as" "of" ‚ü©      
  ‚ü® "BQN" ‚ü©          
  ‚ü® "uses" "tool" ‚ü©  
  ‚ü®‚ü©                 
                    ‚îò

# when group is called monadically

    ‚âçÀò ‚äî 2‚Äø3‚Äø¬Ø1‚Äø2
‚îå‚îÄ         
‚ïµ ‚ü®‚ü©       
  ‚ü®‚ü©       
  ‚ü® 0 3 ‚ü©  
  ‚ü® 1 ‚ü©    
          ‚îò
#basically, right argument operates on its own indices as values (similar as replicate)
    2‚Äø3‚Äø¬Ø1‚Äø2 ‚äî ‚Üï4
‚ü® ‚ü®‚ü© ‚ü®‚ü© ‚ü® 0 3 ‚ü© ‚ü® 1 ‚ü© ‚ü© 

---
Multidimensional Grouping
# ‚ü®first axis, second axis‚ü©
    ‚ü®0‚Äø0‚Äø1‚Äø1,0‚Äø1‚Äø0‚Äø1‚Äø0‚Äø1‚Äø0‚ü© ‚äî (10√ó‚Üï4)+‚åú‚Üï7
‚îå‚îÄ                              
‚ïµ ‚îå‚îÄ              ‚îå‚îÄ            
  ‚ïµ  0  2  4  6   ‚ïµ  1  3  5    
    10 12 14 16     11 13 15    
                ‚îò            ‚îò  
  ‚îå‚îÄ              ‚îå‚îÄ            
  ‚ïµ 20 22 24 26   ‚ïµ 21 23 25    
    30 32 34 36     31 33 35    
                ‚îò            ‚îò  
                               ‚îò
--
    ‚â†¬®‚äî 2‚Äø3‚Äø1‚Äø2
‚ü® 0 1 2 1 ‚ü©

/‚Åº inverse Indices called on the index argument gives the length of each group:    
    /‚Åº‚àß 2‚Äø3‚Äø1‚Äø2
‚ü® 0 1 2 1 ‚ü©

Calling Indices on the result lengths of Group sorts all the indices passed to Group (removing any ¬Ø1s). This is a kind of counting sort.
    /‚â†¬®‚äî 2‚Äø3‚Äø1‚Äø¬Ø1‚Äø2
‚ü® 1 2 2 3 ‚ü©

#breakdown
    ‚äî 2‚Äø3‚Äø1‚Äø¬Ø1‚Äø2  # monadic group, values -to-> group of indices
‚ü® ‚ü®‚ü© ‚ü® 2 ‚ü© ‚ü® 0 4 ‚ü© ‚ü® 1 ‚ü© ‚ü© # value 0 has none, value 1 is at index 2, value 2 is at index 0,4..
    ‚â†¬® ‚äî 2‚Äø3‚Äø1‚Äø¬Ø1‚Äø2
‚ü® 0 1 2 1 ‚ü© # size of these indices
    /0‚Äø1‚Äø2‚Äø1 # ignoring 0, value 1 has 1, value 2 has 2,2, value 3 has 3 <-- this is a counting sort (its a sort, coz it can only count up)
‚ü® 1 2 2 3 ‚ü©

# sorting by group - see the left argument as a list with indices to sort
# remove the extra layer of array with Join
    ‚àæ 2‚Äø3‚Äø1‚Äø¬Ø1‚Äø2 ‚äî "abcde"
"caeb"
# equivalent to the more difficult (but comprehensive?) sorting..
    2‚Äø3‚Äø1‚Äø¬Ø1‚Äø2 {F‚Üê(0‚â§ùï®)‚ä∏/ ‚ãÑ ùï®‚çã‚ä∏‚äè‚óãFùï©} "abcde"
"caeb"

# breakdown
              F         G
 2‚Äø3‚Äø1‚Äø¬Ø1‚Äø2 (‚çã‚ä∏‚äè)‚óã((0‚â§2‚Äø3‚Äø1‚Äø¬Ø1‚Äø2)‚ä∏/) "abcde"

Over: (G W) F (G X)

G X => ((0‚â§2‚Äø3‚Äø1‚Äø¬Ø1‚Äø2)‚ä∏/)"abcde"
G W => ((0‚â§2‚Äø3‚Äø1‚Äø¬Ø1‚Äø2)‚ä∏/)2‚Äø3‚Äø1‚Äø¬Ø1‚Äø2

    2‚Äø3‚Äø1‚Äø2 (‚çã‚ä∏‚äè) "abce"
"caeb"
#breakdown2
# the indices order required to sort "abce"
    ‚çã 2‚Äø3‚Äø1‚Äø2
‚ü® 2 0 3 1 ‚ü©
# use the indices order to sort  "abce"
    2‚Äø0‚Äø3‚Äø1 ‚äè "abce"
"caeb"

# in APL, we do for e.g. 4 3 6 7[‚çã4 3 6 7], using the [..]
# but in BQN, we use pick  ‚äè
    ‚çã‚ä∏‚äè 4‚Äø3‚Äø6‚Äø7 # first grade, then pick based on the sorted indices
‚ü® 3 4 6 7 ‚ü©
---
    ‚ä¢ l ‚Üê "planet"‚Äø"moon"‚Äø"star"‚Äø"asteroid"
‚ü® "planet" "moon" "star" "asteroid" ‚ü©

    ‚àß l
‚ü® "asteroid" "moon" "planet" "star" ‚ü©

    ‚çã l    # order needed to pick the list to sort it
‚ü® 3 1 0 2 ‚ü©
    ‚çã‚çãl    # applying it twice, `inverse` the index order
‚ü® 2 1 3 0 ‚ü©
‚îå‚îÄ                                   
‚ïµ "planet" "moon" "star" "asteroid"  
  2        1      3      0           
                                    ‚îò
# what the above says is: for each major cell of that argument, what rank it has
# relative to the others - the "ordinals" idiom

ordinal - relating to the order of something in a series.

    (‚çãl) ‚äè l
‚ü® "asteroid" "moon" "planet" "star" ‚ü©

while ‚çãl transforms l to ‚àßl, the inverse of ‚çãl transforms ‚àßl back into l. 
That's what we want: for each cell of l, the corresponding number in the inverse of ‚çãl is what index that cell has after sorting.

   (‚çã‚çãl) ‚äè ‚ü® "asteroid","moon","planet","star" ‚ü©
‚ü® "planet" "moon" "star" "asteroid" ‚ü©

Or
    ùï© ‚â° q‚äèp‚äèùï©

   ‚ü® 2,1,3,0 ‚ü© ‚äè ‚ü® 3,1,0,2 ‚ü© ‚äè ‚ü® "planet","moon","star","asteroid" ‚ü©
‚ü® "planet" "moon" "star" "asteroid" ‚ü©

The fact that Grade Up inverts a permutation is useful in itself. Note that this applies to Grade Up specifically, and not Grade Down.
This is because the 'identity permutation' is ordered in ascending order. 
i.e.
 (‚çã‚Åº) is actually ‚çã
'identify permutation' is ‚àß‚çãl also ‚Üï‚â†l

Grade Down would actually invert the reverse of a permutation, 
which is unlikely to be useful. So the ordinals idiom that goes in the opposite direction is actually not ‚çí‚çí but ‚çã‚çí.

---
BQN specifies that matching cells are "always ordered by their indices".

One effect is that ‚çãùï© is not always the same as ‚åΩ‚çíùï©, even though ‚àßùï© always matches ‚åΩ‚à®ùï©.

    ‚ä¢ t ‚Üê >‚ü® "dog"‚Äø4, "ant"‚Äø6, "pigeon"‚Äø2, "pig"‚Äø4 ‚ü©
‚îå‚îÄ            
‚ïµ "dog"    4  
  "ant"    6  
  "pigeon" 2  
  "pig"    4  
             ‚îò

    1 ‚äèÀò t
‚ü® 4 6 2 4 ‚ü©

    (1‚äèÀòt) ‚çã‚ä∏‚äè t   # see "dog" and "pig" is based on the array index
‚îå‚îÄ            
‚ïµ "pigeon" 2  
  "dog"    4  
  "pig"    4  
  "ant"    6  
             ‚îò

# But
    (1‚äèÀòt) ‚çí‚ä∏‚äè t
‚îå‚îÄ            
‚ïµ "ant"    6  
  "dog"    4   # same arrangement of dog and pig
  "pig"    4  
  "pigeon" 2  
             ‚îò

    (1‚äèÀòt)
‚ü® 4 6 2 4 ‚ü©
    ‚çã (1‚äèÀòt)   
‚ü® 2 0 3 1 ‚ü©
    ‚çí (1‚äèÀòt)  # can see the 0 and 3 indices order are maintained
‚ü® 1 0 3 2 ‚ü©

-- FFT (Food For Thought)
    (‚åΩ‚çí/3‚Äø4‚Äø5) ‚äè "012abcdABCDE"
"210dcbaEDCBA"

    a‚Üê3‚Äø4‚Äø5
‚ü® 3 4 5 ‚ü©
    /a
‚ü® 0 0 0 1 1 1 1 2 2 2 2 2 ‚ü©
    ‚çí/a   # see the ordering of indices for 'matching cells' are maintained
‚ü® 7 8 9 10 11 3 4 5 6 0 1 2 ‚ü©
    ‚åΩ‚çí/a
‚ü® 2 1 0 6 5 4 3 11 10 9 8 7 ‚ü©

--
Bin

finding "what bin" (in ùï®)something (from ùï©) fits into.

    hs ‚Üê 1e7√ó627‚Äø581‚Äø578‚Äø553‚Äø520  # High scores

    hs ‚çí 1e7√ó565‚Äø322‚Äø788‚Äø627
‚ü® 3 5 0 1 ‚ü©   # 565 is lesser than 578 but more then 553, can slot in 3rd rank
# 322 falls outside the bin lists, 788 at Rank 0, 627 tie with 1st rank
---
Repeat \# 2-modifier

    ¬ª¬ª¬ª "ABCDE"
"   AB"

    ¬ª‚çü3 "ABCDE"
"   AB

# symbol similar to math concept of exponential
n‚ãÜ4  ‚Üê‚Üí  n√ón√ón√ón
F‚çü4  ‚Üê‚Üí  F‚àòF‚àòF‚àòF

Since F‚çü1 applies F and F‚çü0 doesn't, Repeat might be pronounced "if" or "conditional" when ùîæ is boolean.

    2 √ó‚çü0 2
2
    2 √ó‚çü1 2
4

# ùï® ùîΩ‚çün ùï© is always equivalent to ùï®‚ä∏ùîΩ‚çün ùï©, provided n is a constant;not a function
    3 +‚çü2 7
13
    3 + 3 + 7
13

#Count can be dynamic with ùîæ as a function
in that case, actual count is ùï®ùîæùï©

remember the labels: ùï® ùîΩ_ùï£_ùîæ ùï©

5+‚çü√ó 2  # here w is 5, x is 2 , so (5+) (5+) ..10times.. (5+) 2
52
5+‚çü√ó 1  # here w is 5, x is 1, so (5+) ..5times.. (5+) 1
26

Before/after binds stronger and creates trains

# below w is simply nothing ¬∑
    ‚àæ‚üú1‚çü‚ä¢ 4
‚ü® 4 1 1 1 1 ‚ü©
breakdown: (‚àæ‚üú1) (‚àæ‚üú1) (‚àæ‚üú1) (‚àæ‚üú1) 4

    1‚ä∏+‚çü‚â† ‚Üï4
‚ü® 4 5 6 7 ‚ü©
breakdown: (1‚ä∏+) (1‚ä∏+) (1‚ä∏+) (1‚ä∏+) ‚Üï4

# some usecase for dynamic boolean
# halve the number if greater than 6
    √∑‚üú2‚çü{6<ùï©}¬® 3‚Äø7‚Äø2‚Äø1‚Äø8   # notice the Each ¬® 
‚ü® 3 3.5 2 1 4 ‚ü©
# which is equivalent to
    (√∑‚üú2‚çü{6<ùï©})¬® 3‚Äø7‚Äø2‚Äø1‚Äø8
‚ü® 3 3.5 2 1 4 ‚ü©

    3 ‚ä£‚çü<¬® 2‚Äø4‚Äø6  # Left if less, i.e. minimum
‚ü® 2 3 3 ‚ü©
    3‚åä2‚Äø4‚Äø6  # easier
‚ü® 2 3 3 ‚ü©
---
Some experiments
How to rotate 2D array 90 Degs to the right?

    a
‚îå‚îÄ       
‚ïµ 1 2 3  
  4 5 6  
  7 8 9  
        ‚îò
    ‚çâa
‚îå‚îÄ       
‚ïµ 1 4 7  
  2 5 8  
  3 6 9  
        ‚îò
    ‚åΩÀò‚çâa  # reverse it along the first axis
‚îå‚îÄ       
‚ïµ 7 4 1  
  8 5 2  
  9 6 3  
        ‚îò
# works ok for larger square 2D array
    a‚Üê4‚Äø4‚•ä1+‚Üï16
‚îå‚îÄ             
‚ïµ  1  2  3  4  
   5  6  7  8  
   9 10 11 12  
  13 14 15 16  
              ‚îò
    ‚åΩÀò‚çâa   # rotate 90 deg clockwise
‚îå‚îÄ           
‚ïµ 13  9 5 1  
  14 10 6 2  
  15 11 7 3  
  16 12 8 4  
            ‚îò
# same with this
    ‚çâ‚àò‚åΩa
‚îå‚îÄ           
‚ïµ 13  9 5 1  
  14 10 6 2  
  15 11 7 3  
  16 12 8 4  
            ‚îò
# rotate it 90 deg counter clockwise
    ‚åΩ‚àò‚çâa
‚îå‚îÄ           
‚ïµ 4 8 12 16  
  3 7 11 15  
  2 6 10 14  
  1 5  9 13  
            ‚îò
# rotate 180 deg
    ‚åΩ‚åæ‚•äa
‚îå‚îÄ             
‚ïµ 16 15 14 13  
  12 11 10  9  
   8  7  6  5  
   4  3  2  1  
              ‚îò

---
Search functions

Name	                 (Search)for	in	Return
‚äê	Index of	                ùï©	    ùï®	Index of first match
‚äí	Progressive Index of	    ùï©	    ùï®	Index of first unused match
‚àä	Member of	                ùï®	    ùï©	1 if found, 0 if not
‚çã‚çí	Bins	                    ùï©	    ùï®	Predecessor index

--
‚àä	Member of

		"green"‚Äø"bricks"‚Äø"cow"‚Äø"blue" ‚àä "red"‚Äø"green"‚Äø"blue"
‚ü® 1 0 0 1 ‚ü©   # result length will match length of ùï®

# useful in finding intersection and difference
    "initial set" (‚àä/‚ä£) "intersect"     # Keep ùï©
"initiset"

    "initial set" (¬¨‚àò‚àä/‚ä£) "difference"  # Remove ùï©
"tal st"

‚ç∑ Find

    "xx" ‚ç∑ "xxbdxxxcx"
‚ü® 1 0 0 0 1 1 0 0 ‚ü©
# equivalent to
    "xx"‚ä∏‚â°Àò 2 ‚Üï "xxbdxxxcx"
‚ü® 1 0 0 0 1 1 0 0 ‚ü©

# interesting to note that, by "flattening" into a list
   (<"->")‚â°¬®<Àò2‚Üï"CH -> B"
‚ü® 0 0 0 1 0 0 ‚ü©
‚ü® 3 ‚ü©
# this unit array '<' comparison is not the same as 'pack' ‚ä∏ (as atom)
   (<"->")‚â°Àò2‚Üï"CH -> B"
‚ü® 0 0 0 0 0 0 ‚ü©
   "->"‚ä∏‚â°Àò2‚Üï"CH -> B"
‚ü® 0 0 0 1 0 0 ‚ü©   # but notice the dimension is not ùï©'s dimension

# to have like APL style with trailing zeros
    "string" ‚ç∑ "substring"
‚ü® 0 0 0 1 ‚ü©

    "string" (‚â¢‚àò‚ä¢‚Üë‚ç∑) "substring"  # APL style
‚ü® 0 0 0 1 0 0 0 0 0 ‚ü©

Find is quite useful, even for scanning 2D patterns
    ‚ä¢ a ‚Üê 7 (4|‚ãÜÀú)‚åú‚óã‚Üï 9   # Array with patterns
‚îå‚îÄ                   
‚ïµ 1 1 1 1 1 1 1 1 1  
  0 1 2 3 0 1 2 3 0  
  0 1 0 1 0 1 0 1 0  
  0 1 0 3 0 1 0 3 0  
  0 1 0 1 0 1 0 1 0  
  0 1 0 3 0 1 0 3 0  
  0 1 0 1 0 1 0 1 0  
                    ‚îò # this is 7 x 9

    (0‚Äø3‚Äø0‚âç0‚Äø1‚Äø0) ‚ç∑ a
‚îå‚îÄ               
‚ïµ 0 0 0 0 0 0 0  
  0 0 0 0 0 0 0  
  0 0 0 0 0 0 0  
  0 0 1 0 0 0 1  
  0 0 0 0 0 0 0  
  0 0 1 0 0 0 1  
                ‚îò # this is 6 x 7 only 

# to get full padding
   (0‚Äø3‚Äø0‚âç0‚Äø1‚Äø0) (‚â¢‚àò‚ä¢‚Üë‚ç∑) a
‚îå‚îÄ
‚ïµ 0 0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0 0
  0 0 1 0 0 0 1 0 0
  0 0 0 0 0 0 0 0 0
  0 0 1 0 0 0 1 0 0
  0 0 0 0 0 0 0 0 0
                    ‚îò
# special case
#It's also allowed for ùï® to have a smaller rank than ùï©; in this case leading axes of ùï© are mapped over so that axes of ùï® correspond to trailing axes of ùï©.
    0‚Äø1‚Äø0‚Äø1 ‚ç∑ a
‚îå‚îÄ             
‚ïµ 0 0 0 0 0 0  
  0 0 0 0 0 0  
  1 0 1 0 1 0  
  0 0 0 0 0 0  
  1 0 1 0 1 0  
  0 0 0 0 0 0  
  1 0 1 0 1 0  
              ‚îò

--
‚äê	Index of

    "zero"‚Äø"one"‚Äø"two"‚Äø"three" ‚äê "one"‚Äø"eight"‚Äø"two"
‚ü® 1 4 2 ‚ü© # result length match length of ùï©, "eight" is not found, so return ‚â†ùï®

How to think about it?
The `open` side of the symbol points to the `searched-in argument`
think about the `open` side as 'gulping up' the arguments and 'contain' them within
while the other side is left outside of the container and being used as a `searched for` match

This is same as ùï®‚äèùï©, we search `for` ùï® `in` ùï©
the result (list) length is the same length as the `searched for` argument

# Index of - always return just the first match
       "one"‚Äø"zero"‚Äø"one"‚Äø"two"‚Äø"three" ‚äê "one"‚Äø"eight"‚Äø"two"‚Äø"one"
‚ü® 0 5 3 0 ‚ü©

--
 To find the indices of all matches, start with Match Each, then Indices
    / "letters" ‚â°¬®< 'e'        # Many to one
‚ü® 1 4 ‚ü©

    "letters" (<‚àò/Àò‚â°‚åúÀú) "let"  # Many to many
‚ü® ‚ü® 0 ‚ü© ‚ü® 1 4 ‚ü© ‚ü® 2 3 ‚ü© ‚ü©
# Note, for <‚àò/Àò, if we do < we could combine at major axis Àò, even if the
# result output for each axis has different length


# breakdown
    # 2-Train
    "letters" (<‚àò/Àò) (‚â°‚åúÀú) "let"
    # first Train
    "letters" ‚â°‚åúÀú "let"
‚îå‚îÄ               
‚ïµ 1 0 0 0 0 0 0  
  0 1 0 0 1 0 0  
  0 0 1 1 0 0 0  
                ‚îò
    # 2nd Train, notice, the combinator always bind strongest to Function
    # so its not <‚àò(/Àò), its (<‚àò/)Àò
    (<‚àò/)Àò ("letters" ‚â°‚åúÀú "let")
‚ü® ‚ü® 0 ‚ü© ‚ü® 1 4 ‚ü© ‚ü® 2 3 ‚ü© ‚ü©

--
‚äí	Progressive Index of

Progressive Index of returns the index of the first unused match, 
provided there's still one left.
It returns either ‚â†ùï® or an index of a cell from ùï® that matches the given cell of ùï©. 

    "aaa" ‚äí "aaaaa"
‚ü® 0 1 2 3 3 ‚ü© # last 2 3's are ùï® length, `a` is progressively found in index 0,1,2

    "aaabb" ‚äí "ababababab"
‚ü® 0 3 1 4 2 5 5 5 5 5 ‚ü© # last 5 5's

    "abaaccdd" ‚äí "abcbc" 
‚ü® 0 1 4 8 5 ‚ü© # second `b` in ùï© cannot be found

--
Progressive Member of

# Not available as a symbol

# so Membership of in terms of Index of is:
ùï©‚àäùï® is (ùï®‚äêùï©)<‚â†ùï®
# e.g.
    "abcde" ‚àä "beb"
‚ü® 0 1 0 0 1 ‚ü©
    "beb" ‚äê "abcde"
‚ü® 3 0 3 3 1 ‚ü©
    ("beb" ‚äê "abcde") < 3
‚ü® 0 1 0 0 1 ‚ü©

(ùï®‚äêùï©)<‚â†ùï®, after refactoring is ‚äêÀú<‚â†‚àò‚ä¢

    "abcde"‚àä"beb"
‚ü® 0 1 0 0 1 ‚ü©
    "abcde" (‚äêÀú<‚â†‚àò‚ä¢) "beb"
‚ü® 0 1 0 0 1 ‚ü©
3-Train
   w (‚äêÀú<(‚â†‚àò‚ä¢)) x
   (w‚äêÀúx) < (w(‚â†‚àò‚ä¢)x)
   
# Member of 
    "aabbcc" (‚äêÀú<‚â†‚àò‚ä¢) "baa"
‚ü® 1 1 1 1 0 0 ‚ü©

# Progressive Member of
    "aabbcc" (‚äíÀú<‚â†‚àò‚ä¢) "baa"
‚ü® 1 1 1 0 0 0 ‚ü©   # second `b` is not a member

    "aabbcc" ((‚äíÀú=‚â†‚àò‚ä¢)/‚ä£) "baa"  # Multiset difference, notice the `=` instead of `<`, meaning find those NOT in the progressive set
"bcc"

    ‚çã‚àò‚çã "adebcedba"
‚ü® 0 5 7 2 4 8 6 3 1 ‚ü©

    ‚àß‚ä∏‚äí "adebcedba"
‚ü® 0 5 7 2 4 8 6 3 1 ‚ü©

    ‚àß‚ä∏‚äê "adebcedba"  # Ties included, or rather only the _first_ index is used
‚ü® 0 5 7 2 4 7 5 2 0 ‚ü©

    ‚äíÀú "anything at all"   # every cell matched to itself, equal to ‚Üï‚àò‚â†
‚ü® 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ‚ü©

---
Single Search (how to search for one thing only)

    stuff ‚Üê "tacks"‚Äø"paper"‚Äø"string"‚Äø"tape"

    stuff ‚äê "tacks"‚Äø"string"
‚ü® 0 2 ‚ü©   # good

    stuff ‚äê "string"
‚ü® 4 4 4 4 4 4 ‚ü©  # bad - it treats the element as the whole list to check

    stuff ‚äê< "string"
‚îå¬∑      # enclosed
¬∑ 2  
    ‚îò

    stuff ‚äë‚àò‚äê‚üú< "string"  # want the `first` element
2

    stuff‚ä∏‚äê‚åæ< "string" # or use `Under` to undo (un-enclose) < 
2

    stuff
‚ü® "tacks" "paper" "string" "tape" ‚ü©
    "string"‚Äø"nothing" ‚àästuff
‚ü® 1 0 ‚ü©
    "string"‚àästuff  # member of - also suffers same issue
‚ü® 0 0 0 0 0 0 ‚ü©

    ‚àä‚üústuff‚åæ< "string" # can use similar trick, but for member of
1

---
Search for argument can be higher rank arrays

    ("high"‚âç"rank") ‚àä "list arg"
‚îå‚îÄ         
‚ïµ 0 1 1 0  
  1 1 0 0  
          ‚îò

    4‚Äø4‚Äø4 ‚äí 3‚Äø2‚•ä4
‚îå‚îÄ     
‚ïµ 0 1  # searches in index order  (same index as if using Deshape)
  2 3  
  3 3  
      ‚îò
 # so above same as: ‚•äùï®‚äíùï© is ùï®‚äí‚•äùï©.

    ‚ä¢ rows ‚Üê >"row"‚Äø"rho"‚Äø"row"‚Äø"rue"
‚îå‚îÄ     
‚ïµ"row  
  rho  
  row  
  rue" 
      ‚îò

    rows ‚äê >"row"‚Äø"row"‚Äø"col"‚âç"rho"‚Äø"cow"‚Äø"col"
‚îå‚îÄ       
‚ïµ 0 0 4  # the shape always matches the `searched for` argument's
  1 4 4  
        ‚îò
#breakdown:

    >"row"‚Äø"row"‚Äø"col"‚âç"rho"‚Äø"cow"‚Äø"col"
‚îå‚îÄ     
‚ïé"row  
  row  
  col   
       
 ¬∑rho  
  cow  
  col" 
      ‚îò
    ‚â¢>"row"‚Äø"row"‚Äø"col"‚âç"rho"‚Äø"cow"‚Äø"col"
‚ü® 2 3 3 ‚ü©
# that's why there's 2 rows in the result, each 3 major cells searched against
# the LHS argument `rows` ; in contrast
# if we `flatten` everything into a column
    rows ‚äê >"row"‚Äø"row"‚Äø"col"‚Äø"rho"‚Äø"cow"‚Äø"col"
‚ü® 0 0 4 1 4 4 ‚ü©
# a 0-cell of ùï© gives a 0-cell of the result; i.e. 1-1 cell comparisons and give
# a rank-0 (atom, just a number) for each cell

# consider this: the searched-in cells are rank-0 atom, so compare atom to ataom
    (2‚Äø1‚âç3‚Äø1) ‚àä 3‚Äø1‚Äø4‚Äø3
‚îå‚îÄ     
‚ïµ 0 1  
  1 1  
      ‚îò
# the searched-in cells are `list`, so compare list to list
    (2‚Äø1‚âç3‚Äø1) ‚àä 3‚Äø1‚âç4‚Äø3
‚ü® 0 1 ‚ü©
    3‚Äø1‚âç4‚Äø3
‚îå‚îÄ     
‚ïµ 3 1  
  4 3  
      ‚îò

---
‚Üï  <-- Dyadic window

    5‚Üï"abcdefg"  # take a window, there are 1+(‚â†ùï©)-ùï®, or (‚â†ùï©)¬¨ùï®, of these sections
‚îå‚îÄ       
‚ïµ"abcde  
  bcdef  
  cdefg" 
        ‚îò   # 8 - 5 = 3 sections

# these two are the same
    2‚äè5‚Üï"abcdefg"
"cdefg"
    5‚Üë2‚Üì"abcdefg"
"cdefg"

Windows differs from Prefixes and Suffixes in that it doesn't add a layer of nesting (it doesn't enclose each slice)

# Recall Prefixes and Suffixes
    ‚Üë "abcde"
‚ü® ‚ü®‚ü© "a" "ab" "abc" "abcd" "abcde" ‚ü©
    ‚Üì "abcde"
‚ü® "abcde" "bcde" "cde" "de" "e" ‚ü®‚ü© ‚ü©

# window can do multiple dimension slices
    <‚éâ2 2‚Äø2‚Üï"0123"‚àæ"abcd"‚âç"ABCD"   #2‚Äø2 slice
‚îå‚îÄ                      
‚ïµ ‚îå‚îÄ     ‚îå‚îÄ     ‚îå‚îÄ      
  ‚ïµ"01   ‚ïµ"12   ‚ïµ"23    
    ab"    bc"    cd"   
       ‚îò      ‚îò      ‚îò  
  ‚îå‚îÄ     ‚îå‚îÄ     ‚îå‚îÄ      
  ‚ïµ"ab   ‚ïµ"bc   ‚ïµ"cd    
    AB"    BC"    CD"   
       ‚îò      ‚îò      ‚îò  
                       ‚îò
# transposed is the same
    {(5‚Üïùï©)‚â°‚çâ(3‚Üïùï©)}"abcdefg"
1

    {‚ü®ùï©,‚çâùï©‚ü©}5‚Üï"abcdefg"
‚îå‚îÄ                   
¬∑ ‚îå‚îÄ        ‚îå‚îÄ       
  ‚ïµ"abcde   ‚ïµ"abc    
    bcdef     bcd    
    cdefg"    cde    
          ‚îò   def    
              efg"   
                  ‚îò  
                    ‚îò
# take running sums of 3 values
    +ÀùÀò3‚Üï ‚ü®2,6,0,1,4,3‚ü©
‚ü® 8 7 5 8 ‚ü©

A common task is to act on windows with an initial or final element so the total length stays the same. 
When using windows of length 2, the best way to accomplish this is with a shift ¬´ or ¬ª. 
If the window length is longer or variable, then a 'trick' with Windows works better: 
---> add the elements, and then use windows matching the 'original' length. (Hence, do not need to specify the intended window length! For e.g. above, we had to specify window length 3‚Üï..)

# more normal way of doing - clear intention
    -‚üú(0¬ª‚ä¢) +` 3‚Äø2‚Äø1‚Äø1 # shift a zero to the left
‚ü® 3 2 1 1 ‚ü©

# using the 'trick'
    (-ÀúÀù‚â†‚Üï0‚àæ‚ä¢) +` 3‚Äø2‚Äø1‚Äø1  # directly join the zero to the left; and window length is full input length
‚ü® 3 2 1 1 ‚ü©
# breakdown
    c ‚Üê +` 3‚Äø2‚Äø1‚Äø1
‚ü® 3 5 6 7 ‚ü©
    d ‚Üê (‚â†c)‚Üï(0‚àæ‚ä¢ c)
‚îå‚îÄ         
‚ïµ 0 3 5 6  
  3 5 6 7  
          ‚îò
# then do the thing
    -ÀúÀù d
‚ü® 3 2 1 1 ‚ü©

# apply the concept to the 3 running sums (to keep the length constant)
# but see, the first TWO elements in the result might not be needed
    (+Àù‚â†‚Üï(2‚•ä0)‚ä∏‚àæ) ‚ü®2,6,0,1,4,3‚ü©
‚ü® 2 8 8 7 5 8 ‚ü©

# notice that the whole chunk of functions are (f . g . h . i) 
# evaluations are from right to left, so the fork g . h . i are processed first

----
How to use functions as block (ignores arguments and purely for side effects)

1.Pass @ to a function that ignores its argument. It's a nice signal that nothing is happening and is easy to type.
2.A headerless function that doesn't use an argument will be interpreted as an immediate block by default. Start it with the line ùï§ to avoid this (it's an instruction to navel gaze: the function contemplates its self, but does nothing about it

fn = ()=>{m+=1;n*=2}; fn() # Javascript
Fn ‚Üê {ùï§‚ãÑ  m+‚Ü©1,n√ó‚Ü©2}, Fn @ # Delayed execution


----
Control Flow
If ‚Üê {ùïè‚çüùïé@}¬¥
If (a<10)‚Äø{ùï§
  a +‚Ü© 10
}

# if its true, it will execute and return a result, else returns @
   a‚Üê1
1
   {ùï§‚ãÑa+‚Ü©10}‚çü(a<10) @
11
   {ùï§‚ãÑa+‚Ü©10}‚çü(a<10) @
@
# most cases, can use this
{ a<10 ? a+‚Ü©10 ; @ }

--
For

Fn¬® v      # for (ùï© in v)
Fn¬® ‚Üïn     # for (ùï©=0; ùï©<n; ùï©++)
Fn¬® k‚Üì‚Üïn   # for (ùï©=k; ùï©<n; ùï©++)  with 0‚â§k
Fn¬® k+‚Üïn-k # for (ùï©=k; ùï©<n; ùï©++)  with k‚â§n
Fn¬® ‚åΩ‚Üïn    # for (ùï©=n; --ùï©; )

--
If-Else
# with only predicate
{
  threshold < 6 ?
  a ‚Ü© Small threshold ;  # If predicate was true
  b ‚Ü© 1 Large threshold  # If it wasn't
}

# with Choose ‚ó∂
IfElse ‚Üê {cond‚ÄøTrue‚ÄøFalse: cond‚ó∂False‚ÄøTrue @}

# 2 ways to write it
IfElse ‚ü®ùï©<mid‚äëùï®
  {ùï§‚ãÑ hi‚Ü©mid}
  {ùï§‚ãÑ lo‚Ü©mid}
‚ü©

IfElse (ùï©<mid‚äëùï®)‚Äø{ùï§
  hi‚Ü©mid
}‚Äø{ùï§
  lo‚Ü©mid
}

#usage for above example
   hi‚Üê0
0
   lo‚Üê0
0
   mid‚Üê1
1
   8‚Äø9 { IfElse (ùï©<mid‚äëùï®)‚Äø{ùï§‚ãÑhi‚Ü©mid}‚Äø{ùï§‚ãÑlo‚Ü©mid} } 2
1
   hi
1
   lo
0

#with case headers  
{ùïèùï®}¬¥ (ùï©<mid‚äëùï®)‚Äø{
  1: hi‚Ü©mid
;
  0: lo‚Ü©mid
}

# breakdown (ùï©<mid‚äëùï®) {ùïèùï®} {1: hi‚Ü©mid;0: lo‚Ü©mid} 
# ùï® could be 1 or 0, hence deciding which header to execute

--
Chained if-else

#just predicates
{
  a<b ? a+‚Ü©1 ;
  a<c ? c-‚Ü©1 ;
        a-‚Ü©2
}

#this is a right fold, with the right most input as @ 
#but becoz the middle ones are all deferred functions
#so none will be executed until the first `test` statement is executed
Test ‚Üê {fn‚Üê{Cond‚ÄøAct ùïä else: Cond‚ó∂Else‚ÄøAct}¬¥ùï© ‚ãÑ Fn@}

Test ‚ü®
  (  a<b)‚Äø{ùï§‚ãÑa+‚Ü©1}
  {ùï§‚ãÑa<c}‚Äø{ùï§‚ãÑc-‚Ü©1}
  {ùï§‚ãÑa-‚Ü©2}
‚ü©

--
Switch case
Match ‚Üê {ùïèùï®}¬¥

Match value‚Äø{
  0‚Äøb: n-‚Ü©b
;
  a‚Äøb: n+‚Ü©a-b
;
  ùï©: n‚àæ‚Ü©ùï©
}

Select ‚Üê {(‚äëùï©)‚ó∂(1‚Üìùï©)@}

Select number‚Äø{
  name ‚Ü© "zero"
}‚Äø{
  name ‚Ü© "one"
}‚Äø{
  name ‚Ü© "two"
}

--
                 |this ùï© is actually useless, its just @
Forever ‚Üê {ùïäa:{ùïäAùï©}@}
# main gist, is to run A as a function, forever

Forever 1‚äë@‚Äø{ùï§
  # Stuff to do forever
}

# slicker way is to pass ùï© as an operand (ùîΩ) into 
# the inner {ùïäùîΩùï©} 
Forever ‚Üê {ùï©{ùïäùîΩùï©}@}

# inner operand ùîæ is outer ùï©
# inner operand ùîΩ is outer ùï®
# inner ùï© is @ 
# so execute ùîæ@ as long as ùîΩ is 1
While ‚Üê {ùï®{ùïä‚àòùîæ‚çüùîΩùï©}ùï©@}¬¥

While {ùï§‚ãÑa<15}‚Äø{ùï§
  a√ó‚Ü©2
}

   a‚Üê1
1
   While {ùï§‚ãÑa<15}‚Äø{ùï§‚ãÑ‚Ä¢Show a‚ãÑa√ó‚Ü©2}
1
2
4
8
16

DoWhile ‚Üê {ùï®{ùïä‚çüùîΩùîæùï©}ùï©@}¬¥
# run ùîæ once 
# if ùîΩ is 1, will run the loop again
   a‚Üê1
1
   DoWhile {ùï§‚ãÑa<15}‚Äø{ùï§‚ãÑ‚Ä¢Show a‚ãÑa√ó‚Ü©2}
1
2
4
8
16
   DoWhile {ùï§‚ãÑa<15}‚Äø{ùï§‚ãÑ‚Ä¢Show a‚ãÑa√ó‚Ü©2} # will run once
16
32
   While {ùï§‚ãÑa<15}‚Äø{ùï§‚ãÑ‚Ä¢Show a‚ãÑa√ó‚Ü©2} # wont run, just return @
@

--
Low stack version - save required stack frames logarithmicly (why?)
While ‚Üê {ùï©{ùîΩ‚çüùîæ‚àòùîΩ_ùï£_ùîæ‚àòùîΩ‚çüùîæùï©}ùï®@}¬¥

The simplest approach is to perform one iteration and 
--> recurse with the same two functions.
# comment
#{ùîΩ_ùï£_ùîæ‚àòùîΩ‚çüùîæùï©} is same as {ùïä‚àòùîΩ‚çüùîæùï©}
#it is `deconstructed out` as ùîΩ_ùï£_ùîæ becoz we want to bind ùîΩ with ùîΩ‚çüùîæ‚àòùîΩ
#(as mentioned below)

The modified approach replaces (the leftmost) ùîΩ with ùîΩ‚çüùîæ‚àòùîΩ, (what is the significance of this?) 
that is, it doubles it while making sure the condition is still checked each iteration. 

#so, on the next level of recursion
#we get TWO times the function ùîΩ‚çüùîæ

The `doublings compound` so that recursion level n performs ùîΩ up to 2‚ãÜn times (2 power n) while using on the order of n additional stack frames. 

# seems this also work? what's the diff between this and the above?
While ‚Ü© {ùï©{ùîΩ‚çüùîæ‚àòùïä‚àòùîΩ‚çüùîæùï©}ùï®@}¬¥

# seems there's a system ‚Ä¢_while_
### WARNING: this is NOT a pure BQN function, so it cannot be defined by pure BQN terms

# so this would work
   {ùïä: ‚Ä¢Show i‚ãÑi+‚Ü©1}‚Ä¢_while_(<‚üú10) i   # navel gazing ùïä:, same as ùï§‚ãÑ
1
2
3
4
5
6
7
8
9
10

# this works as well: 
{ùïä: ‚Ä¢Show i‚ãÑi+‚Ü©1}‚Ä¢_while_{ùï§ ‚ãÑ i < 10} @

# this builtin ‚Ä¢while works by taking any initial value from ùîæ
# and the subsequent loop condition is actually evaluated from the result of ùîΩ 
   i‚Üê0
0
   {ùïä: ‚Ä¢Show i‚ãÑi+i‚Ü©1 ‚ãÑ 12}‚Ä¢_while_(<‚üú10) i
0
12   # stopped, coz the result value of ùîΩ is 12 
   i
1
 

# if using ‚ä¢, it would not go beyond 0 for ùîΩ
   i‚Üê2
2
   {ùïä: ‚Ä¢Show i‚ãÑi-‚Ü©1}‚Ä¢_while_‚ä¢1
2
1
0
# its weird, becoz somehow the left ùîΩ affects the right condition

left tack ‚ä£ seems the same
   i‚Üê2
2
   {ùïä: ‚Ä¢Show i‚ãÑi-‚Ü©1}‚Ä¢_while_‚ä£1
2
1
0

# it takes a w as well
# in this case it evaluates the condition by w G x
# and executes by w F x, with the new result being the next x
   10 {ùïä: ‚Ä¢Show ùï®‚Äøùï©‚ãÑ‚Ä¢Show i‚ãÑi+‚Ü©1}‚Ä¢_while_> i
‚ü® 10 5 ‚ü©
5
‚ü® 10 6 ‚ü©
6
‚ü® 10 7 ‚ü©
7
‚ü® 10 8 ‚ü©
8
‚ü® 10 9 ‚ü©
9
10





