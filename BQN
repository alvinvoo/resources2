https://mlochbaum.github.io/BQN/doc/index.html

Types:
1.Number
2.Character (Unicode code point)
3.Array
4.Function
5.1-Modifier
6.2-Modifier
7.Namespace

First 3 types are data types and are immutable; the rest are mutable
Function + the 2 modifiers are operation types
Other than Array, the 6 other types are atomic types, and their values are called atoms

--
An atom has depth 0 and does not have shape
But, primitives promote atoms by enclosing them to get rank-0 or unit array
For e.g. Rank and Shape
So an atom can be considered to have same dimensions as unit array: rank 0 and shape âŸ¨âŸ©

    3    # Atom , Rank 0, Depth 0
3
    <3   # Array (Unit)  , Rank 0, Depth 1
â”ŒÂ·   
Â· 3  
    â”˜
    '3'  # Atom , Rank 0, Depth 0
'3'

hierachy
depthâ†’rankâ†’shape

Unit Array
A unit array is an array with no axes, Rank 0, Depth 1, Shape âŸ¨âŸ©
same shape as an atom like 137
    â‰¢ 123
âŸ¨âŸ©


Enclose <



Enclost vs Enlist:

    < "enclose"
â”ŒÂ·           
Â· "enclose"      # wraps it in unit array
            â”˜

Enlist or Pair â‹ˆ /Z 
    â‹ˆ "enlist"    # âŸ¨ğ•©âŸ©
âŸ¨ "enlist" âŸ©     # wraps it in an array

    "pa" â‹ˆ "ir"   # âŸ¨ğ•¨,ğ•©âŸ©  - dyadic is Pair
âŸ¨ "pa" "ir" âŸ©

    2â€¿4â€¿1 â‹ˆâŒœ "north"â€¿"south"  # Cartesian product
â”Œâ”€                             
â•µ âŸ¨ 2 "north" âŸ© âŸ¨ 2 "south" âŸ©  
  âŸ¨ 4 "north" âŸ© âŸ¨ 4 "south" âŸ©  
  âŸ¨ 1 "north" âŸ© âŸ¨ 1 "south" âŸ©  
                              â”˜

    â‹ˆÂ¨ "+-Ã—Ã·"  # Glyphs to strings
âŸ¨ "+" "-" "Ã—" "Ã·" âŸ©

    'c' (+â‹ˆ-)  1â€¿2
âŸ¨ "de" "ba" âŸ©

    "e0" <âŠ¸âˆ¾ "e1" <âŠ¸âˆ¾ "e2" â‹ˆ "e3"
âŸ¨ "e0" "e1" "e2" "e3" âŸ©
#breakdown: 
# Join always join at first-axis
    "e1" âˆ¾ "e2" â‹ˆ "e3"
âŸ¨ 'e' '1' "e2" "e3" âŸ©
# we can enclose it, before joining 
    (<"e1") âˆ¾ "e2" â‹ˆ "e3"
âŸ¨ "e1" "e2" "e3" âŸ©
# which is same as enlisting it, before joining
    âŸ¨"e12"âŸ© âˆ¾ "e2" â‹ˆ "e3"
âŸ¨ "e12" "e2" "e3" âŸ©
    (â‹ˆ"e123") âˆ¾ "e2" â‹ˆ "e3"
âŸ¨ "e123" "e2" "e3" âŸ©
# but fundamentally different, enlisting will have Rank 1 and a shape; while
# enclosing have Rank 0 and an empty shape
â‰¡ (â‹ˆ"e123")
2
â‰¡ (<"e123")
2
= (â‹ˆ"e123")
1
= (<"e123")
0
â‰¢ (â‹ˆ"e123")
âŸ¨ 1 âŸ©
â‰¢ (<"e123")
âŸ¨âŸ©
# tedious way to join a long list; but notice how the multiple trains are working
    6 (+ <âŠ¸âˆ¾ - <âŠ¸âˆ¾ Ã— â‹ˆ Ã·) 3
âŸ¨ 9 3 18 2 âŸ©
# easier way; extract out the Functions as right operand
    {6ğ•3}Â¨ +â€¿-â€¿Ã—â€¿Ã·
âŸ¨ 9 3 18 2 âŸ©

Pair vs Couple
    "abc" â‰ "def"  # treats arguments as Cells and add a dimension (axis) 
â”Œâ”€     
â•µ"abc  
  def" 
      â”˜

    "abc" â‹ˆ "def"  # treats arguments as elements and add depth
âŸ¨ "abc" "def" âŸ©


https://mlochbaum.github.io/BQN/doc/primitive.html

# for spec reference
https://github.com/mlochbaum/BQN/blob/c747cbab2847d454615712403f495f73823db917/spec/reference.bqn
-**
Ã— 	\=  Multiply
Ã· 	\- 	Reciprocal 	Divide
Ï€ 	\p 	Pi
âˆ 	\8 	Infinity
â‹† 	\+ 	Exponential 	Power
âˆš 	\_ 	Square Root 	Root
' 		Character
@ 		Null character
Ëœ 	\` 	Swap 	Self
â¼ 	\3 	Undo
Ë™ 	\" 	Constant
âˆ˜ 	\j 	Atop


Swap Ëœ , swap the arguments
    2 -Ëœ 'd'  # Subtract from
'b'
    +Ëœ 3      # Add to itself
6
    Ã—Ëœ 4    # 2 ways to square a number
16
    2 â‹†Ëœ 4
16
--
Undo â¼ , undo the function
    âˆšâ¼ 4 , undo the âˆš function, âˆšx = 4, x = ?
16
    â‹†â¼ 10, natural e â‹† ? = 10
2.302585092994046
    2 â‹†â¼ 32    # Log base 2
5
    2 â‹† 2 â‹†â¼ 32
32
    10 â‹†â¼ 1e4  # Log base 10 of a number in scientific notation
4
-
    2 âŒ½ "abcde"
"cdeab"

    2 âŒ½â¼ 2 âŒ½ "abcde"
"abcde"

    Ã—Ëœ Â¯3
9
    Ã—Ëœâ¼ Ã—Ëœ Â¯3  # It's not the same!
3

Undo doesnt always satisfy ğ•© â‰¡ ğ”½â¼ ğ”½ ğ•©, 
but it does obey ğ•© â‰¡ ğ”½ ğ”½â¼ ğ•©

That is, it gives one possible argument that could have been passed to ğ”½, just not necessarily the one that actually was. 

--
Ë™ , Constant
    2 3Ë™ 4 # turns operand into a constant function that always return the operand
3
--
âˆ˜, Atop
it combine (or compose) 2 functions (or actually AKA 2-trains)
it produces a derived function which uses the left operand monadically to post-processes the result of the ambivalent right operand.

    3 Ã—Ëœâˆ˜+ 4  # Square of 3 plus 4
49
    -âˆ˜(Ã—Ëœ) 5  # Negative square of 5
Â¯25


--
Arithmetic

    3â€¿4â€¿5â€¿6 â‰¤ 5
âŸ¨ 1 1 1 0 âŸ©

    'c' < "acbz"
âŸ¨ 0 0 0 1 âŸ©<âˆ˜/Ë˜

    Â¯âˆâ€¿Ï€â€¿âˆ â‰¥ @â€¿'0'â€¿'?'
âŸ¨ 0 0 0 âŸ©

#Comparisons test for `atomic equality` 
    +â€¿-â€¿Ã—â€¿Ã· = âŠ‘âŸ¨-âŸ©
âŸ¨ 0 1 0 0 âŸ©

    'b' â‰  "abacba"
âŸ¨ 1 0 1 1 0 1 âŸ©

--
Modifiers is NOT function
Literal (characters and numbers) or a primitive (functions and modifiers), and has a fixed value. Primitive 1-modifiers have superscript characters and 2-modifiers contain unbroken circles. Other primitives are always functions.

Role 	    Types
Subject 	Number, Character
Function 	Function
1-modifier 	1-modifier
2-modifier 	2-modifier

Every primitive 1-modifer is a superscript character Ëœâ¼Ë™, and the remaining array-based modifiers Ë˜Â¨âŒœÂ´Ë`

The 2-modifiers in BQN are the combinators âˆ˜â—‹âŠ¸âŸœâŠ˜, the sort-of-combinators âŒ¾â—¶âŸ, and the not-at-all-combinators â‰âš‡âŠ. And the functions that make that unbroken circle rule necessary are written âŒ½â‰.



-**
"		String
âŸ¨	\(	Start list
âŸ©	\)	End list
â‹„	\;	Separator
,		Separator

(zoom in if you cannot see the diamond shape â‹„)	
â‹„	,  (and also newline) are completely interchangeable	

âŸ¨
  "putting"         # This is a comment
  "a",              # That , wasn't needed
  "list"
                    # An extra newline won't hurt anything
  "on","multiple"   # Two elements here
  "lines"
âŸ©

#		Comment
â€¿	\ 	Strand    (\ followed by a space)

ligature â€¿ has a higher precedence than either functions or operator

#below 2 expressions are equivalent
âŸ¨2,+,-âŸ©
2â€¿+â€¿-

#use brackets to nest ligatures
    0â€¿1â€¿2
âŸ¨ 0 1 2 âŸ©
    (0â€¿1)â€¿2
âŸ¨ âŸ¨ 0 1 âŸ© 2 âŸ©
    0â€¿(1â€¿2)
âŸ¨ 0 âŸ¨ 1 2 âŸ© âŸ©

--
Data types - Number Character Array
Operation types - Function 1-modifier 2-modifier
Atom - Number Character, Function 1-modifier 2-modifier

#arithmetic functions are pervasive
    2 Ã— âŸ¨0â€¿2 â‹„ 1â€¿3â€¿5âŸ©
âŸ¨ âŸ¨ 0 4 âŸ© âŸ¨ 2 6 10 âŸ© âŸ©

    âŸ¨ 10, 20â€¿30 âŸ© + âŸ¨ 1â€¿2, 3 âŸ©
âŸ¨ âŸ¨ 11 12 âŸ© âŸ¨ 23 33 âŸ© âŸ©

-**
list functions 
        1-arg   2-args
â‰	\.	Solo	Couple
âˆ¾	\,		    Join To
âŒ½	\q	Reverse	Rotate

modifiers
Â¨	\2	Each
Â´	\5	Fold
âˆ¾	\,	Join	Join To

â†•	\d	Range	
âŠ¸	\h	Bind?	

Couple
    â‰ 4
âŸ¨ 4 âŸ©
    2 â‰ 4
âŸ¨ 2 4 âŸ©

Join To (Dyadic)
Join (Monad)

# Join to combine arguments along first axis
    âŸ¨1,2,3âŸ© âˆ¾ "abc"
âŸ¨ 1 2 3 'a' 'b' 'c' âŸ©

    0 âˆ¾ âŸ¨1,2,3âŸ©
âŸ¨ 0 1 2 3 âŸ©

    "plural" âˆ¾ 's'
"plurals"

#Notice the difference between couple and join
âŸ¨1,2âŸ© â‰ âŸ¨3,4âŸ©
â”Œâ”€     
â•µ 1 2  
  3 4  
      â”˜
âŸ¨1,2âŸ© â‰ âŸ¨3,4,5âŸ©
>ğ•©: Elements of ğ•© must have matching shapes

âŸ¨1,2âŸ© âˆ¾ âŸ¨3,4âŸ©
âŸ¨ 1 2 3 4 âŸ©

#For arrays with rank 2 or more, arguments will joined "vertically"
    âŠ¢ a â† 3 +âŒœâ—‹â†• 4
â”Œâ”€         
â•µ 0 1 2 3  
  1 2 3 4  
  2 3 4 5  
          â”˜
    âŠ¢ b â† 2â€¿4 â¥Š â†•8
â”Œâ”€         
â•µ 0 1 2 3  
  4 5 6 7  
          â”˜
    a âˆ¾ b
â”Œâ”€         
â•µ 0 1 2 3  
  1 2 3 4  
  2 3 4 5  
  0 1 2 3  
  4 5 6 7  
          â”˜

# Join To needs major cells to have same shape
# in above example major cells (row wise) shape is 4
    âŠ‘â‰¢Ë˜2â€¿4 â¥Š â†•8
4

Reverse / Rotate
    âŒ½ "drawer"
"reward"
    2 âŒ½ âŸ¨0,1,2,3,4âŸ©
âŸ¨ 2 3 4 0 1 âŸ©
    Â¯1 âŒ½ "bcdea"
"abcde"

--
like how Reverse move element in a list from front to back
transpose â‰ move axis from front to back

   â†•2â€¿3â€¿4
â”Œâ”€
â• âŸ¨ 0 0 0 âŸ© âŸ¨ 0 0 1 âŸ© âŸ¨ 0 0 2 âŸ© âŸ¨ 0 0 3 âŸ©
  âŸ¨ 0 1 0 âŸ© âŸ¨ 0 1 1 âŸ© âŸ¨ 0 1 2 âŸ© âŸ¨ 0 1 3 âŸ©
  âŸ¨ 0 2 0 âŸ© âŸ¨ 0 2 1 âŸ© âŸ¨ 0 2 2 âŸ© âŸ¨ 0 2 3 âŸ©

  âŸ¨ 1 0 0 âŸ© âŸ¨ 1 0 1 âŸ© âŸ¨ 1 0 2 âŸ© âŸ¨ 1 0 3 âŸ©
  âŸ¨ 1 1 0 âŸ© âŸ¨ 1 1 1 âŸ© âŸ¨ 1 1 2 âŸ© âŸ¨ 1 1 3 âŸ©
  âŸ¨ 1 2 0 âŸ© âŸ¨ 1 2 1 âŸ© âŸ¨ 1 2 2 âŸ© âŸ¨ 1 2 3 âŸ©
                                          â”˜
   â‰â†•2â€¿3â€¿4
â”Œâ”€
â• âŸ¨ 0 0 0 âŸ© âŸ¨ 1 0 0 âŸ©
  âŸ¨ 0 0 1 âŸ© âŸ¨ 1 0 1 âŸ©
  âŸ¨ 0 0 2 âŸ© âŸ¨ 1 0 2 âŸ©
  âŸ¨ 0 0 3 âŸ© âŸ¨ 1 0 3 âŸ©

  âŸ¨ 0 1 0 âŸ© âŸ¨ 1 1 0 âŸ©
  âŸ¨ 0 1 1 âŸ© âŸ¨ 1 1 1 âŸ©
  âŸ¨ 0 1 2 âŸ© âŸ¨ 1 1 2 âŸ©
  âŸ¨ 0 1 3 âŸ© âŸ¨ 1 1 3 âŸ©

  âŸ¨ 0 2 0 âŸ© âŸ¨ 1 2 0 âŸ©
  âŸ¨ 0 2 1 âŸ© âŸ¨ 1 2 1 âŸ©
  âŸ¨ 0 2 2 âŸ© âŸ¨ 1 2 2 âŸ©
  âŸ¨ 0 2 3 âŸ© âŸ¨ 1 2 3 âŸ©
                      â”˜
   â‰¢â‰â†•2â€¿3â€¿4
âŸ¨ 3 4 2 âŸ©   # moved first axis to back

    â‰¢ a23456 â† â†•2â€¿3â€¿4â€¿5â€¿6
âŸ¨ 2 3 4 5 6 âŸ©

    â‰¢ â‰ a23456
âŸ¨ 3 4 5 6 2 âŸ©

# but, to exchange multiple axes, use Repeat modifier
# can use negative power to move axes in other direction, just like how Rotate
# works on list
    â‰¢ â‰âŸ3 a23456
âŸ¨ 5 6 2 3 4 âŸ©

    â‰¢ â‰â¼ a23456   # same as â‰Â¯1
âŸ¨ 6 2 3 4 5 âŸ©
   
   â‰¢â‰âŸÂ¯1â†•2â€¿3â€¿4
âŸ¨ 4 2 3 âŸ©

in fact, â‰¢â‰âŸk a â†â†’ kâŒ½â‰¢a

To move axes other than first, use Rank modifier
    â‰¢ â‰â‰3 a23456
âŸ¨ 2 3 5 6 4 âŸ©  # k > 0; transpose only last k axes, in this case 4,5,6

    â‰¢ â‰â¼â‰Â¯1 a23456
âŸ¨ 2 6 3 4 5 âŸ©  # k < 0; ignore first |k axes, in this case, ignore 2

But is not friendly to use when we want to reorder multiple axes, so we have dyadic â‰

# For each index pâ†iâŠ‘ğ•¨ in the left argument, axis i of ğ•© is used for axis p of the result.
# think of the ğ•¨ as the NEW axes' indices
    â‰¢ 1â€¿3â€¿2â€¿0â€¿4 â‰ a23456
âŸ¨ 5 2 4 3 6 âŸ©
# simplify: take 
indices 0 1 2 3 4    0 1 2 3 4 
        1 3 2 0 4    2 3 4 5 6
so, ğ•©'s index 0's 2 goes to new axes index 1, index 1's 3, goes to 3, etc

# if we want to specify all axes, the inverse transpose might be more
# intuitive
# it directly refer to ğ•© (old axes) indices (instead of new axes indices)
    â‰¢ 1â€¿3â€¿2â€¿0â€¿4 â‰â¼ a23456
âŸ¨ 3 5 4 2 6 âŸ©

# BQN extension allows only some axes to be specified, and the remaining
# unspecified axes will be placed in order into the gaps 

    â‰¢ 0â€¿2â€¿4 â‰ a23456  # here, only new axes indices 0,2 and 4 are specified
âŸ¨ 2 5 3 6 4 âŸ© 

    â‰¢ 2 â‰ a23456  # Restrict Transpose to the first three axes
âŸ¨ 3 4 2 5 6 âŸ© # only need to specify new axes index for first axis 2

Interesting to note that, the monadic â‰, is simply the dyadic Transpose with left argument of (=-1Ë™)
   â‰¢ â‰ â†•1â€¿2â€¿3â€¿4
âŸ¨ 2 3 4 1 âŸ©
   â‰¢(=-1Ë™)âŠ¸â‰ â†•1â€¿2â€¿3â€¿4
âŸ¨ 2 3 4 1 âŸ©

# notice that (=-1Ë™) is a fork, it takes the = Rank of ğ•© and minus it by 1
1Ë™ returns constant 1
so above is essentially â‰¢ 3â‰ â†•1â€¿2â€¿3â€¿4 ; means move the first one to the last index position of the new axes

--
Join
    âˆ¾"time"â€¿"to"â€¿"join"â€¿"some"â€¿"words"
"timetojoinsomewords"

Merge (>) does to Couple (â‰): aâ‰b is >aâ€¿b as Join does to Join To: aâˆ¾b is âˆ¾aâ€¿b. 
While Merge and Couple combine arrays (the elements of Merge's argument, or the arguments themselves for Couple) along a new leading axis, Join and Join to combine them along the existing leading axis.

# to join a separator between each words
# prepend the separator to each string, join, then remove the leading separator
    1â†“âˆ¾' 'âˆ¾Â¨"time"â€¿"to"â€¿"join"â€¿"some"â€¿"words"
"time to join some words"

# as long as the major cells length matches
    âŠ¢ m â† (3â€¿1â‰âŒœ4â€¿2â€¿5) â¥ŠÂ¨ 2â€¿3â¥Šâ†•6
â”Œâ”€                                   
â•µ â”Œâ”€          â”Œâ”€      â”Œâ”€             
  â•µ 0 0 0 0   â•µ 1 1   â•µ 2 2 2 2 2    
    0 0 0 0     1 1     2 2 2 2 2    
    0 0 0 0     1 1     2 2 2 2 2    
            â”˜       â”˜             â”˜  
  â”Œâ”€          â”Œâ”€      â”Œâ”€             
  â•µ 3 3 3 3   â•µ 4 4   â•µ 5 5 5 5 5    
            â”˜       â”˜             â”˜  
                                    â”˜
    âˆ¾ m  # Join all that together
â”Œâ”€                       
â•µ 0 0 0 0 1 1 2 2 2 2 2  
  0 0 0 0 1 1 2 2 2 2 2  
  0 0 0 0 1 1 2 2 2 2 2  
  3 3 3 3 4 4 5 5 5 5 5  
                        â”˜

    âŠ¢ n â† 2â€¿4â€¿6 Ã—{âŸ¨ğ•—,ğ•©âŸ©â‰âŸ¨ğ•¨,ğ•¨ğ”½âŒœğ•©âŸ©} 5â€¿6â€¿7â€¿8
â”Œâ”€                           
â•µ Ã—         âŸ¨ 5 6 7 8 âŸ©      
  âŸ¨ 2 4 6 âŸ© â”Œâ”€               
            â•µ 10 12 14 16    
              20 24 28 32    
              30 36 42 48    
                          â”˜  
                            â”˜

    â‰¢Â¨ n  # Different ranks but compatible shapes
â”Œâ”€               
â•µ âŸ¨âŸ©    âŸ¨ 4 âŸ©    
  âŸ¨ 3 âŸ© âŸ¨ 3 4 âŸ©  
                â”˜

# a multiplication table
    âˆ¾ n
â”Œâ”€               
â•µ Ã— 5  6  7  8   
  2 10 12 14 16  
  4 20 24 28 32  
  6 30 36 42 48  
                â”˜

How to `revert` back a higher rank merged array?
   d â† 2â€¿2â¥Šâ†•4
â”Œâ”€     
â•µ 0 1  
  2 3  
      â”˜
   <Ë˜d    # so opposite of > is <Ë˜
âŸ¨ âŸ¨ 0 1 âŸ© âŸ¨ 2 3 âŸ© âŸ©

---
Each
    âŒ½Â¨ "abcd"â€¿"ABCDEF"â€¿"01"
âŸ¨ "dcba" "FEDCBA" "10" âŸ©

    "string"â€¿"list"â€¿"array" âˆ¾Â¨ 's'  # can see Each can apply to both ğ•¨ ğ•© arguments
âŸ¨ "strings" "lists" "arrays" âŸ©

    "abc" â‰Â¨ âŒ½ "abc"  #this is like a zip 
âŸ¨ "ac" "bb" "ca" âŸ©

Depth of an array is the greatest level of array nesting it attains, or, put another way, the greatest number of times you can pick an element starting from the original array before reaching an atom
Depth 2-modifier (âš‡) is a generalization of Each that allows diving deeper into an array

    n â† <â‰1âŸ2 4â€¿3â€¿2â€¿2â¥Šâ†•48
â”Œâ”€                                                                         
â•µ âŸ¨ âŸ¨ 0 1 âŸ© âŸ¨ 2 3 âŸ© âŸ©     âŸ¨ âŸ¨ 4 5 âŸ© âŸ¨ 6 7 âŸ© âŸ©     âŸ¨ âŸ¨ 8 9 âŸ© âŸ¨ 10 11 âŸ© âŸ©    
  âŸ¨ âŸ¨ 12 13 âŸ© âŸ¨ 14 15 âŸ© âŸ© âŸ¨ âŸ¨ 16 17 âŸ© âŸ¨ 18 19 âŸ© âŸ© âŸ¨ âŸ¨ 20 21 âŸ© âŸ¨ 22 23 âŸ© âŸ©  
  âŸ¨ âŸ¨ 24 25 âŸ© âŸ¨ 26 27 âŸ© âŸ© âŸ¨ âŸ¨ 28 29 âŸ© âŸ¨ 30 31 âŸ© âŸ© âŸ¨ âŸ¨ 32 33 âŸ© âŸ¨ 34 35 âŸ© âŸ©  
  âŸ¨ âŸ¨ 36 37 âŸ© âŸ¨ 38 39 âŸ© âŸ© âŸ¨ âŸ¨ 40 41 âŸ© âŸ¨ 42 43 âŸ© âŸ© âŸ¨ âŸ¨ 44 45 âŸ© âŸ¨ 46 47 âŸ© âŸ©  
                                                                          â”˜
    â‰¡ n
3
#n is a 4 x 3 matrix of list of list
# apply
    âŒ½âš‡Â¯1 n  # equivalent to âŒ½Â¨n and âŒ½âš‡2 n, reverse the larger list
â”Œâ”€                                                                         
â•µ âŸ¨ âŸ¨ 2 3 âŸ© âŸ¨ 0 1 âŸ© âŸ©     âŸ¨ âŸ¨ 6 7 âŸ© âŸ¨ 4 5 âŸ© âŸ©     âŸ¨ âŸ¨ 10 11 âŸ© âŸ¨ 8 9 âŸ© âŸ©    
  âŸ¨ âŸ¨ 14 15 âŸ© âŸ¨ 12 13 âŸ© âŸ© âŸ¨ âŸ¨ 18 19 âŸ© âŸ¨ 16 17 âŸ© âŸ© âŸ¨ âŸ¨ 22 23 âŸ© âŸ¨ 20 21 âŸ© âŸ©  
  âŸ¨ âŸ¨ 26 27 âŸ© âŸ¨ 24 25 âŸ© âŸ© âŸ¨ âŸ¨ 30 31 âŸ© âŸ¨ 28 29 âŸ© âŸ© âŸ¨ âŸ¨ 34 35 âŸ© âŸ¨ 32 33 âŸ© âŸ©  
  âŸ¨ âŸ¨ 38 39 âŸ© âŸ¨ 36 37 âŸ© âŸ© âŸ¨ âŸ¨ 42 43 âŸ© âŸ¨ 40 41 âŸ© âŸ© âŸ¨ âŸ¨ 46 47 âŸ© âŸ¨ 44 45 âŸ© âŸ©  
                                                                          â”˜
    âŒ½âš‡Â¯2 n  # equivalent to âŒ½âš‡1 n, apply Each twice, reverse larger list and smaller list
â”Œâ”€                                                                         
â•µ âŸ¨ âŸ¨ 1 0 âŸ© âŸ¨ 3 2 âŸ© âŸ©     âŸ¨ âŸ¨ 5 4 âŸ© âŸ¨ 7 6 âŸ© âŸ©     âŸ¨ âŸ¨ 9 8 âŸ© âŸ¨ 11 10 âŸ© âŸ©    
  âŸ¨ âŸ¨ 13 12 âŸ© âŸ¨ 15 14 âŸ© âŸ© âŸ¨ âŸ¨ 17 16 âŸ© âŸ¨ 19 18 âŸ© âŸ© âŸ¨ âŸ¨ 21 20 âŸ© âŸ¨ 23 22 âŸ© âŸ©  
  âŸ¨ âŸ¨ 25 24 âŸ© âŸ¨ 27 26 âŸ© âŸ© âŸ¨ âŸ¨ 29 28 âŸ© âŸ¨ 31 30 âŸ© âŸ© âŸ¨ âŸ¨ 33 32 âŸ© âŸ¨ 35 34 âŸ© âŸ©  
  âŸ¨ âŸ¨ 37 36 âŸ© âŸ¨ 39 38 âŸ© âŸ© âŸ¨ âŸ¨ 41 40 âŸ© âŸ¨ 43 42 âŸ© âŸ© âŸ¨ âŸ¨ 45 44 âŸ© âŸ¨ 47 46 âŸ© âŸ©  
                                                                          â”˜
    âŸ¨'a',"bc"âŸ© â‰âš‡0 âŸ¨2â€¿3,4âŸ© # depth of 0 means apply pervasively
â”Œâ”€                                                 
Â· âŸ¨ âŸ¨ 'a' 2 âŸ© âŸ¨ 'a' 3 âŸ© âŸ© âŸ¨ âŸ¨ 'b' 4 âŸ© âŸ¨ 'c' 4 âŸ© âŸ©  
                                                  â”˜

when n is positive, it means, apply until THIS depth

----
Fold  \5 (Right fold)
    +Â´ 2â€¿3â€¿4
9
    Ã—Â´ 2â€¿3â€¿4
24
  #alternating sum, execution order from right to left
    -Â´ 1â€¿2â€¿3â€¿4â€¿5
3
    1-2-3-4-5
3
    âˆ¾Â´ âŸ¨ "con", "cat", "enat", "e" âŸ©
"concatenate"
# but shouldn't need the Each, just Join is enough
    âˆ¾ âŸ¨ "con", "cat", "enat", "e" âŸ©
"concatenate"

# can see right fold in action
    â‹ˆÂ´ "abcd"
âŸ¨ 'a' âŸ¨ 'b' "cd" âŸ© âŸ©

    'a' â‹ˆ 'b' â‹ˆ 'c' â‹ˆ 'd'  # Expanded form
âŸ¨ 'a' âŸ¨ 'b' "cd" âŸ© âŸ©

# left Fold 
    â‹ˆËœÂ´ âŒ½ "abcd"
âŸ¨ âŸ¨ "ab" 'c' âŸ© 'd' âŸ©
Can specify an initial element for Fold: simply pass it as ğ•¨
    +Â´1â€¿2â€¿3
6
    5+Â´1â€¿2â€¿3
11
    âˆ¾â—‹â¥ŠÂ´ âŸ¨2â€¿4â‰6â€¿8,"abcd",0âŸ©
âŸ¨ 2 4 6 8 'a' 'b' 'c' 'd' 0 âŸ©

    âˆ¾â—‹â¥ŠÂ´ âŸ¨2â€¿4â‰6â€¿8,"abcd"âŸ©
âŸ¨ 2 4 6 8 'a' 'b' 'c' 'd' âŸ©
# the one-element case, when âˆ¾â—‹â¥Š is never applied and can't deshape anything
    âˆ¾â—‹â¥ŠÂ´ âŸ¨2â€¿4â‰6â€¿8âŸ©
â”Œâ”€     
â•µ 2 4  
  6 8  
      â”˜
# when initial element, âˆ¾â—‹â¥Š is applied at least once (with the initial element
# 'added' to the end of the list)
    âŸ¨âŸ© âˆ¾â—‹â¥ŠÂ´ âŸ¨2â€¿4â‰6â€¿8âŸ©
âŸ¨ 2 4 6 8 âŸ©

    "end" âˆ¾â—‹â¥ŠÂ´ âŸ¨"start","middle"âŸ©
"startmiddleend"

A function P can be applied to each element of ğ•© before operating using ğ•¨PâŠ¸FÂ´ğ•©, which is equivalent to ğ•¨ FÂ´ PÂ¨ğ•©

    "STOP" âŒ½âŠ¸âˆ¾Â´ "ABCDE"â€¿"012"â€¿"abcd"
"EDCBA210dcbaSTOP"

----
Insert \6 Ë (similar to APL âŒ¿)

    âŠ¢ tab â† (2+â†•5) |âŒœ 9+â†•3
â”Œâ”€       
â•µ 1 0 1  
  0 1 2  
  1 2 3  
  4 0 1  
  3 4 5  
        â”˜

#Insert works on the leading axis of the argument
    +Ë tab
âŸ¨ 9 7 12 âŸ©

#sum each row (second axis)
    +ËË˜ tab
âŸ¨ 2 3 6 5 12 âŸ©

# a tricky case
because +Â´Ë˜ tab yields the same result but is actually unsoundâ€”if tab contains arrays then they will be merged together at the end. Remember that if you want to reduce along one axis of an array but get an array of results out, you should use Insert (possibly adding Each to work on elements instead of cells).

#An Insert ğ”½Ë is roughly equals to {ğ•¨ğ”½Â´<Ë˜ğ•©}
#but it takes the argument shape into account
    +Â´<Ë˜ 0â€¿4â¥Š0
0
    +Ë   0â€¿4â¥Š0
âŸ¨ 0 0 0 0 âŸ©


    "id" â‹ˆË "row0 "âˆ¾"row1 "â‰"row2 "
â”Œâ”€                                      
Â· "row0 " âŸ¨ "row1 " âŸ¨ "row2 " "id" âŸ© âŸ©  
                                       â”˜
breakdown:
    "row0 "âˆ¾"row1 "â‰"row2 "
â”Œâ”€       
â•µ"row0   
  row1   
  row2 " 
        â”˜
#and then initial "id" is paired along the first axis

One trick involving Insert is âˆ¾Ë, which merges the first two axes of ğ•© into one long axis.

    âŠ¢ let â† ("AHW"-'A') +âŒœ "aA" +âŒœ â†•4
â”Œâ”€      
â•"abcd  
  ABCD  
        
 Â·hijk  
  HIJK  
        
 Â·wxyz  
  WXYZ" 
       â”˜

    âˆ¾Ë let
â”Œâ”€      
â•µ"abcd  
  ABCD  
  hijk  
  HIJK  
  wxyz  
  WXYZ" 
       â”˜

    â‰¢ âˆ¾Ë â†•3â€¿2â€¿4
âŸ¨ 6 4 âŸ©

    â‰¢ âˆ¾Ë â†•0â€¿2â€¿4  # The identity is an empty cell
âŸ¨ 0 4 âŸ©


----
Scan `
    âŒˆ` 2â€¿0â€¿0â€¿4â€¿1
âŸ¨ 2 2 2 4 4 âŸ©
#traverses the array in forward (left to right) rather than reverse index order
#includes all intermediate results of ğ”½ in its output instead of just the final one

    -` 1â€¿2â€¿3â€¿4â€¿5
âŸ¨ 1 Â¯1 Â¯4 Â¯8 Â¯13 âŸ©


Shift  (or called Nudge - when move by 1 cell)
Â» - add major cells to beginning
Â« - add major cells to end

    0â€¿0 Â» 3â€¿2â€¿1             # Shift Before
âŸ¨ 0 0 3 âŸ©
    "end" Â« "add to the "   # Shift After
" to the end"

    Â» "abcd"   # Nudge
" abc"
    Â« 1â€¿2â€¿3    # Nudge Back
âŸ¨ 2 3 0 âŸ©





--
e.g.
how to decode binary string to decimal: e.g. "1001" -> 9
    2 â‹† â†•4
âŸ¨ 1 2 4 8 âŸ©

    âŒ½2â‹†â†•4
âŸ¨ 8 4 2 1 âŸ©

    (âŒ½2â‹†â†•4) Ã— "1001"-'0'
âŸ¨ 8 0 0 1 âŸ©

    +Â´ (âŒ½2â‹†â†•4) Ã— "1001"-'0'
9

how about given a list of binary strings?
    '0' -Ëœ "01001110"â€¿"01100101"â€¿"01110010"â€¿"01100100"â€¿"00100001"
âŸ¨ âŸ¨ 0 1 0 0 1 1 1 0 âŸ© âŸ¨ 0 1 1 0 0 1 0 1 âŸ© âŸ¨ 0 1 1 1 0 0 1 0 âŸ© âŸ¨ 0 1 1 0 0 1 0 0 âŸ© âŸ¨ 0 0 1 0 0 0 0 1 âŸ© âŸ©

# use Bind âŠ¸ 	
# to 'pack' the data
    # like zip, take atom from LHS to zip with higher rank list on RHS e.g. 'a' âˆ¾ "cd" ..
    "ab" âˆ¾Â¨ âŸ¨ "cd", "ut" âŸ© 
âŸ¨ "acd" "but" âŸ© 
    # but, we can 'pack' "ab" as one thing, so "ab" âˆ¾ "cd" instead
    "ab"âŠ¸âˆ¾Â¨ âŸ¨ "cd", "ut" âŸ©
âŸ¨ "abcd" "abut" âŸ©

    +Â´Â¨ (âŒ½2â‹†â†•8)âŠ¸Ã—Â¨ '0' -Ëœ "01001110"â€¿"01100101"â€¿"01110010"â€¿"01100100"â€¿"00100001"
âŸ¨ 78 101 114 100 33 âŸ©

   # small breakdown for first element
+Â´ âŸ¨ 128 64 32 16 8 4 2 1 âŸ© Ã— âŸ¨ 0 1 0 0 1 1 1 0 âŸ©
   # =78


functions: take 1 or 2 data types as arguments
modifiers: modify the basic behaviour of function(s)

Precedence	Role	Associativity
0       	()âŸ¨âŸ©	    (none)
1       	â€¿	        Non-binary
2       	Modifier	Left-to-right
3       	Function	Right-to-left


--
Tacit programming

    |âˆ˜- 6
6

    7 |âˆ˜- 9
2

# |âˆ˜- is the absolute difference
    14â€¿8 |âˆ˜- 19â€¿6
âŸ¨ 5 2 âŸ©
# sum of absolute differences in the Manhattan distance
    14â€¿8 +Â´âˆ˜|âˆ˜- 19â€¿6
7

-**Combinators
        1-arg   2-arg
Ëœ	\`	Self	Swap
Ë™	\"	Constant
âˆ˜	\j	Atop

-**Comparisons
<			    Less Than
>			    Greater Than
â‰ 	\/	Length	Not Equals
=		Rank	Equals
â‰¤	\<		    Less Than or Equal to
â‰¥	\>		    Greater Than or Equal to

    3 < 4
1
    4 > âˆ
0
    âˆ < @  # Characters are always considered greater than numbers
1

    'e' = "George Boole"
âŸ¨ 0 1 0 0 0 1 0 0 0 0 0 1 âŸ©

    +Â´ 'e' = "George Boole"
3

    'e' +Â´âˆ˜= "George Boole"  # With a combinator
3

-- Length and Rank
# Length - number of elements in a list
    â‰  "testing"
7
    â‰  âŸ¨âŸ©
0
    â‰  âŸ¨ Ï€, âˆ˜, "element" â‹„ âŸ¨'l',1,5,'t'âŸ© âŸ©
4
    â‰  4
1

# Rank
    = 0.5
0
    = â†•3
1
    = 'a'
0
    = "a"
1

# Depth (â‰¡) gives the recursive nesting depth of its argument: the greatest number of times you can take an element before reaching an atom.
    â‰¡ "dream"                  # An ordinary dream
1
    â‰¡ "d"â€¿"r"â€¿"e"â€¿"a"â€¿"m"      # What if the letters were strings?
2
    â‰¡ âŸ¨ "d"â€¿"r"â€¿"e"â€¿"a"â€¿"m" âŸ©  # We have to go deeper
3

-** Whole array comparisons
â‰¡	\m	Depth	Match
â‰¢	\M	Shape	Not Match

    "abcd" â‰¡ "abdd"
0
    "abc"â€¿"de" â‰¡ "abc"â€¿"de"
1
    2â€¿3â€¿4â€¿2 â‰  3â€¿3â€¿2â€¿2  # compare individual atoms
âŸ¨ 1 0 1 0 âŸ©
    2â€¿3â€¿4â€¿2 â‰¢ 3â€¿3â€¿2â€¿2  # compare whole array
1

# How to test whether 2 arrays have same length?
    (â‰ "string") = â‰ "sting"  # yes.. but ugly 
0

# Introduce another composition modifier
â—‹	\k	Over

    "string" =â—‹â‰  "sting"
0

Over calls its right operand on each argument individually. The results are then all used as arguments to the left operand. If there's only one argument, Atop and Over turn out to be the same: both of them call the right operand, then the left.
       Atop
    ğ”½         ğ”½
    |         |
    ğ”¾         ğ”¾
    |       /   \
    ğ•©      ğ•¨     ğ•©

  ğ”½âˆ˜ğ”¾ ğ•©     ğ•¨ ğ”½âˆ˜ğ”¾ ğ•©     => ğ”½ (ğ•¨ ğ”¾ ğ•©)

       Over

    ğ”½         ğ”½
    |       /   \
    ğ”¾      ğ”¾     ğ”¾
    |      |     |    
    ğ•©      ğ•¨     ğ•©

  ğ”½â—‹ğ”¾ ğ•©     ğ•¨ ğ”½â—‹ğ”¾ ğ•©    => (ğ”¾ ğ•¨) ğ”½ (ğ”¾ ğ•©)

--
Before and after
âŠ¸	\h	Before/Bind
âŸœ	\l	After/Bind

Before ğ”½âŠ¸ğ”¾ ğ•©, ğ•¨ ğ”½âŠ¸ğ”¾ ğ•©   # Left ğ”½ executes first
After ğ”½âŸœğ”¾ ğ•©, ğ•¨ ğ”½âŸœğ”¾ ğ•©    # Right ğ”¾  executes first

https://mlochbaum.github.io/BQN/doc/primitive.html

After	  Before
2 â‹†âŸœ- 3	  2  â‹†âŠ¸-  3
2 â‹† - 3	  (â‹† 2) - 3

    4 -âŠ¸âŒ½ " before"  # Rotate to the right by four
"fore be"
    4 âŒ½â¼  " before"  # Okay this time Undo is better
"fore be"
#actually can also be simply
Â¯4âŒ½" before"

# for one argument case, the one argument is used in both input positions
e.g.
â†•8 gives us eight equally-spaced numbers, but to rescale them we'd want to divide by 8. That's (â†•8)Ã·8, but it's nicer to use Before again.

    â†•âŠ¸Ã· 8   #one argument case, same as (â†•8)âŠ¸Ã·8
âŸ¨ 0 0.125 0.25 0.375 0.5 0.625 0.75 0.875 âŸ©

    Â¬âŠ¸Ã— â†•âŠ¸Ã· 8    #  Â¬âŠ¸Ã— is y = x Ã— ( 1 - x)
âŸ¨ 0 0.109375 0.1875 0.234375 0.25 0.234375 0.1875 0.109375 âŸ©

# The below are all same
Before		    After
2âŠ¸â‹† 5	2 â‹† 5	â‹†âŸœ5 2

only slight confusion is the 'After' case, the `5 2` is treated as the 5Ë™2, with 2 being the data type input
this 2 only gets used in LHS, hence it becomes
2 â‹† 5Ë™2  = 2 â‹† 5 = 32

--
*Side note
Constant modifier Ë™

"hi"Ë™ 5
"hi"

4Ë™5
4

Swap modifier also exhibit this property
    "const"Ëœ 5
"const"
    @ "const"Ëœ 6
"const"

The modifier Ëœ applies its operand function to the arguments, after swapping them around or whatever. In this case, the operand function is a data type (not a function or modifier), so it ignores those arguments

so, the below works, as applying data type as operand will ignore the argument
    1âŠ¸+ 5 # also (1 5) + 5 = 1 + 5
6
    +âŸœ1 5 # also, 5 + (1 5) = 5 + 1
6

--
Exercise:

# how to do tacit programming which accepts 8 as an argument?
    (â†•8) Ã· 7
âŸ¨ 0 0.1428571428571428 0.2857142857142857 0.4285714285714285 0.5714285714285714 0.7142857142857143 0.8571428571428571 1 âŸ©

    -âŸœ1 8
7

    â†•âŠ¸Ã·âŸœ(-âŸœ1) 8
âŸ¨ 0 0.1428571428571428 0.2857142857142857 0.4285714285714285 0.5714285714285714 0.7142857142857143 0.8571428571428571 1 âŸ©

# some deconstruction
    â†•âŠ¸ Ã· âŸœ F 8
# 8 gets 'dup/bind over' to LHS by middle right bindâŸœ
    8 â†•âŠ¸ Ã·  F 8
# 8 â†•âŠ¸ left bind becomes (â†• 8)
    (â†• 8) Ã·  F 8
    (â†• 8) Ã·  7

# the big expression above can also be shorten into a 3-train (a fork)
    (â†•Ã·-âŸœ1) 8
âŸ¨ 0 0.1428571428571428 0.2857142857142857 0.4285714285714285 0.5714285714285714 0.7142857142857143 0.8571428571428571 1 âŸ©

# basically execute (f g h) 8 => (f 8) g (h 8)
# (â†• 8) Ã· ((-âŸœ1) 8)
# when a bunch of isolated functions / modifiers are jammed together, the
# association is from left to right
--
the APL â´ , shape, reshape operator is split into 

   1-arg   2-arg
â¥Š  deshape reshape  (\z)
â‰¢  shape   not match (\M)

â†•4â€¿5
â”Œâ”€                                         
â•µ âŸ¨ 0 0 âŸ© âŸ¨ 0 1 âŸ© âŸ¨ 0 2 âŸ© âŸ¨ 0 3 âŸ© âŸ¨ 0 4 âŸ©  
  âŸ¨ 1 0 âŸ© âŸ¨ 1 1 âŸ© âŸ¨ 1 2 âŸ© âŸ¨ 1 3 âŸ© âŸ¨ 1 4 âŸ©  
  âŸ¨ 2 0 âŸ© âŸ¨ 2 1 âŸ© âŸ¨ 2 2 âŸ© âŸ¨ 2 3 âŸ© âŸ¨ 2 4 âŸ©  
  âŸ¨ 3 0 âŸ© âŸ¨ 3 1 âŸ© âŸ¨ 3 2 âŸ© âŸ¨ 3 3 âŸ© âŸ¨ 3 4 âŸ©  
                                          â”˜
â‰¢â†•4â€¿5
âŸ¨ 4 5 âŸ©

4â€¿2â¥Šâ†•4â€¿5
â”Œâ”€                 
â•µ âŸ¨ 0 0 âŸ© âŸ¨ 0 1 âŸ©  
  âŸ¨ 0 2 âŸ© âŸ¨ 0 3 âŸ©  
  âŸ¨ 0 4 âŸ© âŸ¨ 1 0 âŸ©  
  âŸ¨ 1 1 âŸ© âŸ¨ 1 2 âŸ©  
                  â”˜
â¥Š4â€¿2â¥Šâ†•4â€¿5
âŸ¨ âŸ¨ 0 0 âŸ© âŸ¨ 0 1 âŸ© âŸ¨ 0 2 âŸ© âŸ¨ 0 3 âŸ© âŸ¨ 0 4 âŸ© âŸ¨ 1 0 âŸ© âŸ¨ 1 1 âŸ© âŸ¨ 1 2 âŸ© âŸ©

--
Train
BQN trains are same as Dyalog APL with the addition of Nothing (Â·)

--
Dot product


# uses the Atop âˆ˜ in BQN.. doesnt need a special . syntax like in APL
1â€¿2â€¿3 +Â´âˆ˜Ã— 4â€¿5â€¿6
32

# favourite 3 x 4 matrix
3â€¿4â¥Šâ†•12
â”Œâ”€           
â•µ 0 1  2  3  
  4 5  6  7  
  8 9 10 11  
            â”˜

--
Define â† \[
A variable cannot be defined twice in the same scope

    piâ€¿eâ€¿ten â† âŸ¨ Ï€, â‹†1, 10 âŸ©
âŸ¨ 3.141592653589793 2.718281828459045 10 âŸ©

    ten Ã— pi
31.41592653589793

    three â‰ ten - three â† 3
âŸ¨ 3 7 âŸ©

    three â† 4
ERROR

Change (Reassign) â†© \'

    three â†© 4

    three = 3   # Wait why did I do that
0

    3 = three â†© 3
1

    four â†© 3    # four isn't defined yet
ERROR

If you're coming from a typical curly-brace language, you'd say that â† both declares and assigns a variable, while â†© only assigns it.
-
    a â† 4            # First it's a number
    a
4

    a â†© 4â€¿5â€¿6        # Now it's a list!
    a
âŸ¨ 4 5 6 âŸ©

    a â†© a - 1
    a
âŸ¨ 3 4 5 âŸ©

    a -â†© 1 # shorthand - modified assignment, looks like -= or +=
âŸ¨ 2 3 4 âŸ©

    a âˆ¾Ëœâ†© 0â€¿1 # a â† a âˆ¾Ëœ 0â€¿1
âŸ¨ 0 1 2 3 4 âŸ©

--
1â€¿2 (4âŠ¸-) âˆ˜ âŠ£ @
âŸ¨ 3 2 âŸ©
  
#remember Atop

   ğ”½   (4âŠ¸-)
   |
   ğ”¾   âŠ£    # left identity, only return left arg if there's one
  / \
 ğ•¨   ğ•©
1â€¿2  @
--
#so, how about function with only one argument?
    a âŒ½âˆ˜âŠ£â†© @
âŸ¨ 4 3 2 1 0 âŸ©
# but BQN has a simpler syntax
# sort of like a reversed way of saying: "a reversed is"
    a âŒ½â†©
âŸ¨ 0 1 2 3 4 âŸ©

    a 4âŠ¸-â†©           # And back again
âŸ¨ 4 3 2 1 0 âŸ©
# no need parentheses on the 2-train (4âŠ¸-) becoz modifiers bind stronger
than assignment character

# with this
    -âŸœ4âŒ¾(Â¯2âŠ¸â†‘) a
âŸ¨ 4 3 2 Â¯3 Â¯4 âŸ©
# we can reassign like this
    a -âŸœ4âŒ¾(Â¯2âŠ¸â†‘)â†©
âŸ¨ 4 3 2 Â¯3 Â¯4 âŸ©


--
Role

Spelling	       Role	        Purpose
lowercase	       Subject	    Argument or operand
Uppercase	       Function	    Function call or operand
_leftUnderscore	   1-modifier	1-modifier call
_twoUnderscores_   2-modifier	2-modifier call

The role only depends on the first character of the name, and the last one if the first one was an underscore.

---
Variable are case insensitive

three â† 3

ThReE
3

---
Function assignment

    Base2 â† +âŸœ(2âŠ¸Ã—)Â´âˆ˜âŒ½

    Base2 1â€¿0â€¿1â€¿0
10

    Base2 "01010001"-'0'
81

    @ + Base2Â¨ '0' -Ëœ "01000010"â€¿"01010001"â€¿"01001110"
"BQN"

--
    Base2
+âŸœ(2âŠ¸Ã—)Â´âˆ˜âŒ½

    base2 â†© 16   # Change it to a number

    Base2
16

    Base2 6  # constant function
16

---
Modifiers
âŒ¾	\K	Under (only 2-arg, right arg is a function)
âŠ‘	\I	First	Pick

âŠ‘ "BQN"
'B'
1 âŠ‘ "BQN"
'Q'

    âŠ¢ a â† 'a' + â¥ŠâŸœ(â†•Ã—Â´) 4â€¿5
â”Œâ”€       
â•µ"abcde  
  fghij  
  klmno  
  pqrst" 
        â”˜
    2â€¿0 âŠ‘ a
'k'
    1â€¿Â¯1 âŠ‘ a
'j'

# Pick accepts a list of indices
# a is 2D matrix
    âŸ¨2â€¿0, 1â€¿Â¯1, 3â€¿1, Â¯1â€¿Â¯1âŸ© âŠ‘ a
"kjqt"

--
    âŸ¨2,1,0,Â¯1âŸ© âŠ‘ "abc"  # ğ•© doesn't have rank 4! i.e ğ•© need to be 4D
ERROR

    âŸ¨2,1,0,Â¯1âŸ© â¥ŠÂ¨âŠ¸âŠ‘ "abc"
"cbac"

#Breakdown
    (â¥ŠÂ¨âŸ¨2,1,0,Â¯1âŸ©) âŠ‘ "abc"
#note, â¥Š2 = âŸ¨2âŸ©
    âŸ¨ âŸ¨ 2 âŸ© âŸ¨ 1 âŸ© âŸ¨ 0 âŸ© âŸ¨ Â¯1 âŸ© âŸ© âŠ‘ "abc"
"cbac"

    âŸ¨2,1,0,Â¯1âŸ© âŠ "abc"  # Better way `âŠ` is select 
"cbac"

    âŸ¨2â€¿0, âŸ¨âŸ¨1â€¿Â¯1, 3â€¿1âŸ©, Â¯1â€¿Â¯1âŸ©âŸ© âŠ‘ a
âŸ¨ 'k' âŸ¨ "jq" 't' âŸ© âŸ©

    (âŸ¨2â€¿0, 1â€¿Â¯1âŸ©â‰âŸ¨3â€¿1, Â¯1â€¿Â¯1âŸ©) âŠ‘ a
â”Œâ”€    
â•µ"kj  
  qt" 
     â”˜

    (âŸ¨2â€¿0, <1â€¿Â¯1âŸ©â‰âŸ¨<3â€¿1, Â¯1â€¿Â¯1âŸ©) âŠ‘ a  # `<` is encase
â”Œâ”€             
â•µ 'k'   â”ŒÂ·     
        Â·'j'   
            â”˜  
  â”ŒÂ·    't'    
  Â·'q'         
      â”˜        
              â”˜
---
difference
   2â€¿0âŠâ†•4â€¿5 # select major axis
â”Œâ”€
â•µ âŸ¨ 2 0 âŸ© âŸ¨ 2 1 âŸ© âŸ¨ 2 2 âŸ© âŸ¨ 2 3 âŸ© âŸ¨ 2 4 âŸ©
  âŸ¨ 0 0 âŸ© âŸ¨ 0 1 âŸ© âŸ¨ 0 2 âŸ© âŸ¨ 0 3 âŸ© âŸ¨ 0 4 âŸ©
                                          â”˜
   2â€¿0âŠ‘â†•4â€¿5 # pick element
âŸ¨ 2 0 âŸ©

   âŸ¨<2,<0âŸ©âŠâ†•4â€¿5 # like this also can, but awkward
â”ŒÂ·
Â· âŸ¨ 2 0 âŸ©
          â”˜


--
Under âŒ¾	
    8âŒ¾âŠ‘ "BQN"        # Change the first element to 8
âŸ¨ 8 'Q' 'N' âŸ©

â†‘	\r Prefixes Take
â†“	\c Suffixes Drop
--
Use before combinator âŠ¸ to make a standalone function (2 or 3-train)

2 â†‘ "abcde"
"ab"
#what if i want to single out (2 â†‘) as a function itself?
Func1 â† 2 â†‘
Second-level parts of a train must be functions
Func1 â† 2 â†‘
        ^
# this happens becoz we are defining a 2-train, but `2` here is not a
# function
Func2 â† Ã·Ã— #this works, 2 functions here
Func2 100 #take the sign of the right arg and then the reciprocal of it
1
2 Func2 5 # 1 Ã· (2 Ã— 5)
0.1

#so, we can use the before combinator âŠ¸
#becoz 2âŠ¸ will execute first and give 2
Func1 â† 2âŠ¸â†‘
Func1 "abcde"
"ab"

#some variations
Func1 â† 2âŸœâ†‘   # the right `after` part execute first, and then 2 just const
Func1 "abcde"
2
Func1 â† 2Ë™â†‘  # its same as this
Func1 "abcde"
2

Prefixes / Suffixes (different from APL)
    â†‘ â†•5
âŸ¨ âŸ¨âŸ© âŸ¨ 0 âŸ© âŸ¨ 0 1 âŸ© âŸ¨ 0 1 2 âŸ© âŸ¨ 0 1 2 3 âŸ© âŸ¨ 0 1 2 3 4 âŸ© âŸ©

    â†“ â†•5
âŸ¨ âŸ¨ 0 1 2 3 4 âŸ© âŸ¨ 1 2 3 4 âŸ© âŸ¨ 2 3 4 âŸ© âŸ¨ 3 4 âŸ© âŸ¨ 4 âŸ© âŸ¨âŸ© âŸ©

--
Back to Under âŒ¾	
Right operand - some selection functions
    8âŒ¾âŠ‘ "BQN"        # Change the first element to 8
âŸ¨ 8 'Q' 'N' âŸ©
    â†•7
âŸ¨ 0 1 2 3 4 5 6 âŸ©

    4 â†‘ â†•7           # The first four elements
âŸ¨ 0 1 2 3 âŸ©

    âŒ½âŒ¾(4âŠ¸â†‘) â†•7       # And reverse them
âŸ¨ 3 2 1 0 4 5 6 âŸ©

    âŒ½âŒ¾(Â¯4âŠ¸â†‘) â†•7      # Or reverse the last four
âŸ¨ 0 1 2 6 5 4 3 âŸ©

# âŒ¾ seems to take either a data value (which it replaces) or an operation on the Left (i.e an operand)

# 2 2-trains below
    2âŠ¸âŒ½âŒ¾(1âŠ¸âŠ‘) "xyz"â€¿"ABCDE"â€¿"wxyz"â€¿"yz"
âŸ¨ "xyz" "CDEAB" "wxyz" "yz" âŸ©

    2âŠ¸âŒ½âŒ¾(2âŠ¸â†“) "XYabcde"
"XYcdeab"

# slice a list at point 2, length 2
    2 â†‘ 4 â†“ "abcdefgh"
"ef"

# convert that slice to Uppercase
# ('A'-'a')âŠ¸+ is a 2-trains
    ('A'-'a')âŠ¸+ âŒ¾ (2 â†‘ 4âŠ¸â†“)  "abcdefgh"
"abcdEFgh"
# "ef" - 32 = "EF"
--
What Under is actually doing
1.
FâŒ¾G y	Under: apply G, then F, then undo G
(1âŠ¸+) âŒ¾ (1âŠ¸-) â†•3
âŸ¨ Â¯1 0 1 âŸ©
# first apply (1âŠ¸-) â†•3
# 1 - âŸ¨ 0 1 2 âŸ©
âŸ¨ 1 0 -1 âŸ©
# then apply (1âŠ¸+) on this
âŸ¨ 2 1 0 âŸ©
# then Undo G on this
# (1âŠ¸-)â¼ âŸ¨ 2 1 0 âŸ©
âŸ¨ Â¯1 0 1 âŸ©
# for Undo, need to think of
ğ•© â‰¡ ğ”½ ğ”½â¼ ğ•©
# that is, the {..} block needs to give an ans which satisfy 
# the below eq
âŸ¨ 2 1 0 âŸ© â‰¡ (1âŠ¸-) {(1âŠ¸-)â¼ âŸ¨ 2 1 0 âŸ©} 
# so the ans is âŸ¨ Â¯1 0 1 âŸ©

2.
x FâŒ¾G y	Under: apply Fâ—‹G, then undo G # notice is F Over G
# that means, Gâ¼ [(G x) F (G y)]
e.g.
2 Ã—âŒ¾(1âŠ¸-) â†•3
âŸ¨ 2 1 0 âŸ©

Gâ†1âŠ¸-
Fâ†Ã—

(G 2) F (G â†•3) 
âŸ¨ Â¯1 0 1 âŸ©

Gâ¼ Â¯1â€¿0â€¿1
âŸ¨ 2 1 0 âŸ©


--
Difference btw Pick and Take

1âŠ‘"abced"
'b'  # pick an element based on index

1â†‘"abced"
"a"  # take part of the list (or array)

#âŒ¾ takes 2 operands 
#below, both operands are 2-trains
(1âŠ¸+) âŒ¾ (1âŠ¸âŠ‘) "abced"
"acced"
#if we use `take`, we need to replace with an equivalent rank list
"z"âŒ¾ (1âŠ¸â†‘) "bqn"

---
Logical operation

Not â† 1+-  # also Span
And â† Ã—
Or  â† Ã—âŒ¾Â¬

for Or, the definition is 
    A âˆ¨ B = Â¬(Â¬A âˆ§ Â¬B)
so for above,
    ğ•¨ Ã—âŒ¾Â¬ ğ•© =  Â¬â¼(Â¬ğ•¨ Ã— Â¬ğ•©)
# but Â¬â¼ â†â†’ Â¬, (an so is -â¼ â†â†’ -)
so,
    ğ•¨ Ã—âŒ¾Â¬ ğ•© =  Â¬(Â¬ğ•¨ Ã— Â¬ğ•©)
Another definition is
Or  â† +-Ã—

----
Namespace

#file.bqn
âŸ¨something, DoThingâŸ©â‡     # Declare exports
abbreviation â‡ "sth"      # Define and export
_something â† {ğ•—}          # Separate definition
DoThing â† "TODO"âŠ¸!

#some other file at same folder
ns â† â€¢Import "file.bqn"
âŸ¨something, abbrâ‡abbreviationâŸ© â† ns  # Destructure
ns.DoThing 6   


#exports
example â† {
  bâ€¿câ‡   # Non-definition exports can go anywhere
  aâ‡2    # Define and export
  bâ†1+a
  câ†bâ€¿"str"
}

#imports
âŸ¨aliasâ‡a, b, c0â€¿c1â‡c, b2â‡bâŸ© â† example

#another example of imports (without using â‡)
câ€¿a â† example

#using dot .
example.b

{nâ‡7}.n

--
Block

    aâ†bâ†"outer"
"outer"
    { aâ†"inner" â‹„ aâ€¿b } # block here, with local scoping & a separator, executed from L to R
âŸ¨ "inner" "outer" âŸ©
    a
"outer"
--
Lowercase	Uppercase	Meaning
ğ•©	        ğ•	        Right argument
ğ•¨	        ğ•	        Left argument, or Nothing (Â·)
ğ•¤	        ğ•Š	        Function self-reference
ğ•—	        ğ”½	        Left operand
ğ•˜	        ğ”¾	        Right operand
ğ•£	        none	    Modifier self-reference

ğ•©, ğ•¨ => right, left data argument
ğ•, ğ• => right, left function argument

    {'c'=ğ•©} "abcd"
âŸ¨ 0 0 1 0 âŸ©
    { ğ•©+â†©2 â‹„ 0â‰ğ•© } 3  # change of value for ğ•©
âŸ¨ 0 5 âŸ©
    4 { âŸ¨ğ•©â‹„-ğ•¨âŸ© } 5
âŸ¨ 5 Â¯4 âŸ©

--
    3 { (2Ã—ğ•¨)-ğ•© } 1
5
      { (2Ã—ğ•¨)-ğ•© } 1  # left argument is Â· Nothing  
Â¯1
--
    "abc" { (ğ•¨â‰âŒ½) ğ•© } "def"
â”Œâ”€     
â•µ"abc  
  fed" 
      â”˜
          { (ğ•¨â‰âŒ½) ğ•© } "def" # ğ•¨ behaves just like Â· Nothing
â”Œâ”€     
â•µ"fed" 
      â”˜

    { ğ•¨ â‹†âŠ¸- ğ•© } 5 # this behaves as { Â· â‹†âŠ¸- ğ•© } 5, which is â‹†âŠ¸- ğ•©
143.4131591025766

--
ğ•—	        ğ”½	        Left operand
ğ•˜	        ğ”¾	        Right operand

--
# doesnt really make sense to use data type as operands
# but it will just return itself
    4 {Ã—Ëœğ•—}
16
    2 {ğ•—+ğ•˜} 3
5

# if try to pass in a function with lowercase ğ•—, it will error out
    Ã— {Ã—Ëœğ•—}
Error: Ã—: Unexpected argument types
# Uppercase ğ”½ is ok
    Ã— {Ã—Ëœğ”½}
Ã—ËœÃ—
    _dot_ â† {ğ”½Â´âˆ˜ğ”¾}   #_dot_ is a 'deferred modifier', it's content is only evaluate when the modifier is called
    1â€¿2â€¿3 +_dot_Ã— 1â€¿0â€¿1
4

    +{ğ•©ğ”½ğ•©} 6
12
    2 â¥Š{âŸ¨ğ”½ğ•¨,ğ”¾ğ•©âŸ©}- 5
âŸ¨ âŸ¨ 2 âŸ© Â¯5 âŸ©

--
Self-reference
If a block is assigned a name after it is created, this name can be used for recursion:

# (0âŠ¸<)â—¶1â€¿Fact ğ•©-1, based on breakdown below is return Fact(ğ•© - 1) if ğ•© - 1 is > 0;
# else return 1 (this is the base case)
# Fact(ğ•© - 1) .. is essentially { (ğ•© - 1) Ã— Fact (ğ•© - 2) .. Ã— 1 }
    Fact â† { ğ•© Ã— (0âŠ¸<)â—¶1â€¿Fact ğ•©-1 } 
    Fact 7
5040
    (Ã—Â´1+â†•) 7  # There's often a simpler solution than recursion
5040

# we can use self reference ğ•Š to refer to the function it appears in
#this allows for anonymous recursive function
    { ğ•© Ã— (0âŠ¸<)â—¶1â€¿ğ•Š ğ•©-1 } 7
5040

--
Self-reference modifier ğ•£
Refers to the 'containing modifier', while ğ•Š refers to the 'entire' function it appears in
Only refers to 1-modifier or 2-modifier, so can only be written as _ğ•£ or _ğ•£_
    Fact_mod â† 1 { (0âŠ¸<)â—¶âŸ¨ğ•—, (ğ•—Ã—ğ•©)_ğ•£âŸ© ğ•©-1 }
    Fact_mod 7
5040



There must be a space in between the Left operand and _ğ•£
    Fact2 â† 1 { (0âŠ¸<)â—¶âŸ¨ğ•—, ğ•—Ã—ğ•© _ğ•£âŸ© ğ•©-1 }   # this is valid
1(1-modifier block)
    Fact2 7
5040



--
Block headers

Fact â† { F n:   # F is only defined inside {} while Fact can be used inside or outside
  n Ã— (0âŠ¸<)â—¶1â€¿F n-1
}

# A dyadic function that refers to itself as Func
{ l Func r:
  â€¦

# A deferred 1-modifier with a list argument
{ Fn _apply âŸ¨a,bâŸ©:
  â€¦

# A monadic function with no names given
{ ğ•Šğ•©:
  â€¦

# An immediate (??) or deferred 2-modifier
{ F _op_ val:
  â€¦

# for the example above; a header is the same as a series of assignments for a
# headless block
{ # Fn _apply âŸ¨a,bâŸ©:
  Fn â† ğ”½
  _apply â† _ğ•£    # this monadic 1-modifier cannot take a right operand ğ”¾ or left argument ğ•¨
  âŸ¨a,bâŸ© â† ğ•©
  â€¦

# header destructuring
    Destruct â† { ğ•Š aâ€¿1â€¿âŸ¨b,2âŸ©: aâ‰b }
    Destruct       5â€¿1â€¿âŸ¨7,2âŸ©
âŸ¨ 5 7 âŸ©

# nameless block is possible by incoorporating all the special names
# most vague header
ğ•¨ ğ”½_ğ•£_ğ”¾ ğ•©:

--
Short headers (without inputs specified) - AKA 'label'

{ b:   # Block
{ ğ•Š:   # Function
{ _ğ•£:  # 1-Modifier
{ _ğ•£_: # 2-Modifier

Label doesnt restrict inputs; but already specify the type of block

--
Multiple bodies; will execute depending on arguments provided
    Ambiv â† { âŸ¨1,ğ•©âŸ© ; âŸ¨2,ğ•¨,ğ•©âŸ© }
    Ambiv 'a'
âŸ¨ 1 'a' âŸ©
    'a' Ambiv 'b'
âŸ¨ 2 'a' 'b' âŸ©

    CaseAdd â† { 2ğ•Š3:0â€¿5 ; 2ğ•Šğ•©:âŸ¨1,2+ğ•©âŸ© ; ğ•Šğ•©:2â€¿ğ•© }
    2 CaseAdd 3
âŸ¨ 0 5 âŸ©
    2 CaseAdd 4
âŸ¨ 1 6 âŸ©
      CaseAdd 4
âŸ¨ 2 4 âŸ©

# Below, the function name ğ•Š  is ommited
Test â† {
  "abc": "string" ;
  âŸ¨2,bâŸ©: âŒ½ğ•©       ;
  5:     "number" ;
  ğ•©:     "default"
}

Test "abc"
"string"

Test âŸ¨2,5âŸ©
âŸ¨5 2âŸ©

---
Predicate ?(and also ;) (** need to be INSIDE a block)

    CheckPair â† { ğ•ŠâŸ¨a,bâŸ©: a<b? "ok" ; "not ok" }

    CheckPair âŸ¨3,8âŸ©    # Fails destructuring
"ok"
    CheckPair âŸ¨1,4,5âŸ©  # Not a pair
"not ok"
    CheckPair âŸ¨3,Â¯1âŸ©   # Not ascending
"not ok"

#it works similarily like a ternary statement
#doesnt necessary have to start with a header

    { râ†âŒ½ğ•© â‹„ 't'=âŠ‘r ? r ; ğ•© }Â¨ "test"â€¿"this"
âŸ¨ "tset" "this" âŸ©

{ a<b ? a ; b } is just computing aâŒŠb

?; can support any number of options

#the structure below is "if _ and _ then _; else if _ then _; else _".
    Thing â† { ğ•©â‰¥3? ğ•©â‰¤8? 2|ğ•© ; ğ•©=0? @ ; âˆ }

    (âŠ¢ â‰ ThingÂ¨) â†•10  # Table of arguments and results
â”Œâ”€                     
â•µ 0 1 2 3 4 5 6 7 8 9  
  @ âˆ âˆ 1 0 1 0 1 0 âˆ  
                      â”˜
#Same as this actually
#but due to precendece of ?, need to group (ğ•©â‰¥3)
#else, it would be ğ•© â‰¥ (3 âˆ§ ğ•©â‰¤8)
Thing â† { (ğ•©â‰¥3) âˆ§ ğ•©â‰¤8 ? 2|ğ•© ; ğ•©=0? @ ; âˆ }

# at its simplest
   {1=1?â€¢Show "yes"}
"yes"

# but if no `else` condition, it will throw if no matched `header`
   {1=0?â€¢Show "yes"}
Error: No header matched arguments
at {1=0?â€¢Show "yes"}


----
Valences
âŠ˜ \%

{ğ”½ğ•©;ğ•¨ğ”¾ğ•©}	2-Modifier, Apply ğ”½ if there's one argument but ğ”¾ if there are two
# Blocks that define functions and deferred modifiers can include more than one body, separated by semicolons ;

Usage:
    5Ã—âŠ˜-2
3
    Ã—âŠ˜-2
1

--
Choose
â—¶ \$

{fâ†(ğ•¨ğ”½ğ•©)âŠ‘ğ•˜ â‹„ ğ•¨Fğ•©} 2-modifier, Select one of the functions in list ğ•˜ based on ğ”½

Usage:

    Func â† (0âŠ¸<)â—¶1â€¿2
0âŠ¸<â—¶âŸ¨ 1 2 âŸ©
    Func 1
2
    Func 0
1
    Func Â¯2
1
#breakdown (based on the definition)
    ((0âŠ¸<)1)âŠ‘1â€¿2 # if ğ•© is 1 or larger, its more than 0, so 1âŠ‘1â€¿2 = 2
2
    ((0âŠ¸<)Â¯2)âŠ‘1â€¿2 # if ğ•© is lesser than 0, 0âŠ‘1â€¿2 = 1, LHS can only be 1 or 0 
1
    for next statement ğ•¨Fğ•©, due to ğ•¨ is nothing, basically just return const Fğ•©
    so return 1 if ğ•© is larger than 0; else return 2 

----
Fill element
basically 0 for numbers, ' ' for characters, âŸ¨âŸ© for array

    Â¯7 â†‘ 4â¥Š3     # Fill with 0
âŸ¨ 0 0 0 3 3 3 3 âŸ©

    Â¯7 â†‘ "qrst"  # Fill with space
"   qrst"

    Â»Â¨ âŸ¨4â¥Š3,"qrst"âŸ©   # nudge right
âŸ¨ âŸ¨ 0 3 3 3 âŸ© " qrs" âŸ©

    3â†‘âŸ¨âŸ©  # Fill unknown
âŸ¨ 0 0 0 âŸ©

    Â»âŸ¨âŸ©   # Fill not needed
âŸ¨âŸ©

# reshape fill when ğ•¨ contains â†‘ and the product of the rest of ğ•¨ doesn't evenly divide the number of elements in ğ•©
    â†‘â€¿8 â¥Š "completepart"
â”Œâ”€          
â•µ"complete  
  part    " 
           â”˜
    Â» "abc" + 4â€¿3â€¿2
" ee"

#to find out fill element
# deshape, take one, nudge right, pick first one
    âŠ‘Â»1â†‘â¥Š"string" 
' '

    6 â†‘ â†‘â†•3  # Two fills at the end
âŸ¨ âŸ¨âŸ© âŸ¨ 0 âŸ© âŸ¨ 0 1 âŸ© âŸ¨ 0 1 2 âŸ© âŸ¨âŸ© âŸ¨âŸ© âŸ©

    Â»Â¨ 3â€¿4â€¿1 /âŠ¸âŠ” "abc0123A"
âŸ¨ " ab" " 012" " " âŸ©

----
Leading axis refers to the initial axis

Rank (â‰) or Cells (Ë˜) modifier


# about ranks
= 9 # rank 0
= "abcd" # rank 1
= 3â€¿4â¥Š"abcd" # rank 2
= 3â€¿3â€¿4â¥Šâ†•36 # rank 3

#using the 3â€¿3â€¿4â¥Šâ†•36 example, 

Rank 3 - Rank 2 - Rank 1 - Rank 0
  3    â€¿   3    â€¿   4      ...
  

    a â† 3â€¿2â¥Š (+âŸœ'a')â†•6
â”Œâ”€    
â•µ"ab  
  cd  
  ef" 
     â”˜
    â‰¢â‰a  #added one axis in front of Rank 2, hence becomes rank 3
âŸ¨ 1 3 2 âŸ©
    =â‰a  #use this to confirm no of Rank
3

#added one axis in front Rank 1 (the Rank where it becomes 'Cells')
#Ë˜ operates on Major Cells, which is Rank - 1
    â‰Ë˜a  
â”Œâ”€    
â•"ab  
      
 Â·cd  
      
 Â·ef" 
     â”˜
    â‰¢â‰Ë˜a    # coupled an empty 'row' on top of each row
âŸ¨ 3 1 2 âŸ©
    (3â€¿2â¥Šâ†•6)â‰Ë˜a
â”Œâ”€         
â• 0   1    
  'a' 'b'  
           
  2   3    
  'c' 'd'  
           
  4   5    
  'e' 'f'  
          â”˜
    â‰¢(3â€¿2â¥Šâ†•6)â‰Ë˜a
âŸ¨ 3 2 2 âŸ©

# ğ”½Ë˜ is identical to ğ”½â‰1
    (3â€¿2â¥Šâ†•6)â‰â‰1 a
â”Œâ”€         
â• 0   1    
  'a' 'b'  
           
  2   3    
  'c' 'd'  
           
  4   5    
  'e' 'f'  
          â”˜

# below two are identical
    â‰¢(3â€¿2â¥Šâ†•6)â‰â‰2 a
âŸ¨ 2 3 2 âŸ©
    (3â€¿2â¥Šâ†•6)â‰â‰2 a
â”Œâ”€         
â• 0   1    
  2   3    
  4   5    
           
  'a' 'b'  
  'c' 'd'  
  'e' 'f'  
          â”˜
    (3â€¿2â¥Šâ†•6)â‰ a
â”Œâ”€         
â• 0   1    
  2   3    
  4   5    
           
  'a' 'b'  
  'c' 'd'  
  'e' 'f'  
          â”˜
# coupling beyong existing Ranks doesnt do anything fancy
    (3â€¿2â¥Šâ†•6)â‰â‰3 a  
â”Œâ”€         
â• 0   1    
  2   3    
  4   5    
           
  'a' 'b'  
  'c' 'd'  
  'e' 'f'  
          â”˜

    (3â€¿2â¥Šâ†•6)â‰â‰0 a  # create a new Rank 1 axis
â”Œâ”€       
â• 0 'a'  
  1 'b'  
         
  2 'c'  
  3 'd'  
         
  4 'e'  
  5 'f'  
        â”˜
    â‰¢(3â€¿2â¥Šâ†•6)â‰â‰0 a
âŸ¨ 3 2 2 âŸ©


#â‰Â¯1 seems same as â‰1
#if the right operand ğ•˜ of â‰ is negative, its interpreted as 0âŒˆRank+ğ•˜ 
#Therefore, a value of Â¯1 selects major cells.
    (3â€¿2â¥Šâ†•6)â‰â‰Â¯1 a
â”Œâ”€         
â• 0   1    
  'a' 'b'  
           
  2   3    
  'c' 'd'  
           
  4   5    
  'e' 'f'  
          â”˜
    â‰¢â‰â‰Â¯1 a
âŸ¨ 3 1 2 âŸ©

# but going beyond Â¯1 is same as â‰0
    â‰¢â‰â‰Â¯2 a
âŸ¨ 3 2 1 âŸ©
    â‰¢â‰â‰Â¯3 a
âŸ¨ 3 2 1 âŸ©
    â‰¢â‰â‰Â¯100 a
âŸ¨ 3 2 1 âŸ©

#what are major cells?
https://help.dyalog.com/18.0/Content/Language/Introduction/Variables/Cells%20and%20Subarrays.htm#CellsSubarrays

#all about Rank â‰ (its the same as APL â¤) 
https://help.dyalog.com/18.0/?skinName=Large#Language/Primitive%20Operators/Rank.htm
â‰ takes a ğ•˜ scalar or vector of up to 3 items

    s
"abracadabra"
    s âˆ¾â‰0â€¿1 "suffix"   # same as 1â€¿0â€¿1 "suffix"
â”Œâ”€         
â•µ"asuffix  
  bsuffix  
  rsuffix  
  asuffix  
  csuffix  
  asuffix  
  dsuffix  
  asuffix  
  bsuffix  
  rsuffix  
  asuffix" 
          â”˜
breakdown:
 â‰â‰0 s
â”Œâ”€   
â•µ"a  
  b  
  r  
  a  
  c  
  a  
  d  
  a  
  b  
  r  
  a" 
    â”˜    

  â‰â‰1 "suffix"
â”Œâ”€        
â•µ"suffix" 
         â”˜
# so take the Rank 0 of s and join with Rank 1 (major cell) of "suffix"

âŠ’ is occurence counter, returns the index of leading axis (or called first axis or major cells)
    s â† "abracadabra"
    âŠ’ s
âŸ¨ 0 0 0 1 0 2 0 3 1 1 4 âŸ©
    âŠ’ â‰Ë˜ s
âŸ¨ 0 0 0 1 0 2 0 3 1 1 4 âŸ©
    âŠ’ s âˆ¾â‰0â€¿1 "suffix"
âŸ¨ 0 0 0 1 0 2 0 3 1 1 4 âŸ©

    b â† 4â€¿5 â¥Š â†•4
â”Œâ”€           
â•µ 0 1 2 3 0  
  1 2 3 0 1  
  2 3 0 1 2  
  3 0 1 2 3  
            â”˜
    âˆ¨ b  # sort by cols
â”Œâ”€           
â•µ 3 0 1 2 3  
  2 3 0 1 2  
  1 2 3 0 1  
  0 1 2 3 0  
            â”˜

    âˆ¨Ë˜b  # sort by rows (major cells)
â”Œâ”€           
â•µ 3 2 1 0 0  
  3 2 1 1 0  
  3 2 2 1 0  
  3 3 2 1 0  

    2â€¿1 âŒ½ â†•3â€¿5 # rotate; shift once to left and twice upward
â”Œâ”€                                         
â•µ âŸ¨ 2 1 âŸ© âŸ¨ 2 2 âŸ© âŸ¨ 2 3 âŸ© âŸ¨ 2 4 âŸ© âŸ¨ 2 0 âŸ©  
  âŸ¨ 0 1 âŸ© âŸ¨ 0 2 âŸ© âŸ¨ 0 3 âŸ© âŸ¨ 0 4 âŸ© âŸ¨ 0 0 âŸ©  
  âŸ¨ 1 1 âŸ© âŸ¨ 1 2 âŸ© âŸ¨ 1 3 âŸ© âŸ¨ 1 4 âŸ© âŸ¨ 1 0 âŸ©  
                                          â”˜ 
    # see how values are matched to leading axes
    # drop below dropped from the larger ranks first
    â‰¢ 3â€¿2 â†“ 7â€¿7â€¿7â€¿7â¥Š"abc"
âŸ¨ 4 5 7 7 âŸ©

--
Use leading axis agreement to match arguments together
Axes of lower-rank argument are matched with leading axes of higher-rank one

    âŠ¢ x â† 3â€¿2â€¿4 â¥Š â†•60     # A rank-3 array
â”Œâ”€             
â•  0  1  2  3  
   4  5  6  7  
               
   8  9 10 11  
  12 13 14 15  
               
  16 17 18 19  
  20 21 22 23  
              â”˜
    100â€¿0â€¿200 + x         # 0-cells paired with 2-cells
â”Œâ”€                 
â• 100 101 102 103  
  104 105 106 107  
                   
    8   9  10  11  
   12  13  14  15  
                   
  216 217 218 219  
  220 221 222 223  
                  â”˜
    âŠ¢ c â† 100 Ã— 3 =âŒœâ—‹â†• 2  # A rank-2 array to add
#breakdown: (â†•3) =âŒœ (â†•2)
â”Œâ”€         
â•µ 100   0  
    0 100  
    0   0  
          â”˜
    c + x                 # 0-cells paired with 1-cells
â”Œâ”€                 
â• 100 101 102 103  
    4   5   6   7  
                   
    8   9  10  11  
  112 113 114 115  
                   
   16  17  18  19  
   20  21  22  23  
                  â”˜
    x + x                 # Pairwise addition
â”Œâ”€             
â•  0  2  4  6  
   8 10 12 14  
               
  16 18 20 22  
  24 26 28 30  
               
  32 34 36 38  
  40 42 44 46  
              â”˜
---
Depth
Depth of an array is the greatest level of array nesting it attains, or, put another way, the greatest number of times you can pick an element starting from the original array before reaching an atom

    â‰¡ 2â€¿3â€¿4
1
    â‰¡ "a string is a list of characters"
1

# doesnt care about shape
    â‰¡ 3â€¿4â¥Š"characters"
1
    â‰¡ (1+â†•10)â¥Š"characters"
1

# care about elements
    â‰¡ âŸ¨2,3,4,5âŸ©
1
    â‰¡ âŸ¨2,<3,4,5âŸ©
2
    â‰¡ âŸ¨2,<3,4,<<<5âŸ©
4
# atom has depth 0
    â‰¡'c'
0
    Fâ†+â‹„â‰¡f
0
    â‰¡âŸ¨'c',f,2âŸ©
1
    â‰¡âŸ¨5,âŸ¨'c',f,2âŸ©âŸ©
2
# an empty array's depth is 1
    â‰¡âŸ¨âŸ©
1
    â‰¡2â€¿0â€¿3â¥Š0
1

--
For Select, the left argument is a list and its elements correspond to the right
argument axes
    â†•6â€¿7
â”Œâ”€
â•µ âŸ¨ 0 0 âŸ© âŸ¨ 0 1 âŸ© âŸ¨ 0 2 âŸ© âŸ¨ 0 3 âŸ© âŸ¨ 0 4 âŸ© âŸ¨ 0 5 âŸ© âŸ¨ 0 6 âŸ©
  âŸ¨ 1 0 âŸ© âŸ¨ 1 1 âŸ© âŸ¨ 1 2 âŸ© âŸ¨ 1 3 âŸ© âŸ¨ 1 4 âŸ© âŸ¨ 1 5 âŸ© âŸ¨ 1 6 âŸ©
  âŸ¨ 2 0 âŸ© âŸ¨ 2 1 âŸ© âŸ¨ 2 2 âŸ© âŸ¨ 2 3 âŸ© âŸ¨ 2 4 âŸ© âŸ¨ 2 5 âŸ© âŸ¨ 2 6 âŸ©
  âŸ¨ 3 0 âŸ© âŸ¨ 3 1 âŸ© âŸ¨ 3 2 âŸ© âŸ¨ 3 3 âŸ© âŸ¨ 3 4 âŸ© âŸ¨ 3 5 âŸ© âŸ¨ 3 6 âŸ©
  âŸ¨ 4 0 âŸ© âŸ¨ 4 1 âŸ© âŸ¨ 4 2 âŸ© âŸ¨ 4 3 âŸ© âŸ¨ 4 4 âŸ© âŸ¨ 4 5 âŸ© âŸ¨ 4 6 âŸ©
  âŸ¨ 5 0 âŸ© âŸ¨ 5 1 âŸ© âŸ¨ 5 2 âŸ© âŸ¨ 5 3 âŸ© âŸ¨ 5 4 âŸ© âŸ¨ 5 5 âŸ© âŸ¨ 5 6 âŸ©
                                                            â”˜

    âŸ¨3â€¿2,1â€¿4â€¿1âŸ© âŠ â†•6â€¿7 # 3â€¿2 correspond to first axis, which it flips; 1â€¿4â€¿1 to 2nd axis, i.e.columns
â”Œâ”€                         
â•µ âŸ¨ 3 1 âŸ© âŸ¨ 3 4 âŸ© âŸ¨ 3 1 âŸ©  
  âŸ¨ 2 1 âŸ© âŸ¨ 2 4 âŸ© âŸ¨ 2 1 âŸ©  
                          â”˜
# how do you get depth 1 in left argument?
# use atom

    âŸ¨3â€¿2,1âŸ© <âŸ(0=â‰¡)Â¨âŠ¸âŠ â†•6â€¿7  # get 3â€¿2 of column-1 
âŸ¨ âŸ¨ 3 1 âŸ© âŸ¨ 2 1 âŸ© âŸ©
# breakdown
    sâ†<âŸ(0=â‰¡)Â¨ âŸ¨3â€¿2,1âŸ©
â”Œâ”€               
Â· âŸ¨ 3 2 âŸ© â”ŒÂ·     
          Â· 1    
              â”˜  
                â”˜
    s âŠ â†•6â€¿7
âŸ¨ âŸ¨ 3 1 âŸ© âŸ¨ 2 1 âŸ© âŸ©

# but Replicate / doesnt have this problem, becoz depth 1 acts on first axis
# only
    3â€¿2â€¿1â€¿2â€¿3 / "abcde"
"aaabbcddeee"

---
Replicate /
# if single number, applies pervasively
    3 / "copy"
"cccooopppyyy"

# boolean value 0 or 1 to switch on and off
    1â€¿1â€¿0â€¿0â€¿1â€¿0 / "filter"
"fie"

    â‰¤âŸœ'i' "filter"  # breakdown: "filter" â‰¤ 'i'
âŸ¨ 1 1 0 0 1 0 âŸ©

    â‰¤âŸœ'i'âŠ¸/ "filter" 
"fie"

# breakdown:
    (â‰¤âŸœ'i')âŠ¸/ "filter"
    ((â‰¤âŸœ'i') "filter") / "filter"
    ("filter" â‰¤ 'i') / "filter"

    {1+'"'=ğ•©}âŠ¸/ "for ""escaping"" quotes"  # the "" inside the quotes is actually one quote, so here there are 2 quotes
"for """"escaping"""" quotes" # here there are 4 quotes

    âŠ¢ b â† 2â€¿5 â¥Š â†•10
â”Œâ”€           
â•µ 0 1 2 3 4  
  5 6 7 8 9  
            â”˜
# ğ•¨ has depth of 2, gives the amount to copy along each leading axis of ğ•©
    âŸ¨2â€¿0, 1â€¿0â€¿0â€¿1â€¿1âŸ© / b
â”Œâ”€       
â•µ 0 3 4  
  0 3 4  
        â”˜

    2â€¿0 / 1â€¿0â€¿0â€¿1â€¿1âŠ¸/Ë˜ b  # here âŠ¸ is 'pack', its packing 1â€¿0â€¿0â€¿1â€¿1 to be used on the major cells
â”Œâ”€       
â•µ 0 3 4  
  0 3 4  
        â”˜
#breakdown
        1â€¿0â€¿0â€¿1â€¿1 /Ë˜ b
Error: Ë˜: Argument lengths don't agree
at  1â€¿0â€¿0â€¿1â€¿1 /Ë˜ b
^^
        1â€¿0â€¿0â€¿1â€¿1 âŠ¸/Ë˜ b
â”Œâ”€       
â•µ 0 3 4  
  5 8 9  
        â”˜
# if want to duplicate (using unit number) along each axis
    âŸ¨<2,<3âŸ© / b
â”Œâ”€                               
â•µ 0 0 0 1 1 1 2 2 2 3 3 3 4 4 4  
  0 0 0 1 1 1 2 2 2 3 3 3 4 4 4  
  5 5 5 6 6 6 7 7 7 8 8 8 9 9 9  
  5 5 5 6 6 6 7 7 7 8 8 8 9 9 9  
                                â”˜
# careful not to do this, coz this is equivalent to 2â€¿3 / b (which applies to
# first axis only) 
    âŸ¨2,3âŸ© / b
â”Œâ”€           
â•µ 0 1 2 3 4  
  0 1 2 3 4  
  5 6 7 8 9  
  5 6 7 8 9  
  5 6 7 8 9  
            â”˜
# simple case
    b â‰¡ âŸ¨âŸ© / b
1

---
Indices - Monadic /
ğ•© must be integer and have at least rank 1 (atom not allowed)

    / 3â€¿0â€¿1â€¿2
âŸ¨ 0 0 0 2 3 3 âŸ©

# /ğ•© is the list ğ•©/â†•â‰ ğ•©

    2â€¿5â€¿0â€¿1 /âŠ¸âŠ” "ABCDEFGH"
âŸ¨ "AB" "CDEFG" âŸ¨âŸ© "H" âŸ©
#breakdown:
    (/2â€¿5â€¿0â€¿1) âŠ” "ABCDEFGH"
âŸ¨ 0 0 1 1 1 1 1 3 âŸ© # notice index 2 is missing

the modification (/âˆ¾âŸœ1)âŠ¸âŠ” ensures the result always has as many elements as ğ•¨.

    /(âˆ¾âŸœ1) 2â€¿5â€¿0â€¿1
âŸ¨ 0 0 1 1 1 1 1 3 4 âŸ©
#breakdown:
    /(2â€¿5â€¿0â€¿1 âˆ¾ 1)  # add one more element to the index vector

# can get indices where 1 appears
    / 0â€¿1â€¿0â€¿1â€¿0â€¿0â€¿0â€¿0â€¿1â€¿0
âŸ¨ 1 3 8 âŸ©
# can get the distance from each 1
    -âŸœÂ» / 0â€¿1â€¿0â€¿1â€¿0â€¿0â€¿0â€¿0â€¿1â€¿0
âŸ¨ 1 2 5 âŸ©
# breakdown:
âŸ¨ 1 3 8 âŸ© -Â» âŸ¨ 1 3 8 âŸ©


---
Group \u

    0â€¿1â€¿2â€¿0â€¿1 â‰ "abcde"  # Corresponding indices and values
â”Œâ”€                     
â•µ 0   1   2   0   1    
  'a' 'b' 'c' 'd' 'e'  
                      â”˜
    0â€¿1â€¿2â€¿0â€¿1 âŠ” "abcde"  # Values grouped by index (so the indices are 0,1,2, so there are 3 values in the list)
âŸ¨ "ad" "be" "c" âŸ©

# Â¯1 to drop value
    0â€¿Â¯1â€¿2â€¿2â€¿Â¯1 âŠ” "abcde"  # Drop c and e
âŸ¨ "a" âŸ¨âŸ© "cd" âŸ©
# extra element to indicate result minimum length
    0â€¿1â€¿2â€¿2â€¿1â€¿6 âŠ” "abcde"  # Length-6 result
âŸ¨ "a" "be" "cd" âŸ¨âŸ© âŸ¨âŸ© âŸ¨âŸ© âŸ©

# try to group a list of words by length
    phrase â† "BQN"â€¿"uses"â€¿"notation"â€¿"as"â€¿"a"â€¿"tool"â€¿"of"â€¿"thought"
    â‰Ë˜ â‰ Â¨âŠ¸âŠ” phrase  # breakdown: â‰Ë˜ ((â‰ Â¨) phrase) âŠ” phrase
â”Œâ”€                   
â•µ âŸ¨âŸ©                 
  âŸ¨ "a" âŸ©            
  âŸ¨ "as" "of" âŸ©      
  âŸ¨ "BQN" âŸ©          
  âŸ¨ "uses" "tool" âŸ©  
  âŸ¨âŸ©                 
  âŸ¨âŸ©                 
  âŸ¨ "thought" âŸ©      
  âŸ¨ "notation" âŸ©     
                    â”˜

# get diagonals of a table

    âŠ¢ a â† 'a'+â¥ŠâŸœ(â†•Ã—Â´)3â€¿5
â”Œâ”€       
â•µ"abcde  
  fghij  
  klmno" 
        â”˜
    (+âŒœÂ´Â·â†•Â¨â‰¢)âŠ¸âŠ” a
âŸ¨ "a" "bf" "cgk" "dhl" "eim" "jn" "o" âŸ© 

# breakdown: ((+âŒœÂ´Â·â†•Â¨â‰¢) a) âŠ” a
# 2-Train
    (+âŒœÂ´Â·â†•Â¨â‰¢) a
â”Œâ”€                                                                                             
â•µ 0 1 2 3 4                                                                                    
  1 2 3 4 5                                                                                    
  2 3 4 5 6                                                                                    
             â”˜
    â†•Â¨â‰¢ a 
âŸ¨ âŸ¨ 0 1 2 âŸ© âŸ¨ 0 1 2 3 4 âŸ© âŸ©

# the usage of fold, just to fold the list once is smart
    +âŒœÂ´âŸ¨âŸ¨0,1,2âŸ©,âŸ¨0,1,2,3,4âŸ©âŸ©
    âŸ¨0,1,2âŸ© +âŒœ âŸ¨0,1,2,3,4âŸ©

# the Â· is Nothing, it does nothing as a Left ğ•¨ to â†•, but its needed to separate
# the Range and the Fold function; else the whole thing gets recognized as a
# Fork

    (+âŒœÂ´â†•Â¨â‰¢) a
Error: Â´: Argument must be a list (3â€¿5 â‰¡ â‰¢ğ•©)
at (+âŒœÂ´â†•Â¨â‰¢) a
   ^^^^^^^^
3-Train: (+âŒœÂ´)â†•Â¨(â‰¢), the error shows that the Fold is applied straight to `a`

# in order words, becoz 3-Train is defined as such
# (f g h) âµ -> (f âµ) g (h âµ)
# its not possible for Â·â†•Â¨ to be the middle `g` function anymore since its _does
# not_ accept a left argument (Nothing)

--
Using Group for partitioning

# easy splitting
    ' '(+`âˆ˜=âŠ”âŠ¢)"BQN uses notation as a tool of thought"
âŸ¨ "BQN" " uses" " notation" " as" " a" " tool" " of" " thought" âŸ©
# breakdown ' '(+`âˆ˜=)".." âŠ” (' 'âŠ¢"..")
# use of scan for running numbers to group
   ' '+`âˆ˜="BQN uses notation as a tool of thought"
âŸ¨ 0 0 0 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 4 4 5 5 5 5 5 6 6 6 7 7 7 7 7 7 7 7 âŸ©
# but, the 'front spacing' is included

# we could remove the 'front spacing' by making it Â¯1
    ' '((âŠ¢-ËœÂ¬Ã—+`)âˆ˜=âŠ”âŠ¢)"BQN uses notation as a tool of thought"
âŸ¨ "BQN" "uses" "notation" "as" "a" "tool" "of" "thought" âŸ©
# breakdown of (âŠ¢-ËœÂ¬Ã—+`) 
# take note this is 3 trains of 3 train
# (f g (f1 g1 h))
   a â† (' '="BQN uses notation as a tool of thought")
âŸ¨ 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 âŸ©
   b â† (Â¬ a) Ã— (+`) a
âŸ¨ 0 0 0 0 1 1 1 1 0 2 2 2 2 2 2 2 2 0 3 3 0 4 0 5 5 5 5 0 6 6 0 7 7 7 7 7 7 7 âŸ©
   a -Ëœ b
âŸ¨ 0 0 0 Â¯1 1 1 1 1 Â¯1 2 2 2 2 2 2 2 2 Â¯1 3 3 Â¯1 4 Â¯1 5 5 5 5 Â¯1 6 6 Â¯1 7 7 7 7 7 7 7 âŸ©

--
To get rid of (one chunk of space) - more than 1 char - of delimiter

# if use this same method, will have âŸ¨âŸ© empty partitions
' '((âŠ¢-ËœÂ¬Ã—+`)âˆ˜=âŠ”âŠ¢)"  string with  spaces   "
    âŸ¨ âŸ¨âŸ© âŸ¨âŸ© "string" "with" âŸ¨âŸ© "spaces" âŸ©

# we want only the FIRST leading space of each spacings - to create a group
# the first leading space can be 0, for the 0th group
# we shift and compare
    (âŠ¢â‰1âŠ¸Â»<âŠ¢) ' '="  string with  spaces   "  # All, then filtered, spaces
â”Œâ”€                                                 
â•µ 1 1 0 0 0 0 0 0 1 0 0 0 0 1 1 0 0 0 0 0 0 1 1 1   
  0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0     # this is what we want
                                                  â”˜
    â‰âŸœ(âŠ¢-ËœÂ¬Ã—Â·+`1âŠ¸Â»<âŠ¢)' '="  string with  spaces   "  # More processing
â”Œâ”€                                                         
â•µ  1  1 0 0 0 0 0 0  1 0 0 0 0  1  1 0 0 0 0 0 0  1  1  1  
  Â¯1 Â¯1 0 0 0 0 0 0 Â¯1 1 1 1 1 Â¯1 Â¯1 2 2 2 2 2 2 Â¯1 Â¯1 Â¯1  
                                                          â”˜
    ' '((âŠ¢-ËœÂ¬Ã—Â·+`1âŠ¸Â»<âŠ¢)âˆ˜=âŠ”âŠ¢)"  string with  spaces   "  # Final result
âŸ¨ "string" "with" "spaces" âŸ©

    ' '((Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âˆ˜â‰ âŠ”âŠ¢)"  string with  spaces   "  # Slightly shorter
âŸ¨ "string" "with" "spaces" âŸ©

# breakdown
(âŠ¢-ËœÂ¬Ã—Â·+`1âŠ¸Â»<âŠ¢) a
(âŠ¢-Ëœ(Â¬Ã—(+`(1âŠ¸Â»<âŠ¢)))) a  # the nothing, separates the plus scan + shift function as one chunk

so
a-Ëœ(Â¬a)Ã—(+`(1âŠ¸Â»<âŠ¢))a

# infact
   Â·+`(1Â»a)<a
âŸ¨ 0 0 0 0 0 0 0 0 1 1 1 1 1 2 2 2 2 2 2 2 2 3 3 3 âŸ©

# we can enhance the function to use `membership of` to search for any "string"
# like so, we can delimit for any arbitary string
   " -> "((âŠ¢-ËœÂ¬Ã—Â·+`1âŠ¸Â»<âŠ¢)âˆ˜âˆŠËœâŠ”âŠ¢) "CH -> B -> CD"
âŸ¨ "CH" "B" "CD" âŸ©
   " -> "((Â¬-ËœâŠ¢Ã—Â·+`Â»âŠ¸>)âˆ˜(Â¬âˆŠËœ)âŠ”âŠ¢) "CH -> B -> CD"
âŸ¨ "CH" "B" "CD" âŸ©


--
A combinator (or nothing or separator) has higher precendence, it binds more tightly

Using back the above e.g

(+âŒœÂ´âˆ˜â†•Â¨â‰¢) a
â”Œâ”€              
Â· â”ŒÂ·    â”ŒÂ·      
  Â· 3   Â· 10    
      â”˜      â”˜  
               â”˜
#breakdown , âˆ˜ actually 'binds' â†• as its ğ”¾, (+âŒœÂ´âˆ˜â†•)Â¨â‰¢ a


# back to `phrase`, if we want to group based on 0-index and also get rid of
# word more than 5 letters (i.e, get from length-1 to length-5)

    1 -Ëœ â‰¤âŸœ5âŠ¸Ã— â‰ Â¨ phrase
âŸ¨ 2 3 Â¯1 1 0 3 1 Â¯1 âŸ©
    â‰Ë˜ {1-Ëœâ‰¤âŸœ5âŠ¸Ã—â‰ Â¨ğ•©}âŠ¸âŠ” phrase
â”Œâ”€                   
â•µ âŸ¨ "a" âŸ©            
  âŸ¨ "as" "of" âŸ©      
  âŸ¨ "BQN" âŸ©          
  âŸ¨ "uses" "tool" âŸ©  
                    â”˜

#breakdown: 1 -Ëœ (â‰¤âŸœ5)âŠ¸Ã— â‰ Â¨ phrase
    np â† â‰ Â¨ phrase
âŸ¨ 3 4 8 2 1 4 2 7 âŸ© # want: get rid of 8,7 (turn to Â¯1) , and then reduce the rest by 1
    1 -Ëœ (â‰¤âŸœ5)âŠ¸Ã— np
    1 -Ëœ ((â‰¤âŸœ5)np) Ã— np
    1 -ËœâŸ¨ 1,1,0,1,1,1,1,0 âŸ©Ã—np
âŸ¨ 2 3 Â¯1 1 0 3 1 Â¯1 âŸ©

# since we want length 1 to length 5, once way to guarantee there are 5 groups
# is to add a minimum `5` length as the extra element
    â‰Ë˜ {5âˆ¾Ëœ1-Ëœâ‰¤âŸœ5âŠ¸Ã—â‰ Â¨ğ•©}âŠ¸âŠ” phrase
â”Œâ”€                   
â•µ âŸ¨ "a" âŸ©            
  âŸ¨ "as" "of" âŸ©      
  âŸ¨ "BQN" âŸ©          
  âŸ¨ "uses" "tool" âŸ©  
  âŸ¨âŸ©                 
                    â”˜

# when group is called monadically

    â‰Ë˜ âŠ” 2â€¿3â€¿Â¯1â€¿2
â”Œâ”€         
â•µ âŸ¨âŸ©       
  âŸ¨âŸ©       
  âŸ¨ 0 3 âŸ©  
  âŸ¨ 1 âŸ©    
          â”˜
#basically, right argument operates on its own indices as values (similar as replicate)
    2â€¿3â€¿Â¯1â€¿2 âŠ” â†•4
âŸ¨ âŸ¨âŸ© âŸ¨âŸ© âŸ¨ 0 3 âŸ© âŸ¨ 1 âŸ© âŸ© 

---
Multidimensional Grouping
# âŸ¨first axis, second axisâŸ©
    âŸ¨0â€¿0â€¿1â€¿1,0â€¿1â€¿0â€¿1â€¿0â€¿1â€¿0âŸ© âŠ” (10Ã—â†•4)+âŒœâ†•7
â”Œâ”€                              
â•µ â”Œâ”€              â”Œâ”€            
  â•µ  0  2  4  6   â•µ  1  3  5    
    10 12 14 16     11 13 15    
                â”˜            â”˜  
  â”Œâ”€              â”Œâ”€            
  â•µ 20 22 24 26   â•µ 21 23 25    
    30 32 34 36     31 33 35    
                â”˜            â”˜  
                               â”˜
--
    â‰ Â¨âŠ” 2â€¿3â€¿1â€¿2
âŸ¨ 0 1 2 1 âŸ©

/â¼ inverse Indices called on the index argument gives the length of each group:    
    /â¼âˆ§ 2â€¿3â€¿1â€¿2
âŸ¨ 0 1 2 1 âŸ©

Calling Indices on the result lengths of Group sorts all the indices passed to Group (removing any Â¯1s). This is a kind of counting sort.
    /â‰ Â¨âŠ” 2â€¿3â€¿1â€¿Â¯1â€¿2
âŸ¨ 1 2 2 3 âŸ©

#breakdown
    âŠ” 2â€¿3â€¿1â€¿Â¯1â€¿2  # monadic group, values -to-> group of indices
âŸ¨ âŸ¨âŸ© âŸ¨ 2 âŸ© âŸ¨ 0 4 âŸ© âŸ¨ 1 âŸ© âŸ© # value 0 has none, value 1 is at index 2, value 2 is at index 0,4..
    â‰ Â¨ âŠ” 2â€¿3â€¿1â€¿Â¯1â€¿2
âŸ¨ 0 1 2 1 âŸ© # size of these indices
    /0â€¿1â€¿2â€¿1 # ignoring 0, value 1 has 1, value 2 has 2,2, value 3 has 3 <-- this is a counting sort (its a sort, coz it can only count up)
âŸ¨ 1 2 2 3 âŸ©

# sorting by group - see the left argument as a list with indices to sort
# remove the extra layer of array with Join
    âˆ¾ 2â€¿3â€¿1â€¿Â¯1â€¿2 âŠ” "abcde"
"caeb"
# equivalent to the more difficult (but comprehensive?) sorting..
    2â€¿3â€¿1â€¿Â¯1â€¿2 {Fâ†(0â‰¤ğ•¨)âŠ¸/ â‹„ ğ•¨â‹âŠ¸âŠâ—‹Fğ•©} "abcde"
"caeb"

# breakdown
              F         G
 2â€¿3â€¿1â€¿Â¯1â€¿2 (â‹âŠ¸âŠ)â—‹((0â‰¤2â€¿3â€¿1â€¿Â¯1â€¿2)âŠ¸/) "abcde"

Over: (G W) F (G X)

G X => ((0â‰¤2â€¿3â€¿1â€¿Â¯1â€¿2)âŠ¸/)"abcde"
G W => ((0â‰¤2â€¿3â€¿1â€¿Â¯1â€¿2)âŠ¸/)2â€¿3â€¿1â€¿Â¯1â€¿2

    2â€¿3â€¿1â€¿2 (â‹âŠ¸âŠ) "abce"
"caeb"
#breakdown2
# the indices order required to sort "abce"
    â‹ 2â€¿3â€¿1â€¿2
âŸ¨ 2 0 3 1 âŸ©
# use the indices order to sort  "abce"
    2â€¿0â€¿3â€¿1 âŠ "abce"
"caeb"

# in APL, we do for e.g. 4 3 6 7[â‹4 3 6 7], using the [..]
# but in BQN, we use pick  âŠ
    â‹âŠ¸âŠ 4â€¿3â€¿6â€¿7 # first grade, then pick based on the sorted indices
âŸ¨ 3 4 6 7 âŸ©
---
    âŠ¢ l â† "planet"â€¿"moon"â€¿"star"â€¿"asteroid"
âŸ¨ "planet" "moon" "star" "asteroid" âŸ©

    âˆ§ l
âŸ¨ "asteroid" "moon" "planet" "star" âŸ©

    â‹ l    # order needed to pick the list to sort it
âŸ¨ 3 1 0 2 âŸ©
    â‹â‹l    # applying it twice, `inverse` the index order
âŸ¨ 2 1 3 0 âŸ©
â”Œâ”€                                   
â•µ "planet" "moon" "star" "asteroid"  
  2        1      3      0           
                                    â”˜
# what the above says is: for each major cell of that argument, what rank it has
# relative to the others - the "ordinals" idiom

ordinal - relating to the order of something in a series.

    (â‹l) âŠ l
âŸ¨ "asteroid" "moon" "planet" "star" âŸ©

while â‹l transforms l to âˆ§l, the inverse of â‹l transforms âˆ§l back into l. 
That's what we want: for each cell of l, the corresponding number in the inverse of â‹l is what index that cell has after sorting.

   (â‹â‹l) âŠ âŸ¨ "asteroid","moon","planet","star" âŸ©
âŸ¨ "planet" "moon" "star" "asteroid" âŸ©

Or
    ğ•© â‰¡ qâŠpâŠğ•©

   âŸ¨ 2,1,3,0 âŸ© âŠ âŸ¨ 3,1,0,2 âŸ© âŠ âŸ¨ "planet","moon","star","asteroid" âŸ©
âŸ¨ "planet" "moon" "star" "asteroid" âŸ©

The fact that Grade Up inverts a permutation is useful in itself. Note that this applies to Grade Up specifically, and not Grade Down.
This is because the 'identity permutation' is ordered in ascending order. 
i.e.
 (â‹â¼) is actually â‹
'identify permutation' is âˆ§â‹l also â†•â‰ l

Grade Down would actually invert the reverse of a permutation, 
which is unlikely to be useful. So the ordinals idiom that goes in the opposite direction is actually not â’â’ but â‹â’.

---
BQN specifies that matching cells are "always ordered by their indices".

One effect is that â‹ğ•© is not always the same as âŒ½â’ğ•©, even though âˆ§ğ•© always matches âŒ½âˆ¨ğ•©.

    âŠ¢ t â† >âŸ¨ "dog"â€¿4, "ant"â€¿6, "pigeon"â€¿2, "pig"â€¿4 âŸ©
â”Œâ”€            
â•µ "dog"    4  
  "ant"    6  
  "pigeon" 2  
  "pig"    4  
             â”˜

    1 âŠË˜ t
âŸ¨ 4 6 2 4 âŸ©

    (1âŠË˜t) â‹âŠ¸âŠ t   # see "dog" and "pig" is based on the array index
â”Œâ”€            
â•µ "pigeon" 2  
  "dog"    4  
  "pig"    4  
  "ant"    6  
             â”˜

# But
    (1âŠË˜t) â’âŠ¸âŠ t
â”Œâ”€            
â•µ "ant"    6  
  "dog"    4   # same arrangement of dog and pig
  "pig"    4  
  "pigeon" 2  
             â”˜

    (1âŠË˜t)
âŸ¨ 4 6 2 4 âŸ©
    â‹ (1âŠË˜t)   
âŸ¨ 2 0 3 1 âŸ©
    â’ (1âŠË˜t)  # can see the 0 and 3 indices order are maintained
âŸ¨ 1 0 3 2 âŸ©

-- FFT (Food For Thought)
    (âŒ½â’/3â€¿4â€¿5) âŠ "012abcdABCDE"
"210dcbaEDCBA"

    aâ†3â€¿4â€¿5
âŸ¨ 3 4 5 âŸ©
    /a
âŸ¨ 0 0 0 1 1 1 1 2 2 2 2 2 âŸ©
    â’/a   # see the ordering of indices for 'matching cells' are maintained
âŸ¨ 7 8 9 10 11 3 4 5 6 0 1 2 âŸ©
    âŒ½â’/a
âŸ¨ 2 1 0 6 5 4 3 11 10 9 8 7 âŸ©

--
Bin

finding "what bin" (in ğ•¨)something (from ğ•©) fits into.

    hs â† 1e7Ã—627â€¿581â€¿578â€¿553â€¿520  # High scores

    hs â’ 1e7Ã—565â€¿322â€¿788â€¿627
âŸ¨ 3 5 0 1 âŸ©   # 565 is lesser than 578 but more then 553, can slot in 3rd rank
# 322 falls outside the bin lists, 788 at Rank 0, 627 tie with 1st rank
---
Repeat \# 2-modifier

    Â»Â»Â» "ABCDE"
"   AB"

    Â»âŸ3 "ABCDE"
"   AB

# symbol similar to math concept of exponential
nâ‹†4  â†â†’  nÃ—nÃ—nÃ—n
FâŸ4  â†â†’  Fâˆ˜Fâˆ˜Fâˆ˜F

Since FâŸ1 applies F and FâŸ0 doesn't, Repeat might be pronounced "if" or "conditional" when ğ”¾ is boolean.

    2 Ã—âŸ0 2
2
    2 Ã—âŸ1 2
4

# ğ•¨ ğ”½âŸn ğ•© is always equivalent to ğ•¨âŠ¸ğ”½âŸn ğ•©, provided n is a constant;not a function
    3 +âŸ2 7
13
    3 + 3 + 7
13

#Count can be dynamic with ğ”¾ as a function
in that case, actual count is ğ•¨ğ”¾ğ•©

remember the labels: ğ•¨ ğ”½_ğ•£_ğ”¾ ğ•©

5+âŸÃ— 2  # here w is 5, x is 2 , so (5+) (5+) ..10times.. (5+) 2
52
5+âŸÃ— 1  # here w is 5, x is 1, so (5+) ..5times.. (5+) 1
26

Before/after binds stronger and creates trains

# below w is simply nothing Â·
    âˆ¾âŸœ1âŸâŠ¢ 4
âŸ¨ 4 1 1 1 1 âŸ©
breakdown: (âˆ¾âŸœ1) (âˆ¾âŸœ1) (âˆ¾âŸœ1) (âˆ¾âŸœ1) 4

    1âŠ¸+âŸâ‰  â†•4
âŸ¨ 4 5 6 7 âŸ©
breakdown: (1âŠ¸+) (1âŠ¸+) (1âŠ¸+) (1âŠ¸+) â†•4

# some usecase for dynamic boolean
# halve the number if greater than 6
    Ã·âŸœ2âŸ{6<ğ•©}Â¨ 3â€¿7â€¿2â€¿1â€¿8   # notice the Each Â¨ 
âŸ¨ 3 3.5 2 1 4 âŸ©
# which is equivalent to
    (Ã·âŸœ2âŸ{6<ğ•©})Â¨ 3â€¿7â€¿2â€¿1â€¿8
âŸ¨ 3 3.5 2 1 4 âŸ©

    3 âŠ£âŸ<Â¨ 2â€¿4â€¿6  # Left if less, i.e. minimum
âŸ¨ 2 3 3 âŸ©
    3âŒŠ2â€¿4â€¿6  # easier
âŸ¨ 2 3 3 âŸ©
---
Some experiments
How to rotate 2D array 90 Degs to the right?

    a
â”Œâ”€       
â•µ 1 2 3  
  4 5 6  
  7 8 9  
        â”˜
    â‰a
â”Œâ”€       
â•µ 1 4 7  
  2 5 8  
  3 6 9  
        â”˜
    âŒ½Ë˜â‰a  # reverse it along the first axis
â”Œâ”€       
â•µ 7 4 1  
  8 5 2  
  9 6 3  
        â”˜
# works ok for larger square 2D array
    aâ†4â€¿4â¥Š1+â†•16
â”Œâ”€             
â•µ  1  2  3  4  
   5  6  7  8  
   9 10 11 12  
  13 14 15 16  
              â”˜
    âŒ½Ë˜â‰a   # rotate 90 deg clockwise
â”Œâ”€           
â•µ 13  9 5 1  
  14 10 6 2  
  15 11 7 3  
  16 12 8 4  
            â”˜
# same with this
    â‰âˆ˜âŒ½a
â”Œâ”€           
â•µ 13  9 5 1  
  14 10 6 2  
  15 11 7 3  
  16 12 8 4  
            â”˜
# rotate it 90 deg counter clockwise
    âŒ½âˆ˜â‰a
â”Œâ”€           
â•µ 4 8 12 16  
  3 7 11 15  
  2 6 10 14  
  1 5  9 13  
            â”˜
# rotate 180 deg
    âŒ½âŒ¾â¥Ša
â”Œâ”€             
â•µ 16 15 14 13  
  12 11 10  9  
   8  7  6  5  
   4  3  2  1  
              â”˜

---
Search functions

Name	                 (Search)for	in	Return
âŠ	Index of	                ğ•©	    ğ•¨	Index of first match
âŠ’	Progressive Index of	    ğ•©	    ğ•¨	Index of first unused match
âˆŠ	Member of	                ğ•¨	    ğ•©	1 if found, 0 if not
â‹â’	Bins	                    ğ•©	    ğ•¨	Predecessor index

--
âˆŠ	Member of

		"green"â€¿"bricks"â€¿"cow"â€¿"blue" âˆŠ "red"â€¿"green"â€¿"blue"
âŸ¨ 1 0 0 1 âŸ©   # result length will match length of ğ•¨

# useful in finding intersection and difference
    "initial set" (âˆŠ/âŠ£) "intersect"     # Keep ğ•©
"initiset"

    "initial set" (Â¬âˆ˜âˆŠ/âŠ£) "difference"  # Remove ğ•©
"tal st"

â· Find

    "xx" â· "xxbdxxxcx"
âŸ¨ 1 0 0 0 1 1 0 0 âŸ©
# equivalent to
    "xx"âŠ¸â‰¡Ë˜ 2 â†• "xxbdxxxcx"
âŸ¨ 1 0 0 0 1 1 0 0 âŸ©

# interesting to note that, by "flattening" into a list
   (<"->")â‰¡Â¨<Ë˜2â†•"CH -> B"
âŸ¨ 0 0 0 1 0 0 âŸ©
âŸ¨ 3 âŸ©
# this unit array '<' comparison is not the same as 'pack' âŠ¸ (as atom)
   (<"->")â‰¡Ë˜2â†•"CH -> B"
âŸ¨ 0 0 0 0 0 0 âŸ©
   "->"âŠ¸â‰¡Ë˜2â†•"CH -> B"
âŸ¨ 0 0 0 1 0 0 âŸ©   # but notice the dimension is not ğ•©'s dimension

# to have like APL style with trailing zeros
    "string" â· "substring"
âŸ¨ 0 0 0 1 âŸ©

    "string" (â‰¢âˆ˜âŠ¢â†‘â·) "substring"  # APL style
âŸ¨ 0 0 0 1 0 0 0 0 0 âŸ©

Find is quite useful, even for scanning 2D patterns
    âŠ¢ a â† 7 (4|â‹†Ëœ)âŒœâ—‹â†• 9   # Array with patterns
â”Œâ”€                   
â•µ 1 1 1 1 1 1 1 1 1  
  0 1 2 3 0 1 2 3 0  
  0 1 0 1 0 1 0 1 0  
  0 1 0 3 0 1 0 3 0  
  0 1 0 1 0 1 0 1 0  
  0 1 0 3 0 1 0 3 0  
  0 1 0 1 0 1 0 1 0  
                    â”˜ # this is 7 x 9

    (0â€¿3â€¿0â‰0â€¿1â€¿0) â· a
â”Œâ”€               
â•µ 0 0 0 0 0 0 0  
  0 0 0 0 0 0 0  
  0 0 0 0 0 0 0  
  0 0 1 0 0 0 1  
  0 0 0 0 0 0 0  
  0 0 1 0 0 0 1  
                â”˜ # this is 6 x 7 only 

# to get full padding
   (0â€¿3â€¿0â‰0â€¿1â€¿0) (â‰¢âˆ˜âŠ¢â†‘â·) a
â”Œâ”€
â•µ 0 0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0 0
  0 0 0 0 0 0 0 0 0
  0 0 1 0 0 0 1 0 0
  0 0 0 0 0 0 0 0 0
  0 0 1 0 0 0 1 0 0
  0 0 0 0 0 0 0 0 0
                    â”˜
# special case
#It's also allowed for ğ•¨ to have a smaller rank than ğ•©; in this case leading axes of ğ•© are mapped over so that axes of ğ•¨ correspond to trailing axes of ğ•©.
    0â€¿1â€¿0â€¿1 â· a
â”Œâ”€             
â•µ 0 0 0 0 0 0  
  0 0 0 0 0 0  
  1 0 1 0 1 0  
  0 0 0 0 0 0  
  1 0 1 0 1 0  
  0 0 0 0 0 0  
  1 0 1 0 1 0  
              â”˜

--
âŠ	Index of

    "zero"â€¿"one"â€¿"two"â€¿"three" âŠ "one"â€¿"eight"â€¿"two"
âŸ¨ 1 4 2 âŸ© # result length match length of ğ•©, "eight" is not found, so return â‰ ğ•¨

How to think about it?
The `open` side of the symbol points to the `searched-in argument`
think about the `open` side as 'gulping up' the arguments and 'contain' them within
while the other side is left outside of the container and being used as a `searched for` match

This is same as ğ•¨âŠğ•©, we search `for` ğ•¨ `in` ğ•©
the result (list) length is the same length as the `searched for` argument

# Index of - always return just the first match
       "one"â€¿"zero"â€¿"one"â€¿"two"â€¿"three" âŠ "one"â€¿"eight"â€¿"two"â€¿"one"
âŸ¨ 0 5 3 0 âŸ©

--
 To find the indices of all matches, start with Match Each, then Indices
    / "letters" â‰¡Â¨< 'e'        # Many to one
âŸ¨ 1 4 âŸ©

    "letters" (<âˆ˜/Ë˜â‰¡âŒœËœ) "let"  # Many to many
âŸ¨ âŸ¨ 0 âŸ© âŸ¨ 1 4 âŸ© âŸ¨ 2 3 âŸ© âŸ©
# Note, for <âˆ˜/Ë˜, if we do < we could combine at major axis Ë˜, even if the
# result output for each axis has different length


# breakdown
    # 2-Train
    "letters" (<âˆ˜/Ë˜) (â‰¡âŒœËœ) "let"
    # first Train
    "letters" â‰¡âŒœËœ "let"
â”Œâ”€               
â•µ 1 0 0 0 0 0 0  
  0 1 0 0 1 0 0  
  0 0 1 1 0 0 0  
                â”˜
    # 2nd Train, notice, the combinator always bind strongest to Function
    # so its not <âˆ˜(/Ë˜), its (<âˆ˜/)Ë˜
    (<âˆ˜/)Ë˜ ("letters" â‰¡âŒœËœ "let")
âŸ¨ âŸ¨ 0 âŸ© âŸ¨ 1 4 âŸ© âŸ¨ 2 3 âŸ© âŸ©

--
âŠ’	Progressive Index of

Progressive Index of returns the index of the first unused match, 
provided there's still one left.
It returns either â‰ ğ•¨ or an index of a cell from ğ•¨ that matches the given cell of ğ•©. 

    "aaa" âŠ’ "aaaaa"
âŸ¨ 0 1 2 3 3 âŸ© # last 2 3's are ğ•¨ length, `a` is progressively found in index 0,1,2

    "aaabb" âŠ’ "ababababab"
âŸ¨ 0 3 1 4 2 5 5 5 5 5 âŸ© # last 5 5's

    "abaaccdd" âŠ’ "abcbc" 
âŸ¨ 0 1 4 8 5 âŸ© # second `b` in ğ•© cannot be found

--
Progressive Member of

# Not available as a symbol

# so Membership of in terms of Index of is:
ğ•©âˆŠğ•¨ is (ğ•¨âŠğ•©)<â‰ ğ•¨
# e.g.
    "abcde" âˆŠ "beb"
âŸ¨ 0 1 0 0 1 âŸ©
    "beb" âŠ "abcde"
âŸ¨ 3 0 3 3 1 âŸ©
    ("beb" âŠ "abcde") < 3
âŸ¨ 0 1 0 0 1 âŸ©

(ğ•¨âŠğ•©)<â‰ ğ•¨, after refactoring is âŠËœ<â‰ âˆ˜âŠ¢

    "abcde"âˆŠ"beb"
âŸ¨ 0 1 0 0 1 âŸ©
    "abcde" (âŠËœ<â‰ âˆ˜âŠ¢) "beb"
âŸ¨ 0 1 0 0 1 âŸ©
3-Train
   w (âŠËœ<(â‰ âˆ˜âŠ¢)) x
   (wâŠËœx) < (w(â‰ âˆ˜âŠ¢)x)
   
# Member of 
    "aabbcc" (âŠËœ<â‰ âˆ˜âŠ¢) "baa"
âŸ¨ 1 1 1 1 0 0 âŸ©

# Progressive Member of
    "aabbcc" (âŠ’Ëœ<â‰ âˆ˜âŠ¢) "baa"
âŸ¨ 1 1 1 0 0 0 âŸ©   # second `b` is not a member

    "aabbcc" ((âŠ’Ëœ=â‰ âˆ˜âŠ¢)/âŠ£) "baa"  # Multiset difference, notice the `=` instead of `<`, meaning find those NOT in the progressive set
"bcc"

    â‹âˆ˜â‹ "adebcedba"
âŸ¨ 0 5 7 2 4 8 6 3 1 âŸ©

    âˆ§âŠ¸âŠ’ "adebcedba"
âŸ¨ 0 5 7 2 4 8 6 3 1 âŸ©

    âˆ§âŠ¸âŠ "adebcedba"  # Ties included, or rather only the _first_ index is used
âŸ¨ 0 5 7 2 4 7 5 2 0 âŸ©

    âŠ’Ëœ "anything at all"   # every cell matched to itself, equal to â†•âˆ˜â‰ 
âŸ¨ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 âŸ©

---
Single Search (how to search for one thing only)

    stuff â† "tacks"â€¿"paper"â€¿"string"â€¿"tape"

    stuff âŠ "tacks"â€¿"string"
âŸ¨ 0 2 âŸ©   # good

    stuff âŠ "string"
âŸ¨ 4 4 4 4 4 4 âŸ©  # bad - it treats the element as the whole list to check

    stuff âŠ< "string"
â”ŒÂ·      # enclosed
Â· 2  
    â”˜

    stuff âŠ‘âˆ˜âŠâŸœ< "string"  # want the `first` element
2

    stuffâŠ¸âŠâŒ¾< "string" # or use `Under` to undo (un-enclose) < 
2

    stuff
âŸ¨ "tacks" "paper" "string" "tape" âŸ©
    "string"â€¿"nothing" âˆŠstuff
âŸ¨ 1 0 âŸ©
    "string"âˆŠstuff  # member of - also suffers same issue
âŸ¨ 0 0 0 0 0 0 âŸ©

    âˆŠâŸœstuffâŒ¾< "string" # can use similar trick, but for member of
1

---
Search for argument can be higher rank arrays

    ("high"â‰"rank") âˆŠ "list arg"
â”Œâ”€         
â•µ 0 1 1 0  
  1 1 0 0  
          â”˜

    4â€¿4â€¿4 âŠ’ 3â€¿2â¥Š4
â”Œâ”€     
â•µ 0 1  # searches in index order  (same index as if using Deshape)
  2 3  
  3 3  
      â”˜
 # so above same as: â¥Šğ•¨âŠ’ğ•© is ğ•¨âŠ’â¥Šğ•©.

    âŠ¢ rows â† >"row"â€¿"rho"â€¿"row"â€¿"rue"
â”Œâ”€     
â•µ"row  
  rho  
  row  
  rue" 
      â”˜

    rows âŠ >"row"â€¿"row"â€¿"col"â‰"rho"â€¿"cow"â€¿"col"
â”Œâ”€       
â•µ 0 0 4  # the shape always matches the `searched for` argument's
  1 4 4  
        â”˜
#breakdown:

    >"row"â€¿"row"â€¿"col"â‰"rho"â€¿"cow"â€¿"col"
â”Œâ”€     
â•"row  
  row  
  col   
       
 Â·rho  
  cow  
  col" 
      â”˜
    â‰¢>"row"â€¿"row"â€¿"col"â‰"rho"â€¿"cow"â€¿"col"
âŸ¨ 2 3 3 âŸ©
# that's why there's 2 rows in the result, each 3 major cells searched against
# the LHS argument `rows` ; in contrast
# if we `flatten` everything into a column
    rows âŠ >"row"â€¿"row"â€¿"col"â€¿"rho"â€¿"cow"â€¿"col"
âŸ¨ 0 0 4 1 4 4 âŸ©
# a 0-cell of ğ•© gives a 0-cell of the result; i.e. 1-1 cell comparisons and give
# a rank-0 (atom, just a number) for each cell

# consider this: the searched-in cells are rank-0 atom, so compare atom to ataom
    (2â€¿1â‰3â€¿1) âˆŠ 3â€¿1â€¿4â€¿3
â”Œâ”€     
â•µ 0 1  
  1 1  
      â”˜
# the searched-in cells are `list`, so compare list to list
    (2â€¿1â‰3â€¿1) âˆŠ 3â€¿1â‰4â€¿3
âŸ¨ 0 1 âŸ©
    3â€¿1â‰4â€¿3
â”Œâ”€     
â•µ 3 1  
  4 3  
      â”˜

---
â†•  <-- Dyadic window

    5â†•"abcdefg"  # take a window, there are 1+(â‰ ğ•©)-ğ•¨, or (â‰ ğ•©)Â¬ğ•¨, of these sections
â”Œâ”€       
â•µ"abcde  
  bcdef  
  cdefg" 
        â”˜   # 8 - 5 = 3 sections

# these two are the same
    2âŠ5â†•"abcdefg"
"cdefg"
    5â†‘2â†“"abcdefg"
"cdefg"

Windows differs from Prefixes and Suffixes in that it doesn't add a layer of nesting (it doesn't enclose each slice)

# Recall Prefixes and Suffixes
    â†‘ "abcde"
âŸ¨ âŸ¨âŸ© "a" "ab" "abc" "abcd" "abcde" âŸ©
    â†“ "abcde"
âŸ¨ "abcde" "bcde" "cde" "de" "e" âŸ¨âŸ© âŸ©

# window can do multiple dimension slices
    <â‰2 2â€¿2â†•"0123"âˆ¾"abcd"â‰"ABCD"   #2â€¿2 slice
â”Œâ”€                      
â•µ â”Œâ”€     â”Œâ”€     â”Œâ”€      
  â•µ"01   â•µ"12   â•µ"23    
    ab"    bc"    cd"   
       â”˜      â”˜      â”˜  
  â”Œâ”€     â”Œâ”€     â”Œâ”€      
  â•µ"ab   â•µ"bc   â•µ"cd    
    AB"    BC"    CD"   
       â”˜      â”˜      â”˜  
                       â”˜
# transposed is the same
    {(5â†•ğ•©)â‰¡â‰(3â†•ğ•©)}"abcdefg"
1

    {âŸ¨ğ•©,â‰ğ•©âŸ©}5â†•"abcdefg"
â”Œâ”€                   
Â· â”Œâ”€        â”Œâ”€       
  â•µ"abcde   â•µ"abc    
    bcdef     bcd    
    cdefg"    cde    
          â”˜   def    
              efg"   
                  â”˜  
                    â”˜
# take running sums of 3 values
    +ËË˜3â†• âŸ¨2,6,0,1,4,3âŸ©
âŸ¨ 8 7 5 8 âŸ©

A common task is to act on windows with an initial or final element so the total length stays the same. 
When using windows of length 2, the best way to accomplish this is with a shift Â« or Â». 
If the window length is longer or variable, then a 'trick' with Windows works better: 
---> add the elements, and then use windows matching the 'original' length. (Hence, do not need to specify the intended window length! For e.g. above, we had to specify window length 3â†•..)

# more normal way of doing - clear intention
    -âŸœ(0Â»âŠ¢) +` 3â€¿2â€¿1â€¿1 # shift a zero to the left
âŸ¨ 3 2 1 1 âŸ©

# using the 'trick'
    (-ËœËâ‰ â†•0âˆ¾âŠ¢) +` 3â€¿2â€¿1â€¿1  # directly join the zero to the left; and window length is full input length
âŸ¨ 3 2 1 1 âŸ©
# breakdown
    c â† +` 3â€¿2â€¿1â€¿1
âŸ¨ 3 5 6 7 âŸ©
    d â† (â‰ c)â†•(0âˆ¾âŠ¢ c)
â”Œâ”€         
â•µ 0 3 5 6  
  3 5 6 7  
          â”˜
# then do the thing
    -ËœË d
âŸ¨ 3 2 1 1 âŸ©

# apply the concept to the 3 running sums (to keep the length constant)
# but see, the first TWO elements in the result might not be needed
    (+Ëâ‰ â†•(2â¥Š0)âŠ¸âˆ¾) âŸ¨2,6,0,1,4,3âŸ©
âŸ¨ 2 8 8 7 5 8 âŸ©

# notice that the whole chunk of functions are (f . g . h . i) 
# evaluations are from right to left, so the fork g . h . i are processed first

----
How to use functions as block (ignores arguments and purely for side effects)

1.Pass @ to a function that ignores its argument. It's a nice signal that nothing is happening and is easy to type.
2.A headerless function that doesn't use an argument will be interpreted as an immediate block by default. Start it with the line ğ•¤ to avoid this (it's an instruction to navel gaze: the function contemplates its self, but does nothing about it

fn = ()=>{m+=1;n*=2}; fn() # Javascript
Fn â† {ğ•¤â‹„  m+â†©1,nÃ—â†©2}, Fn @ # Delayed execution


----
Control Flow
If â† {ğ•âŸğ•@}Â´
If (a<10)â€¿{ğ•¤
  a +â†© 10
}

# if its true, it will execute and return a result, else returns @
   aâ†1
1
   {ğ•¤â‹„a+â†©10}âŸ(a<10) @
11
   {ğ•¤â‹„a+â†©10}âŸ(a<10) @
@
# most cases, can use this
{ a<10 ? a+â†©10 ; @ }

--
For

FnÂ¨ v      # for (ğ•© in v)
FnÂ¨ â†•n     # for (ğ•©=0; ğ•©<n; ğ•©++)
FnÂ¨ kâ†“â†•n   # for (ğ•©=k; ğ•©<n; ğ•©++)  with 0â‰¤k
FnÂ¨ k+â†•n-k # for (ğ•©=k; ğ•©<n; ğ•©++)  with kâ‰¤n
FnÂ¨ âŒ½â†•n    # for (ğ•©=n; --ğ•©; )

--
If-Else
# with only predicate
{
  threshold < 6 ?
  a â†© Small threshold ;  # If predicate was true
  b â†© 1 Large threshold  # If it wasn't
}

# with Choose â—¶
IfElse â† {condâ€¿Trueâ€¿False: condâ—¶Falseâ€¿True @}

# 2 ways to write it
IfElse âŸ¨ğ•©<midâŠ‘ğ•¨
  {ğ•¤â‹„ hiâ†©mid}
  {ğ•¤â‹„ loâ†©mid}
âŸ©

IfElse (ğ•©<midâŠ‘ğ•¨)â€¿{ğ•¤
  hiâ†©mid
}â€¿{ğ•¤
  loâ†©mid
}

#usage for above example
   hiâ†0
0
   loâ†0
0
   midâ†1
1
   8â€¿9 { IfElse (ğ•©<midâŠ‘ğ•¨)â€¿{ğ•¤â‹„hiâ†©mid}â€¿{ğ•¤â‹„loâ†©mid} } 2
1
   hi
1
   lo
0

#with case headers  
{ğ•ğ•¨}Â´ (ğ•©<midâŠ‘ğ•¨)â€¿{
  1: hiâ†©mid
;
  0: loâ†©mid
}

# breakdown (ğ•©<midâŠ‘ğ•¨) {ğ•ğ•¨} {1: hiâ†©mid;0: loâ†©mid} 
# ğ•¨ could be 1 or 0, hence deciding which header to execute

--
Chained if-else

#just predicates
{
  a<b ? a+â†©1 ;
  a<c ? c-â†©1 ;
        a-â†©2
}

#this is a right fold, with the right most input as @ 
#but becoz the middle ones are all deferred functions
#so none will be executed until the first `test` statement is executed
Test â† {fnâ†{Condâ€¿Act ğ•Š else: Condâ—¶Elseâ€¿Act}Â´ğ•© â‹„ Fn@}

Test âŸ¨
  (  a<b)â€¿{ğ•¤â‹„a+â†©1}
  {ğ•¤â‹„a<c}â€¿{ğ•¤â‹„c-â†©1}
  {ğ•¤â‹„a-â†©2}
âŸ©

--
Switch case
Match â† {ğ•ğ•¨}Â´

Match valueâ€¿{
  0â€¿b: n-â†©b
;
  aâ€¿b: n+â†©a-b
;
  ğ•©: nâˆ¾â†©ğ•©
}

Select â† {(âŠ‘ğ•©)â—¶(1â†“ğ•©)@}

Select numberâ€¿{
  name â†© "zero"
}â€¿{
  name â†© "one"
}â€¿{
  name â†© "two"
}

--
                 |this ğ•© is actually useless, its just @
Forever â† {ğ•Ša:{ğ•ŠAğ•©}@}
# main gist, is to run A as a function, forever

Forever 1âŠ‘@â€¿{ğ•¤
  # Stuff to do forever
}

# slicker way is to pass ğ•© as an operand (ğ”½) into 
# the inner {ğ•Šğ”½ğ•©} 
Forever â† {ğ•©{ğ•Šğ”½ğ•©}@}

# inner operand ğ”¾ is outer ğ•©
# inner operand ğ”½ is outer ğ•¨
# inner ğ•© is @ 
# so execute ğ”¾@ as long as ğ”½ is 1
While â† {ğ•¨{ğ•Šâˆ˜ğ”¾âŸğ”½ğ•©}ğ•©@}Â´

While {ğ•¤â‹„a<15}â€¿{ğ•¤
  aÃ—â†©2
}

   aâ†1
1
   While {ğ•¤â‹„a<15}â€¿{ğ•¤â‹„â€¢Show aâ‹„aÃ—â†©2}
1
2
4
8
16

DoWhile â† {ğ•¨{ğ•ŠâŸğ”½ğ”¾ğ•©}ğ•©@}Â´
# run ğ”¾ once 
# if ğ”½ is 1, will run the loop again
   aâ†1
1
   DoWhile {ğ•¤â‹„a<15}â€¿{ğ•¤â‹„â€¢Show aâ‹„aÃ—â†©2}
1
2
4
8
16
   DoWhile {ğ•¤â‹„a<15}â€¿{ğ•¤â‹„â€¢Show aâ‹„aÃ—â†©2} # will run once
16
32
   While {ğ•¤â‹„a<15}â€¿{ğ•¤â‹„â€¢Show aâ‹„aÃ—â†©2} # wont run, just return @
@

--
Low stack version - save required stack frames logarithmicly (why?)
While â† {ğ•©{ğ”½âŸğ”¾âˆ˜ğ”½_ğ•£_ğ”¾âˆ˜ğ”½âŸğ”¾ğ•©}ğ•¨@}Â´

The simplest approach is to perform one iteration and 
--> recurse with the same two functions.
# comment
#{ğ”½_ğ•£_ğ”¾âˆ˜ğ”½âŸğ”¾ğ•©} is same as {ğ•Šâˆ˜ğ”½âŸğ”¾ğ•©}
#it is `deconstructed out` as ğ”½_ğ•£_ğ”¾ becoz we want to bind ğ”½ with ğ”½âŸğ”¾âˆ˜ğ”½
#(as mentioned below)

The modified approach replaces (the leftmost) ğ”½ with ğ”½âŸğ”¾âˆ˜ğ”½, (what is the significance of this?) 
that is, it doubles it while making sure the condition is still checked each iteration. 

#so, on the next level of recursion
#we get TWO times the function ğ”½âŸğ”¾

The `doublings compound` so that recursion level n performs ğ”½ up to 2â‹†n times (2 power n) while using on the order of n additional stack frames. 

# seems this also work? what's the diff between this and the above?
While â†© {ğ•©{ğ”½âŸğ”¾âˆ˜ğ•Šâˆ˜ğ”½âŸğ”¾ğ•©}ğ•¨@}Â´

# seems there's a system â€¢_while_
### WARNING: this is NOT a pure BQN function, so it cannot be defined by pure BQN terms

# so this would work
   {ğ•Š: â€¢Show iâ‹„i+â†©1}â€¢_while_(<âŸœ10) i   # navel gazing ğ•Š:, same as ğ•¤â‹„
1
2
3
4
5
6
7
8
9
10

# this works as well: 
{ğ•Š: â€¢Show iâ‹„i+â†©1}â€¢_while_{ğ•¤ â‹„ i < 10} @

# this builtin â€¢while works by taking any initial value from ğ”¾
# and the subsequent loop condition is actually evaluated from the result of ğ”½ 
   iâ†0
0
   {ğ•Š: â€¢Show iâ‹„i+iâ†©1 â‹„ 12}â€¢_while_(<âŸœ10) i
0
12   # stopped, coz the result value of ğ”½ is 12 
   i
1
 

# if using âŠ¢, it would not go beyond 0 for ğ”½
   iâ†2
2
   {ğ•Š: â€¢Show iâ‹„i-â†©1}â€¢_while_âŠ¢1
2
1
0
# its weird, becoz somehow the left ğ”½ affects the right condition

left tack âŠ£ seems the same
   iâ†2
2
   {ğ•Š: â€¢Show iâ‹„i-â†©1}â€¢_while_âŠ£1
2
1
0

# it takes a w as well
# in this case it evaluates the condition by w G x
# and executes by w F x, with the new result being the next x
   10 {ğ•Š: â€¢Show ğ•¨â€¿ğ•©â‹„â€¢Show iâ‹„i+â†©1}â€¢_while_> i
âŸ¨ 10 5 âŸ©
5
âŸ¨ 10 6 âŸ©
6
âŸ¨ 10 7 âŸ©
7
âŸ¨ 10 8 âŸ©
8
âŸ¨ 10 9 âŸ©
9
10





