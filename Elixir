(Erlang) NIFs - Native Implemented Functions that is implemented in C
%{app_id: :undefined, cluster_id: :undefined, consumer_tag:
%"amq.ctag-HdV2nPwGLXMsrrdxhYBHnw", content_encoding: :undefined, content_type:
%:undefined, correlation_id: :undefined, delivery_tag: 1, exchange: "",
%expiration: :undefined, headers: :undefined, message_id: :undefined,
%persistent: true, priority: :undefined, redelivered: false, reply_to:
%:undefined, routing_key: "task_queue", timestamp: :undefined, type: :undefined,
%user_id: :undefined}
The NIF library must be loaded in runtime by the Erlang code of the module.



under /usr/bin
iex - interactive Elixir (REPL)
elixir - to run scripts
    elixir simple.exs
mix - build tool
elixirc - to compile file
    elixirc math.ex
    when launching `iex` in a directory with *.beam files, it will autoload them



few ways to run code:
iex <myfile.ex>  - via repl
elixir -r <myfile.ex> -e 'M.hi "Alex"'  - -r require -e evaluate    : single line execution

elixirc <myfile.ex>  - to create .beam
iex  - then autoload in iex to use it

via mix:
iex -S mix

mix run somescript.exs
mix run -e 'Myproj.M.hi "..."'    - via mix run with evaluation (function)


to break expression in iEX, 
#iex:break
or
Ctrl-g, i, c

# checkout IEx.helpers

import_file(path)
Injects the contents of the file at path as if it was typed into the shell.

This would be the equivalent of getting all of the file contents and packing it all into a single line in IEx and executing it.

---
.iex.exs

put all your imports and aliases here to save time!
this will be run when we fire up iex -S mix

--

elixir will also auto load *.beam files in same directory

Elixir is dynamically typed
Elixir does come with typespecs

Elixir data structures are immutable
Date types:
-------------
iex> 1          # integer
iex> 0x1F       # integer
iex> 1.0        # float
iex> true       # boolean
iex> :atom      # atom / symbol
iex> "elixir"   # string
iex> [1, 2, 3]  # list
iex> {1, 2, 3}  # tuple

iex> 1 + 2
3
iex> 5 * 5
25
iex> 10 / 2
5.0

-- can drop the parentheses
-- notice the comma to separate arguments
iex> div(10, 2)
5
iex> div 10, 2
5
iex> rem 10, 3
1

--
shortcut notations
iex> 0b1010  -- binary
10
iex> 0o777   -- octal
511
iex> 0x1F    -- hex
31

--
float 
iex> 1.0
1.0
iex> 1.0e-10
1.0e-10

iex> round(3.58)
4
iex> trunc(3.58)
3

----
Kernel is the default environment (module)
`h` is the helper h() function , h/0 (function h with zero arguments)
can show function documentations (very helpful in REPL)
<the function name>/<arity> is the identifier for a function
iex> h trunc/1
                             def trunc()

Returns the integer part of number.

iex> h Kernel.trunc/1
                             def trunc()

Returns the integer part of number.

h brings up @doc and @spec

Use `t` to check on type (specified by @typedoc and @type in module)

--
Booleans
iex> true
true
iex> true == false
false

iex> is_boolean(true)
true
iex> is_boolean(1)
false

there are also a bunch of other predicate functions like: is_integer/1, is_float/1 or is_number/1

-----
Atoms or symbols
(used a keys or enums)

iex> :apple
:apple
iex> :orange
:orange
iex> :watermelon
:watermelon

iex> :apple == :apple
true
iex> :apple == :orange
false

booleans true and false are also atoms
iex> true == :true
true
iex> is_atom(false)
true
iex> is_boolean(:false)
true
iex> is_atom(nil) -- an undefined atom call 'nil'
true

iex> is_atom(Hello) -- Hello here is an alias, starts in Uppercase and also an atom
true

---------
Strings
iex> "hellö"
"hellö"

string interpolation
iex> string = :world
iex> "hellö #{string}"
"hellö world"
iex> "hello #{str1}"
"hello world"

iex> "hello
...> world"
"hello\nworld"
iex> "hello\nworld"
"hello\nworld"

iex> IO.puts("hello\nworld")
hello
world
:ok

Strings in Elixir are represented internally by contiguous sequences of bytes known as binaries
iex> is_binary("hellö")
true
-- “ö” takes 2 bytes to be represented in UTF-8
iex> byte_size("hellö")
6

iex> String.length("hellö")
5
iex> String.upcase("hellö")
"HELLÖ"

--------
Anonymous functions
iex> add = fn a, b -> a + b end
#Function<12.71889879/2 in :erl_eval.expr/5>
iex> add.(1, 2)
3
iex> is_function(add)
true

-- Note that a dot (.) between the variable and parentheses is required to invoke an anonymous function. The dot ensures there is no ambiguity between calling the anonymous function matched to a variable add and a named function add/2.

-- Also note that, for `->`, an expression is always required on the RHS of ->, need to return a value after ->


# check if add is a function that expects exactly 2 arguments
iex> is_function(add, 2)
true
# check if add is a function that expects exactly 1 argument
iex> is_function(add, 1)
false

# anonymous functions can also access variables that are in scope when the function is defined
iex> double = fn a -> add.(a, a) end
#Function<6.71889879/1 in :erl_eval.expr/5>
iex> double.(2)
4

iex> x = 42
42
iex> (fn -> x = 0 end).() # does not affect its surrounding environment
0
iex> x
42

-----------
(Linked) Lists

iex> [1, 2, true, 3]
[1, 2, true, 3]
iex> length [1, 2, 3]
3

Two lists can be concatenated or subtracted using the ++/2 and --/2 operators
iex> [1, 2, 3] ++ [4, 5, 6]
[1, 2, 3, 4, 5, 6]
iex> [1, true, 2, false, 3, true] -- [true, false]
[1, 2, 3, true]

a list can hold _any_ value
iex> [1,'1',1]
[1, '1', 1]


iex> list = [1, 2, 3]
iex> hd(list)
1
iex> tl(list)
[2, 3]
iex> hd([])
** (ArgumentError) argument error

When Elixir sees a list of printable ASCII numbers, Elixir will print that as a charlist (literally a list of characters). 

iex> [11, 12, 13]
'\v\f\r'
iex> [104, 101, 108, 108, 111]
'hello'

we can use `i/1` to retrieve more information about a value in IEx

Single quotes are charlists, double quotes are strings.
iex> 'hello' == "hello"
false

`in` keyword

iex> 2 in [1,2,3]
true


------
Tuples
tuples can hold any value (same as a list)
iex> {:ok, "hello"}
{:ok, "hello"}
iex> tuple_size {:ok, "hello"}
2

iex> tuple = {:ok, "hello"}
{:ok, "hello"}
iex> elem(tuple, 1)
"hello"
iex> tuple_size(tuple)
2

iex> tuple = {:ok, "hello"}
{:ok, "hello"}
iex> put_elem(tuple, 1, "world") # returns new tuple
{:ok, "world"}
iex> tuple
{:ok, "hello"}


List vs Tuple

Lists are stored in memory as linked lists.
    - read slow (linear operation) since need to traverse list
    - update or adding fast 
Tuples, on the other hand, are stored contiguously in memory.
    - getting the tuple size or accessing an element by index is fast
    - updating or adding elements to tuples is expensive because it requires
      creating a new tuple in memory


When counting the elements in a data structure, Elixir also abides by a simple rule: the function is named size if the operation is in constant time (i.e. the value is pre-calculated) or length if the operation is linear (i.e. calculating the length gets slower as the input grows). As a mnemonic, both “length” and “linear” start with “l”.

For example, we have used 4 counting functions so far: byte_size/1 (for the number of bytes in a string), tuple_size/1 (for tuple size), length/1 (for list length) and String.length/1 (for the number of graphemes in a string). We use byte_size to get the number of bytes in a string – a cheap operation. Retrieving the number of Unicode graphemes, on the other hand, uses String.length, and may be expensive as it relies on a traversal of the entire string.

-------

iex> "foo" <> "bar"
"foobar"

# and / or are strict
# and / or are short-circuit operators
iex> true and true
true
iex> false or is_atom(:example)
true

iex> 1 and true
** (BadBooleanError) expected a boolean on left-side of "and", got: 1

iex> false and raise("This error will never be raised")
false
iex> true or raise("This error will never be raised")
true

# ||, && and ! will accept arguments of any type
# or
iex> 1 || true
1
iex> false || 11
11

# and
iex> nil && 13
nil
iex> true && 17
17

# not
iex> !true
false
iex> !1
false
iex> !nil
true

# ==, !=, ===, !==, <=, >=, < and > as comparison operators:
iex> 1 == 1
true
iex> 1 != 2
true
iex> 1 < 2
true

# === is more strict when comparing integers and floats
iex> 1 == 1.0
true
iex> 1 === 1.0
false

# we can compare different data types
iex> 1 < :atom
true

# The reason we can compare different data types is pragmatism. Sorting algorithms don’t need to worry about different data types in order to sort. The overall sorting order is defined below:
number < atom < reference < function < port < pid < tuple < map < list < bitstring

-------
Pattern Matching

= is a pattern matching operator (the match operator)
^ is the pin operator

iex(6)> x = 'a'
'a'
iex(7)> 'a' = x # this is a valid expression, it matched because both left and right side are equal
'a'
iex(10)> 'b' = x # when doesnt match, a `MatchError` is raised
** (MatchError) no match of right hand side value: 'a'

# this is different than a comparator
iex(8)> x == 'a'
true
iex(9)> 'a' == x
true

A variable can only be assigned on the left side of `=`

# useful for destructuring complex data types
iex> {a, b, c} = {:hello, "world", 42}
{:hello, "world", 42}
iex> a
:hello
iex> b
"world"

# we can match on specific values
# will only match when right side tuple starts with :ok
iex> {:ok, result} = {:ok, 13}
{:ok, 13}
iex> result
13

iex> {:ok, result} = {:error, :oops}
** (MatchError) no match of right hand side value: {:error, :oops}

# against list
iex> [a, b, c] = [1, 2, 3]
[1, 2, 3]
iex> a
1

# matching against head and tail
iex> [head | tail] = [1, 2, 3]
[1, 2, 3]
iex> head
1
iex> tail
[2, 3]

**The | operator is typically used between brackets as the cons operator: [head | tail]

# also used for prepending (consing) a list
iex> list = [1, 2, 3]
[1, 2, 3]
iex> [0 | list]
[0, 1, 2, 3]

it can be used to UPDATE a Map as well (not putting in new stuffs, that's Map.put)




---
The pin operator prevents variables from getting rebound

iex> x = 1
1
iex> x = 2
2

# use ^ when want to pattern match against a variable's existing value
iex> x = 1
1
iex> ^x = 2
** (MatchError) no match of right hand side value: 2

# becoz ^x has been pinned to 1, it's equivalent to the following
iex> 1 = 2
** (MatchError) no match of right hand side value: 2

iex> x = 1
1
iex> [^x, 2, 3] = [1, 2, 3]
[1, 2, 3]
iex> {y, ^x} = {2, 1}
{2, 1}
iex> y
2
iex> {y, ^x} = {2, 2}
** (MatchError) no match of right hand side value: {2, 2}

# if a variable is mentioned more than once, all reference should bind to same
# value
iex> {x, x} = {1, 1}
{1, 1}
iex> {x, x} = {1, 2}
** (MatchError) no match of right hand side value: {1, 2}

# use underscore to ignore values
iex> [head | _] = [1, 2, 3]
[1, 2, 3]
iex> head

--
pin operator vs match?/2

a pin operator matches values, not patterns
a pin operator checks if the values are equal, using ===/2
match?/2 matches patterns

match?(%{x: 1}, %{x: 1, y: 2})
#=> true

attrs = %{x: 1}
match?(^attrs, %{x: 1, y: 2}) # fail to match exact value
#=> false

https://hexdocs.pm/elixir/master/Kernel.html#match?/2

----------
case, cond and if

CASE
# case, compare a value against many patterns
iex> case {1, 2, 3} do
...>   {4, 5, 6} ->
...>     "This clause won't match"
...>   {1, x, 3} ->
...>     "This clause will match and bind x to 2 in this clause"
...>   _ ->
...>     "This clause would match any value"
...> end
"This clause will match and bind x to 2 in this clause"

# use ^ to pattern match against an existing variable
iex> x = 1
1
iex> case 10 do
...>   ^x -> "Won't match"
...>   _ -> "Will match"
...> end
"Will match"

iex> case {1, 2, 3} do
...>   {1, x, 3} when x > 0 ->
...>     "Will match"
...>   _ ->
...>     "Would match, if guard condition were not satisfied"
...> end
"Will match"

iex> hd(1)
** (ArgumentError) argument error
iex> case 1 do
...>   x when hd(x) -> "Won't match" # error wont be thrown here
...>   x -> "Got #{x}"
...> end
"Got 1"

# none matching clause will raise error
iex> case :ok do
...>   :error -> "Won't match"
...> end
** (CaseClauseError) no case clause matching: :ok

# anonymous functions can have multiple clauses and guards
# but must have same arities
iex> f = fn
...>   x, y when x > 0 -> x + y
...>   x, y -> x * y
...> end
#Function<12.71889879/2 in :erl_eval.expr/5>
iex> f.(1, 3)  # remember, anonymous function need the dot to access
4
iex> f.(-1, 3)
-3

---
COND

for checking (evaluating) different truthful conditions

iex> cond do
...>   2 + 2 == 5 ->
...>     "This will not be true"
...>   2 * 2 == 3 ->
...>     "Nor this"
...>   1 + 1 == 2 ->
...>     "But this will"
...> end
"But this will"

# use `true` as catch all (same as `otherwise` in H)
iex> cond do
...>   2 + 2 == 5 ->
...>     "This is never true"
...>   2 * 2 == 3 ->
...>     "Nor this"
...>   true ->
...>     "This is always true (equivalent to else)"
...> end
"This is always true (equivalent to else)"

# no truth conditions, will raise CondClauseError
iex(11)> cond do
...(11)> 2 + 1 == 4 -> "not good"
...(11)> end
** (CondClauseError) no cond clause evaluated to a truthy value

# any value besides only `nil` and `false` are considered true
iex> cond do
...>   hd([1, 2, 3]) ->
...>     "1 is considered as true"
...> end
"1 is considered as true"

-------
`if` and `unless`

if/2 and unless/2 (these 2 are macros, the way this is handled is like scheme)

iex> if true do   # if alone works
...>   "This works!"
...> end
"This works!"
iex> unless true do
...>   "This will never be seen"
...> end
nil    # false expression returns nil
# always returns a value

iex> if nil do      # if , else
...>   "This won't be seen"
...> else
...>   "This will"
...> end
"This will"

------
Variable scoping

iex> x = 1
1
iex> if true do
...>   x = x + 1
...> end
2
iex> x  # global x not changed
1

iex> x = 1
1
iex> x = if true do  # needs to assign x from return value if want to change out of scope
...>   x + 1
...> else
...>   x
...> end
2

-------
do/end blocks (syntactic sugar for keyword list - arguments with commas)

if true do 1 + 2 end

can also be written as

if true, do: 1 + 2

to get rid of the end
in above, each argument is separated by a comma
this syntax is using `keyword lists`
we can 'chain' it up using commas

iex> if false, do: :this, else: :that
:that

# these are equivalent
iex> if true do
...>   a = 1 + 2
...>   a + 10
...> end
13
iex> if true, do: (  #keyword :do, value (..) 
...>   a = 1 + 2
...>   a + 10
...> )
13

-----------------
Binaries, strings and charlists

#can check code point like so
iex(1)> ?a
97
iex(2)> ?获
33719

iex> "\u0061" === "a"
true
iex> 0x0061 = 97 = ?a
97

#Elixir uses UTF-8 to encode its strings
#for e.g., é can be represented in Unicode as a single character. It can also be represented as the combination of the character e and the acute accent character ´ into a single grapheme.
iex> string = "hełło" 
"hełło"
iex> String.length(string) # counts graphemes
5
iex> byte_size(string) # shows number of raw bytes needed to store the string in UTF-8 encoding
7

# if want to see inner binary (bytes) representation of string, can concat the null byte
# <<0>> to it
iex(3)> "abc" <> <<0>>
<<97, 98, 99, 0>>
# can use IO.inspect/2
iex> IO.inspect("hełło", binaries: :as_binaries)
<<104, 101, 197, 130, 197, 130, 111>>

-----
Bitstrings
A bitstring is a fundamental data type in Elixir, denoted with the <<>> syntax. A bitstring is a contiguous sequence of bits in memory (not linked list).

#by default, 8 bits (1 byte) is used to store each number in bitstring
iex> <<42>> === <<42::8>>
true
iex> <<3::4>> #but we can manually manipulate it like this
<<3::size(4)>> # or use size(n) function

#can also represent 3 in base 2, 4 bits - 0011
#since the content in the memory is same, both == and === passes 
iex> <<0::1, 0::1, 1::1, 1::1>> == <<3::4>>
true
iex> <<0::1, 0::1, 1::1, 1::1>> === <<3::4>>
true

# value exceeds number of bits provisioned, left most 1 truncated
iex> <<1>> === <<257>>
true

257 value in base 2 = 100000001, but can only up until 256 binary value for 8 bits, so becomes 00000001, or simply 1

-----
Binaries
A binary is a bitstring where the number of bits is divisible by 8. 
Every binary is a bitstring, but not every bitstring is a binary.

iex> is_bitstring(<<3::4>>)
true
iex> is_binary(<<3::4>>)
false
iex> is_bitstring(<<0, 255, 42>>)
true
iex> is_binary(<<0, 255, 42>>)
true
iex> is_binary(<<42::16>>) # note, this is also true
true

iex> <<0, 1, x>> = <<0, 1, 2>>
<<0, 1, 2>>
iex> x
2
iex> <<0, 1, x>> = <<0, 1, 2, 3>>
** (MatchError) no match of right hand side value: <<0, 1, 2, 3>>


# but if we use type `binary` modifier (which can match bits divisible by 8)
iex> <<0, 1, x::binary>> = <<0, 1, 2, 3>>
<<0, 1, 2, 3>>
iex> x
<<2, 3>>

# using binary-size/1 for more specific `n` bytes
iex> <<head::binary-size(2), rest::binary>> = <<0, 1, 2, 3>>
<<0, 1, 2, 3>>
iex> head
<<0, 1>>
iex> rest
<<2, 3>>

# A string is a UTF-8 encoded binary
# Every string is a binary, but due to the UTF-8 standard encoding rules, not every binary is a valid string
iex> is_binary("hello")
true
iex> is_binary(<<239, 191, 19>>)
true
iex> String.valid?(<<239, 191, 19>>)
false

# string concatenation operator <> (binary concatenation operator)
iex> "a" <> "ha"
"aha"
iex> <<0, 1>> <> <<2, 3>>
<<0, 1, 2, 3>>

# binary pattern matching
iex> <<head, rest::binary>> = "banana"
"banana"
iex> head == ?b # this works becoz `b` is just one byte
true
iex> rest
"anana"

iex> "ü" <> <<0>>
<<195, 188, 0>>
iex> <<x, rest::binary>> = "über"
"über"
iex> x == ?ü # ü is 2 bytes , first byte is only 195
false
iex> rest
<<188, 98, 101, 114>>

# but we can use utf8 modifier
iex> <<x::utf8, rest::binary>> = "über"
"über"
iex> x == ?ü
true
iex(13)> ?ü
252 # unicode point  = 252
iex> "ü" <> <<0>> 
<<195, 188, 0>> # utf8 hex representation # see utf8-chartable.de
iex> rest
"ber"

------
Charlists
A charlist is a `list of integers` where all the integers are valid code points
useful when interfacing with Erlang, in particular when using older libraries that do not accept binaries as arguments.

iex> 'hello'
'hello'
iex> [?h, ?e, ?l, ?l, ?o]  # all valid code points, in a list
'hello'

iex> 'hełło'
[104, 101, 322, 322, 111] # the list is only printed in single quotes if all code points are within ASCII range
iex> is_list('hełło') 
true

# as long as a list of integers all happen to be in range between 0 and 127
# Elixir will interpret it as charlist
iex> heartbeats_per_minute = [99, 97, 116]
'cat'

iex> to_charlist("hełło")
[104, 101, 322, 322, 111]
iex> to_string('hełło')
"hełło"
iex> to_string(:hello)
"hello"
iex> to_string(1)
"1"

# <> concats for string (binary)
# ++ concats for list (charlist)

iex> 'this ' <> 'fails'
** (ArgumentError) expected binary argument in <> operator but got: 'this '
    (elixir) lib/kernel.ex:1821: Kernel.wrap_concatenation/3
    (elixir) lib/kernel.ex:1808: Kernel.extract_concatenations/2
    (elixir) expanding macro: Kernel.<>/2
    iex:1: (file)
iex> 'this ' ++ 'works'
'this works'
iex> "he" ++ "llo"
** (ArgumentError) argument error
    :erlang.++("he", "llo")
iex> "he" <> "llo"
"hello"

------------
Associative data structures: keyword lists and maps

-- Keyword List
# mainly used to work with optional (argument) values
  - this solves Clojure's problem of how to pass long kwargs elegantly
# use 2-item tuples as key-value data structure
iex> list = [{:a, 1}, {:b, 2}]
[a: 1, b: 2]
iex> list == [a: 1, b: 2] # special syntax
true

# all list operations are usable on keyword list
iex> list ++ [c: 3]
[a: 1, b: 2, c: 3]
iex> [a: 0] ++ list
[a: 0, a: 1, b: 2]

iex> new_list = [a: 0] ++ list
[a: 0, a: 1, b: 2]
iex> new_list[:a] # lookup only fetch the front values
0

- Keys must be atoms.
- Keys are ordered, as specified by the developer.
- Keys can be given more than once. (yes, its just a list)

# keyword list is used to pass options to functions
iex> if false, do: :this, else: :that
:that

# do: and else: pairs form a keyword list
# recall if/2 macro
iex> if(false, [do: :this, else: :that])
:that

# its the same as
iex> if(false, [{:do, :this}, {:else, :that}])
:that

# In general, when the keyword list is the last argument of a function, the square brackets are optional.

https://hexdocs.pm/elixir/Keyword.html

-- MAPS

- Maps allow any value as a key.
- Maps’ keys do not follow any ordering.

Maps can be created with the %{} syntax, and key-value pairs can be expressed as key => value

iex> map = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}
iex> map[:a]
1
iex> map[2]
:b
iex> map[:c]
nil

this map[:a] syntax should be a syntactic sugar for fetch(container, key)
https://hexdocs.pm/elixir/Access.html#fetch/2

# maps are very useful with pattern matching
# will match on a subset of given value
iex> %{} = %{:a => 1, 2 => :b} # an empty map matches all maps.
%{2 => :b, :a => 1}
iex> %{:a => a} = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}
iex> a
1
iex> %{:c => c} = %{:a => 1, 2 => :b}
** (MatchError) no match of right hand side value: %{2 => :b, :a => 1}

iex> n = 1
1
iex> map = %{n => :one}
%{1 => :one}
iex> map[n]
:one
iex> %{^n => :one} = %{1 => :one, 2 => :two, 3 => :three}
%{1 => :one, 2 => :two, 3 => :three}

# check https://hexdocs.pm/elixir/Map.html to learn more
iex> Map.get(%{:a => 1, 2 => :b}, :a)
1
iex> Map.put(%{:a => 1, 2 => :b}, :c, 3)
%{2 => :b, :a => 1, :c => 3}
iex> Map.to_list(%{:a => 1, 2 => :b})
[{2, :b}, {:a, 1}]


iex> map = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}

# | is also the syntax to update a key's value
iex> %{map | 2 => "two"}
%{2 => "two", :a => 1}
# this syntax requires key to exist, else fail
iex> %{map | :c => 3}
** (KeyError) key :c not found in: %{2 => :b, :a => 1}

# when all keys are atoms, can use `keyword` syntax (i.e. no need to use =>)
iex> map = %{a: 1, b: 2}
%{a: 1, b: 2}

# map.field accessor syntax
iex> map = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}

iex> map.a
1
iex> map.c
** (KeyError) key :c not found in: %{2 => :b, :a => 1}

# beware Map.pop returns the item being popped as well as the new map inside a
# tuple
iex(4)> test = %{a: 1, b: 2}
%{a: 1, b: 2}
iex(5)> Map.pop(test, :a)
{1, %{b: 2}}


-- Nested data structures

put_in/2 and update_in/2 from Kernel
iex> users = [
  john: %{name: "John", age: 27, languages: ["Erlang", "Ruby", "Elixir"]},
  mary: %{name: "Mary", age: 29, languages: ["Elixir", "F#", "Clojure"]}
]
[
  john: %{age: 27, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
  mary: %{age: 29, languages: ["Elixir", "F#", "Clojure"], name: "Mary"}
]

iex> users[:john].age
27

iex> users = put_in users[:john].age, 31
[
  john: %{age: 31, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
  mary: %{age: 29, languages: ["Elixir", "F#", "Clojure"], name: "Mary"}
]

iex> users = update_in users[:mary].languages, fn languages -> List.delete(languages, "Clojure") end
[
  john: %{age: 31, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
  mary: %{age: 29, languages: ["Elixir", "F#"], name: "Mary"}
]

--------------
Modules and functions

defmodule macro - define module
def/2 macro - define functions
defp/2 macro - define private functions

iex> defmodule Math do
...>   def sum(a, b) do
...>     a + b
...>   end
...> end

iex> Math.sum(1, 2)
3

Elixir projects directories
    - _build - contains compilation artifacts
    - lib - contains Elixir code (.ex files)
    - test - contains tests (.exs files)

use `elixir` when wants to execute script .exs files
    - module will be compiled and loaded into memory, no .beam file is generated

defdelegate
define a function in this module which delegates to another module
defmodule MyList do
  defdelegate reverse(list), to: Enum    # delegate to: Enum, function to be called same name as defined
  defdelegate other_reverse(list), to: Enum, as: :reverse  #as: is the function to be called in the target :to
end

MyList.reverse([1, 2, 3])
#=> [3, 2, 1]

MyList.other_reverse([1, 2, 3])
#=> [3, 2, 1]




---
&(expr) is the `capture operator` (seems like a pointer..)
https://hexdocs.pm/elixir/Kernel.SpecialForms.html#&/1

iex> Math.zero?(0)
true
iex> fun = &Math.zero?/1 # pointer 'assigned' to `fun`
&Math.zero?/1
iex> is_function(fun)
true
iex> fun.(0)
true

iex> &is_function/1
&:erlang.is_function/1  # seems like this is an Erlang function
iex> (&is_function/1).(fun)
true

## https://erlang.org/doc/search/

iex> fun = &(&1 + 1)
#Function<6.71889879/1 in :erl_eval.expr/5>
iex> fun.(1)
2

iex> fun2 = &"Good #{&1}"
#Function<6.127694169/1 in :erl_eval.expr/5>
iex)> fun2.("morning")
"Good morning"


fun = &(&1 + 1) is equal to 
fun = fn x -> x + 1

#first &(..) is a capture syntax
#the &1 is the argument placeholder

#can have multiple argument placeholders
fun = &{&1, &2}
fun.(1, 2)
{1, 2}

fun = &[&1 | &2]  #recall | is the cons operator (for tail only), means tail position can be anything
fun.(1, [2, 3])
[1, 2, 3]

---
Function default arguments (with \\)

defmodule Concat do
  # A function head declaring defaults
  def join(a, b \\ nil, sep \\ " ")

  def join(a, b, _sep) when is_nil(b) do # here _sep means it will always be ignored
    a
  end

  def join(a, b, sep) do
    a <> sep <> b
  end
end

IO.puts Concat.join("Hello", "world")      #=> Hello world
IO.puts Concat.join("Hello", "world", "_") #=> Hello_world
IO.puts Concat.join("Hello")               #=> Hello

-----
Recursion

defmodule Math do
  # seems like only way is to define 2 separate functions as such
  #  case .. -> cannot be used becoz `->` expect RHS to return a value
  #  (expression)
  def double_each([head | tail]) do
    [head * 2 | double_each(tail)]
  end

  def double_each([]) do
    []
  end
end

Enum.reduce([1, 2, 3], 0, fn(x, acc) -> x + acc end)
-- equivalent to 
Enum.reduce([1, 2, 3], 0, &+/2)  # &+/2 is the erlang function &:erlang.+/2 

Enum.map([1, 2, 3], fn(x) -> x * 2 end)
-- equivalent to 
Enum.map([1, 2, 3], &(&1 * 2))


------
Enum (eager) and Stream (lazy)

Enum and Stream are modules,
they make use of Enumerable protocol 
(something like a typeclass / interface
that require implementor to implement 
a set of minimal functions)

Enumerable needs to implement:
reduce/3, count/1, member?/2, and slice/1

These are enumerables: Lists ([1, 2, 3]), Maps (%{foo: 1, bar: 2}) and Ranges (1..3)

All functions in Enum module are eager
iex> odd? = &(rem(&1, 2) != 0)
#Function<6.80484245/1 in :erl_eval.expr/5>
iex> Enum.filter(1..3, odd?)
[1, 3]

They generate intermediate lists
iex> 1..100_000 |> Enum.map(&(&1 * 3)) |> Enum.filter(odd?) |> Enum.sum()
7500000000

pipe operator, similar to the threading macro (->, thread first macro) in Clojure
pass result as the first argument to the next function
pass from left to right

2 caveats:
1. to pipe into an anonymous function, need to invoke it
some_fun = &Regex.replace(~r/l/, &1, "L")
"Hello" |> some_fun.()

2. for value expected outside of first argument, can use then/2
"Hello" |> then(&Regex.replace(~r/l/,&1, "L"))

---
Streams are composable, lazy enumerables
iex> 1..100_000 |> Stream.map(&(&1 * 3)) |> Stream.filter(odd?) |> Enum.sum
7500000000


iex> 1..100_000 |> Stream.map(&(&1 * 3))
#Stream<[enum: 1..100000, funs: [#Function<34.16982430/1 in Stream.map/2>]]>
iex> 1..100_000 |> Stream.map(&(&1 * 3)) |> Stream.filter(odd?)
#Stream<[enum: 1..100000, funs: [...]]>

Instead of generating intermediate lists, streams build a series of computations that are invoked only when we pass the underlying stream to the Enum module (or when calling Stream.run). Streams are useful when working with large, possibly infinite, collections (and slow resources like file / network resources).

iex> stream = Stream.cycle([1, 2, 3])
#Function<15.16982430/2 in Stream.unfold/2>
iex> Enum.take(stream, 10)
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1]


#String.next_codepoint -> @spec next_codepoint(t()) :: {codepoint(), t()} | nil
#where t() is UTF-8 encoded or just binary()
iex> stream = Stream.unfold("hełło", &String.next_codepoint/1)
# unfold needs to take in an initial accumulator and a function which return a tuple of {this value, next
# accumulator}
#Function<39.75994740/2 in Stream.unfold/2>
iex> Enum.take(stream, 3)
["h", "e", "ł"]

Streams can be very useful for handling large files or even slow resources like network resources, Check out Stream.resource/3 which allows to define pre and post functions

-----------
Processes
1. All code runs inside processes
2. Processes are isolated from each other
3. Processes communicate via message passing

basic mechanism to spawn new process
iex(6)> pid = spawn(fn -> 1 + 2 end)
#PID<0.115.0>
iex(7)> Process.alive?(pid)
false
iex(8)> self()
#PID<0.105.0>
iex(9)> Process.alive?(self())
true

-- send -> process's mailbox -> receive

iex> send(self(), {:hello, "world"})
{:hello, "world"}
iex> receive do
...>   {:hello, msg} -> msg
...>   {:world, _msg} -> "won't match"
...> end
"world"

A process can send messages to itself.

If there is no message in the mailbox matching any of the patterns, the current process will wait until a matching message arrives. A timeout can also be specified:
iex> receive do
...>   {:hello, msg}  -> msg
...> after
...>   1_000 -> "nothing after 1s"
...> end
"nothing after 1s"

Use Process.info() to check information about current process

# send messages between processes
iex> parent = self()
#PID<0.41.0>
iex> spawn(fn -> send(parent, {:hello, self()}) end)
#PID<0.48.0>
iex> receive do
...>   {:hello, pid} -> "Got hello from #{inspect pid}"
...> end
"Got hello from #PID<0.48.0>"

inspect/1 function convert a data structure's internal representation to a string

# use flush/0 to prints all messages in the mailbox
iex> send(self(), :hello)
:hello
iex> flush()
:hello
:ok

-- Links

iex> spawn(fn -> raise "oops" end)
#PID<0.58.0>

[error] Process #PID<0.58.00> raised an exception
** (RuntimeError) oops
    (stdlib) erl_eval.erl:668: :erl_eval.do_apply/6

# parent process still running after this
# If we want the failure in one process to propagate to another one, we should link them. This can be done with spawn_link/1

iex(13)> spawn_link(fn -> raise "hi" end)
** (EXIT from #PID<0.105.0>) shell process exited with reason: an exception was raised:
    ** (RuntimeError) hi
    (stdlib 3.15.1) erl_eval.erl:683: :erl_eval.do_apply/6

Interactive Elixir (1.12.0) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)>
23:54:33.168 [error] Process #PID<0.125.0> raised an exception
** (RuntimeError) hi
    (stdlib 3.15.1) erl_eval.erl:683: :erl_eval.do_apply/6

# Parent process has received EXIT signal and cause shell to terminate

Processes and links play an important role when building fault-tolerant systems. Elixir processes are isolated and don’t share anything by default. 
Therefore, a failure in a process will never crash or corrupt the state of another process. 
Links, however, allow processes to establish a relationship in case of failure. We often link our processes to supervisors which will detect when a process dies and start a new process in its place.

**Abstractions built on top of spawn and spawn_link

Agents, generic servers and supervisors are all meant to work with multiple messages or manage state
For execution of some straight forward task, can use Tasks

-- Tasks

Tasks, by default, have the :restart value set to :temporary, which means they are not restarted.

Task.start/1
Task.start_link/1
Task.async/1
Task.await/1

iex(1)> Task.start(fn -> raise "oops" end)
{:ok, #PID<0.55.0>}  # returns better reports

15:22:33.046 [error] Task #PID<0.55.0> started from #PID<0.53.0> terminating
...

-- State
Each processes (that loop infinitely) can send, receive messags and store state (typically using map)

#`kv.ex`
defmodule KV do
  def start_link do
    Task.start_link(fn -> loop(%{}) end)
  end

  defp loop(map) do
    receive do
      {:get, key, caller} ->
        send caller, Map.get(map, key)
        loop(map)
      {:put, key, value} ->
        loop(Map.put(map, key, value))
    end
  end
end

iex(4)> {:ok, pid} = KV.start_link() # start infinite process
{:ok, #PID<0.117.0>}
iex(7)> send(pid, {:get, :alvin, self()})
{:get, :alvin, #PID<0.105.0>}
iex(8)> flush()
nil       # nothing inside this key
:ok

iex(12)> send(pid, {:put, :alvin, self()})
{:put, :alvin, #PID<0.105.0>}
iex(13)> send(pid, {:get, :alvin, self()})
{:get, :alvin, #PID<0.105.0>}
iex(14)> flush()
#PID<0.105.0>     # pid inside this key
:ok
iex(15)> flush()  # no more after flushed
:ok

# can use Process to manipulate processes
ex> Process.register(pid, :kv)
true
iex> send(:kv, {:get, :hello, self()})
{:get, :hello, #PID<0.41.0>}
iex> flush()
:world
:ok

-- Agents (as abstraction to what we did above, no need manual loop)

iex> {:ok, pid} = Agent.start_link(fn -> %{} end)
{:ok, #PID<0.72.0>}
iex> Agent.update(pid, fn map -> Map.put(map, :hello, :world) end)
:ok
iex> Agent.get(pid, fn map -> Map.get(map, :hello) end)
:world

All Agent's function takes a `function` argument (input) for the process

------------
IO and filesystem

IO module
By default, IO read and write to stdin and stdout

iex> IO.puts("hello world")
hello world
:ok
iex> IO.gets("yes or no? ")
yes or no? yes
"yes\n"

iex> IO.puts(:stderr, "hello world")
hello world
:ok


---
File

iex> {:ok, file} = File.open("hello", [:write])
{:ok, #PID<0.47.0>}
iex> IO.binwrite(file, "world") 
# binwrite is to write iodata (raw data with unicode encoding)
# use IO.write for standard IO devices
:ok
iex> File.close(file)
:ok
iex> File.read("hello")
{:ok, "world"}

iex> File.read("hello")
{:ok, "world"}
iex> File.read!("hello")
"world"
iex> File.read("unknown")
{:error, :enoent}
iex> File.read!("unknown")
** (File.Error) could not read file "unknown": no such file or directory

version without ! is preferred if want to handle error manually
case File.read(file) do
  {:ok, body}      -> # do something with the `body`
  {:error, reason} -> # handle the error caused by `reason`
end

if not handling pattern matching error, when error happens will have a raised error
    about pattern matching
{:ok, body} = File.read(file)

so, if dont want to handle error outcomes, prefer File.read!/1


---
Path
iex> Path.join("foo", "bar")
"foo/bar"
iex> Path.expand("~/hello")
"/Users/jose/hello"

---
Processes

iex> {:ok, file} = File.open("hello", [:write])
{:ok, #PID<0.47.0>}

# a file is a process


iex> pid = spawn(fn ->
...>  receive do: (msg -> IO.inspect msg)
...> end)    # allow us to see inside what's happening in the process
#PID<0.57.0>

iex> IO.write(pid, "hello")
{:io_request, #PID<0.41.0>, #Reference<0.0.8.91>,
 {:put_chars, :unicode, "hello"}}  # here is :unicode
** (ErlangError) erlang error: :terminated  # IO expects return of result, since there's no result, it fails
iex(9)> IO.binwrite(pid, "hey")
{:io_request, #PID<0.105.0>, #Reference<0.443468378.3025666051.172127>,
 {:put_chars, :latin1, "hey"}}   # see here, its :latin1 for binwrite
 {:error, :terminated}

--
if a file is opened without encoding, the file is in raw mode and 
functions with bin* must be used, these functions expect `iodata`

for most IO devices, open a file in :utf8 encoding, standard IO
functions can be used. These functions expect `chardata`

------------
1. # Alias the module so it can be called as Bar instead of Foo.Bar
alias Foo.Bar, as: Bar

# Require the module in order to use its macros
require Foo

# Import functions from Foo so they can be called without the `Foo.` prefix
import Foo

# Invokes the custom code defined in Foo as an extension point
use Foo


1.
defmodule Stats do
  alias Math.List, as: List
  # In the remaining module definition List expands to Math.List.
end

`alias` is lexically scoped
defmodule Math do
  def plus(a, b) do
    alias Math.List   
    # only inside plus/2 the alias will be valid
    # ...
  end

  def minus(a, b) do
    # ...
  end
end

2.
In order to use macros, need to opt-in by requiring module they are defined in
require is lexically scoped
iex> Integer.is_odd(3)
** (CompileError) iex:1: you must require Integer before invoking the macro Integer.is_odd/1
    (elixir) src/elixir_dispatch.erl:97: :elixir_dispatch.dispatch_require/6
iex> require Integer
Integer
iex> Integer.is_odd(3)
true

3.
Use import to access public functions or macros from other modules without
fully-qualified name
iex> import List, only: [duplicate: 2]  # or :except
List
iex> duplicate(:ok, 3)
[:ok, :ok, :ok]

# import is lexically scoped
defmodule Math do
  def some_function do
    import List, only: [duplicate: 2] # duplicate only available here
    duplicate(:ok, 10)
  end
end

# importing a module automatically requires it
# prefer `alias` to `import`

4.
use macro - extension point
when use a module, we are allowing the module to inject any code inside
the current module, such as importing itself or other modules, defining new functions, setting a module state, etc.

# useful for ExUnit.Case, Supervisor and GenServer etc..
# they populate our module with some basic behaviour 
defmodule AssertionTest do
  use ExUnit.Case, async: true

  test "always pass" do
    assert true
  end
end


# all test receive a context as an argument
# it is useful to be passed around, it also has some default properties like
# %{test: test_name}
test "stores key-value pairs", context do
    assert KV.put(context[:pid], :hello, :world) == :ok
    assert KV.get(context[:pid], :hello) == :world
end

--
defmodule Example do
  use Feature, option: :value
end

# is compiled into

defmodule Example do
  require Feature
  Feature.__using__(option: :value)
end

# Don’t use use where an import or alias would do.
# Code injection may have unintended side effect

--
In Erlang VM, modules are always represented as atoms

iex> List.flatten([1, [2], 3])
[1, 2, 3]
iex> :"Elixir.List".flatten([1, [2], 3]) # in Elixir, the base in Elixir
[1, 2, 3]
iex> :lists.flatten([1, [2], 3])
[1, 2, 3]


--------
Module nesting

defmodule Foo do
  defmodule Bar do
  end
end

# If Bar is moved outside of Foo, it must be reference as Foo.Bar (or an alias
# must be set)

# the below works, Foo doesnt need to be defined before Foo.Bar as they are
# independent of each other
defmodule Foo.Bar do
end

defmodule Foo do
  alias Foo.Bar
  # Can still access it as `Bar`
end

---
Can do multi alias/import/require/use

alias MyApp.{Foo, Bar, Baz}


----------------
Module Attributes

# most used are @moduledoc and @doc
@moduledoc - provides documentation for the current module.
@doc - provides documentation for the function or macro that follows the attribute.
@spec - provides a typespec for the function that follows the attribute.
@behaviour - (notice the British spelling) used for specifying an OTP or user-defined behaviour.

1. As annotations (documentation)
Elixir promotes the use of Markdown with heredocs to write readable documentation. Heredocs are multi-line strings, they start and end with triple double-quotes, keeping the formatting of the inner text.

We can access documentation of any **compiled module** from IEx
We have ExDoc to generate HTML pages from documentations

2. As constants

defmodule MyServer do
  @initial_state %{host: "127.0.0.1", port: 3456}
  IO.inspect @initial_state
end

defmodule MyServer do
  @my_data 14   # dont add newline between attribute and its value
  def first_data, do: @my_data  # unless its for reading it
  @my_data 13
  def second_data, do: @my_data
end

MyServer.first_data #=> 14
MyServer.second_data #=> 13

Module attribute are being called at 'compilation time' and its return value is 
what is substituted in for the attribute
Dont use it for function that's expected to be called at runtime (like db calls or
env variable inside another variable) 

3. Accumulative attributes
defmodule Foo do
  # can configure it to be accumlative
  Module.register_attribute __MODULE__, :param, accumulate: true

  @param :foo
  @param :bar
  # here @param == [:bar, :foo]
end

----------------
Structs

Structs are extensions built on top of maps that provide compile-time checks and default values.

#define a struct named User
defmodule User do
  defstruct name: "Alvin", age: 28
end

Struct can only be defined inside a module and takes the name of the module
defstruct can only be called once per module

iex> %User{}  # default value
%User{age: 27, name: "John"}
iex> %User{name: "Jane"}
%User{age: 27, name: "Jane"}

--
default value, when not given, is `nil`

iex> defmodule Product do
...>   defstruct [:name]
...> end
iex> %Product{}
%Product{name: nil}

iex> defmodule User do
...>   defstruct [name: "John", age: 27, :email] # must specify those with nil _first_
...> end
** (SyntaxError) iex:107: syntax error before: email

# struct are defined as keyword list
# this is basically a keyword list behaviour (default nil values must come
# first)

iex(27)> defmodule Product do
...(27)> defstruct [:name, :email, age: 89] # can specify multiples
...(27)> end
{:module, Product, ...
        %Product{age: 89, email: nil, name: nil}}

# can enforce keys
iex> defmodule Car do
...>   @enforce_keys [:make]
...>   defstruct [:model, :make]
...> end
iex> %Car{}
** (ArgumentError) the following keys must also be given when building struct Car: [:make]
    expanding struct: Car.__struct__/1

--
Accessing and updating structs

iex> john = %User{}
%User{age: 27, name: "John"}
iex> john.name  # cannot use john[:name]
"John"
iex> jane = %{john | name: "Jane"}
%User{age: 27, name: "Jane"}
iex> %{jane | oops: :field}
** (KeyError) key :oops not found in: %User{age: 27, name: "Jane"}
#can pattern match
iex> %User{name: name} = john
%User{age: 27, name: "John"}
iex> name
"John"

for get_in(xxx, ..), xxx can be below options:
Access.elem(_index) # to get from tuple ONLY
Access.at(_index) # to get from list ONLY
   -> to get from a list, can checkout Enum module. (becoz not every Struct implements the Access behaviour 
        for e.g.    Enum.at([1,2,3], 0) => 1
                    Enum.fetch([1,2,3], 0) => {:ok, 1}
Access.fetch(_container, _key) # to get from map, keyword list (or struct)

get_in(Access.t(), [term(), ...]) -> get a value from nested structure

iex(2)> users = %{"alvin" => %{age: 28, dob: 2009}}
%{"alvin" => %{age: 28, dob: 2009}}
iex(3)> get_in(users, ["alvin", :dob])
2009

iex(4)> users = %{"alvin" => %{age: 28, dob: {12, 24, 2009}}}
%{"alvin" => %{age: 28, dob: {12, 24, 2009}}}
iex(5)> get_in(users, ["alvin", :dob])
{12, 24, 2009}
iex(8)> get_in(users, ["alvin", :dob, Access.elem(0)])
12

-- can get_in deep level
iex(12)> users = %{"alvin" => %{age: 28, dob: %{year: 1990, month: 12, day: 14}}}
%{"alvin" => %{age: 28, dob: %{day: 14, month: 12, year: 1990}}}
iex(13)> users["alvin"]
%{age: 28, dob: %{day: 14, month: 12, year: 1990}}
iex(14)> get_in(users, ["alvin", :dob, :month])
12

-- get from list
iex(53)> l
[1, 2, 3]
iex(54)> get_in(l, [Access.at(0)])
1


-----
Structs are _bare_ maps
iex> is_map(john)
true
iex> john.__struct__ # store a 'special' field/key __struct__ that holds the struct name
User

iex> jane = Map.put(%User{}, :name, "Jane")
%User{age: 27, name: "Jane"}
iex> Map.merge(jane, %User{name: "John"})
%User{age: 27, name: "John"}
iex> Map.keys(jane)
[:__struct__, :age, :name]
iex(24)> Map.put(%User{}, :anotherkey, "Hey") # puts a new key
%{__struct__: User, age: 28, anotherkey: "Hey", name: "Alvin"}


-------
Protocol (data polymorphism) -- something like typeclass?

Dispatching on a protocol is available to any data type that has implemented the protocol and a protocol can be implemented by anyone (in other files), at any time.

defprotocol Utility do
  @spec type(t) :: String.t()
  def type(value)
end

defimpl Utility, for: BitString do  # depending on Data Type
  def type(_value), do: "string"  # can have different implementation, but same output
end

defimpl Utility, for: Integer do
  def type(_value), do: "integer"
end

--
Functions defined in a protocol may have more than one input (argument), but the dispatching will always be based on the data type of the first input.
--
iex> Utility.type("foo")
"string"
iex> Utility.type(123)
"integer"

most common protocols is String.Chars, with its to_string/1

defprotocol Size do
  @doc "Calculates the size (and not the length!) of a data structure"
  def size(data) 
end

defimpl Size, for: BitString do # BitString seems to be a String (Binary)
  def size(string), do: byte_size(string)
end

defimpl Size, for: Map do
  def size(map), do: map_size(map)
end

defimpl Size, for: Tuple do
  def size(tuple), do: tuple_size(tuple)
end

iex(2)> Size.size(%{name: "teresa", name2: "Alvin"})
2
iex(3)> Size.size({:ok, :not_ok, "hey"})
3
iex(4)> Size.size("hey there")
9
iex(5)> Size.size("我是人")
9
iex(7)> Size.size([1,2,3])
** (Protocol.UndefinedError) protocol Size not implemented for [1, 2, 3] of type List
    size_protocol.ex:1: Size.impl_for!/1
        size_protocol.ex:3: Size.size/1

Structs are maps, which DO NOT share protocol implementation with maps
(reason is, they can have their own 'name' and protocol)
For e.g. MapSet

defmodule User do
  defstruct [:name, :age]
end

defimpl Size, for: User do
  def size(_user), do: 2
end

--
Deriving a protocol based on Any type
..

defimpl Size, for: Any do
  def size(_), do: 0
end

defmodule OtherUser do
  @derive [Size]    # this module would be able to use Size.size(_struct), which defaults to 0
  defstruct [:name, :age]
end

#Something same like 'deriving' in Haskell

..
Another alternative is to tell protocol to 'fallback' to Any when implementation cannot
be found

defprotocol Size do
  @fallback_to_any true
  def size(data)
end

# then anything that doesnt have implementation will default to Any's
# implementation
iex(7)> Size.size([1,2,3])
0

# but this wont much sense, hence its better to use the @derive approach and let
those without implementation fail

--
Some built in protocols
https://hexdocs.pm/elixir/Protocol.html

Enum
iex> Enum.map [1, 2, 3], fn(x) -> x * 2 end
[2, 4, 6]
iex> Enum.reduce 1..3, 0, fn(x, acc) -> x + acc end
6
String.Chars  which exposed via to_string
iex> to_string :hello
"hello"
iex> "age: #{25}"  # Works becoz Integer and Float implements String.Chars
"age: 25"

iex> tuple = {1, 2, 3}
{1, 2, 3}
iex> "tuple: #{tuple}"
** (Protocol.UndefinedError) protocol String.Chars not implemented for {1, 2, 3}
# would need the inspect function to print more 'complex' data structure

iex> "tuple: #{inspect tuple}"
"tuple: {1, 2, 3}"
# Inspect itself is also a protocol, data structure that need printable format
# implements `inspect` function https://hexdocs.pm/elixir/Inspect.html#inspect/2

# inspected values that starts with # means its in non-valid Elixir syntax
iex> inspect &(&1+2)
"#Function<6.71889879/1 in :erl_eval.expr/5>"


-------
Comprehensions

`for` special form
iex> for n <- [1, 2, 3, 4], do: n * n
[1, 4, 9, 16]

A comprehension is made of three parts: generators, filters, and collectables.

n <- [1, 2, 3, 4] is the generator

iex> for n <- 1..4, do: n * n
[1, 4, 9, 16]

# support pattern matching on the LHS
iex> values = [good: 1, good: 2, bad: 3, good: 4]
iex> for {:good, n} <- values, do: n * n
[1, 4, 16]

# can use filter (similar to guard?) in comprehension 
iex> for n <- 0..5, rem(n, 3) == 0, do: n * n
[0, 9]

Comprehensions discard all elements for which the filter expression returns false or nil; all other values are selected.

Comprehensions allow multiple generators and filters to be used (similar to Racket / Clojure)

dirs = ['/home/mikey', '/home/james']

for dir <- dirs,   # loop 1 
    file <- File.ls!(dir),  # loop 2
    path = Path.join(dir, file), # end up with loop 1 * loop 2 times
    File.regular?(path) do
  File.stat!(path).size
end

# 2 generators to produce cartesian products of 2 lists
iex> for i <- [:a, :b, :c], j <- [1, 2], do:  {i, j}
[a: 1, a: 2, b: 1, b: 2, c: 1, c: 2]

----
(8 Bit..) Bitstring generators
iex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>
iex> for <<r::8, g::8, b::8 <- pixels>>, do: {r, g, b}
[{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]


-- :into option
# set the comprehension result structure (must implement Collectable protocol)
iex(2)> for <<c <- " hello world ">>, do: <<c>>
[" ", "h", "e", "l", "l", "o", " ", "w", "o", "r", "l", "d", " "]
iex(3)> for <<c <- " hello world ">>, c != ?\s, do: <<c>>
["h", "e", "l", "l", "o", "w", "o", "r", "l", "d"]

# recall ?a = 97, basically checking the decimal value for this ASCII char (or
# Unicode point)

?\s = 32 (space character)

# so , the :into option convert (or aggregate) the result into a string "" here
iex> for <<c <- " hello world ">>, c != ?\s, into: "", do: <<c>>
"helloworld"

:into accepts any structure that implements the Collectable protocol

# Collectable
# Enum.into (implemented Colletable.into) insert enumerable into a collection
Enum.into([a: 1, b: 2], %{})
%{a: 1, b: 2}


# using tuple as an 'temp' structure to do the arithmetic, but still output in
# map
iex> for {key, val} <- %{"a" => 1, "b" => 2}, into: %{}, do: {key, val * val}
%{"a" => 1, "b" => 4}

# to open a convert current stdio stream in IEx into upcase
iex> stream = IO.stream(:stdio, :line)
iex> for line <- stream, into: stream do
...>   String.upcase(line) <> "\n"
...> end

-- :uniq option
# guarantees only unique values are added to collection
iex > for x <- [1, 1, 2, 3], uniq: true, do: x * 2
[2, 4, 6]

iex > for <<x <- "abcabc">>, uniq: true, into: "", do: <<x - 32>>
"ABC"

-- :reduce option

# want to filter only lower case letters and collect them with their freq into a
# map

# simple way, but iterate the data twice
iex > letters = for <<x <- "AbCabCABc">>, x in ?a..?z, do: <<x>>
iex > Enum.reduce(letters, %{}, fn x, acc -> Map.update(acc, x, 1, & &1 + 1) end)
%{"a" => 1, "b" => 2, "c" => 1}

# use :reduce to fuse 2 steps into single step
iex > for <<x <- "AbCabCABc">>, x in ?a..?z, reduce: %{} do
  acc -> Map.update(acc, <<x>>, 1, & &1 + 1)  # do block becomes the reducer function
end
%{"a" => 1, "b" => 2, "c" => 1}

# When the :reduce key is given, _its value_ is used as the initial accumulator and the do block must be changed to use -> clauses, where the left side of -> receives the accumulated value of the previous iteration and the expression on the right side must return the new accumulator value. 

-----
`with` special form

something like `let*` in racket, where valid expression will pass on the variable down the pipeline

opts = %{width: 10, height: 15}
with {:ok, width} <- Map.fetch(opts, :width),
     {:ok, height} <- Map.fetch(opts, :height) do
  {:ok, width * height}
end
{:ok, 150}

opts = %{width: 10}
with {:ok, width} <- Map.fetch(opts, :width),
     {:ok, height} <- Map.fetch(opts, :height) do
  {:ok, width * height}
end
:error

# can use guard `when`
users = %{"melany" => "guest", "bob" => :admin}
with {:ok, role} when not is_binary(role) <- Map.fetch(users, "bob") do
  {:ok, to_string(role)}
end
{:ok, "admin"}

# can mix with other expressions / clauses in the pipeline
width = nil
opts = %{width: 10, height: 15}
with {:ok, width} <- Map.fetch(opts, :width),   # notice the comma,
     double_width = width * 2,
     {:ok, height} <- Map.fetch(opts, :height) do
  {:ok, double_width * height}
end
{:ok, 300}
width
nil

opts = %{width: 10, height: 15}
with(  # can use parens for clarity
  {:ok, width} <- Map.fetch(opts, :width),
  {:ok, height} <- Map.fetch(opts, :height)
) do
  {:ok, width * height}
end
{:ok, 150}

# can used with `else`
opts = %{width: 10}
with {:ok, width} <- Map.fetch(opts, :width),
     {:ok, height} <- Map.fetch(opts, :height) do
  {:ok, width * height}
else
  :error ->
    {:error, :wrong_data}

  _other_error ->
    :unexpected_error
end
{:error, :wrong_data}


------------
Sigils (~) - for working with textual representation

1. ~r (regular expression)

iex> regex = ~r/foo|bar/
~r/foo|bar/
iex> "foo" =~ regex  # matches must be "string" (binary)
true
iex> "bat" =~ regex
false

# support modifiers (i here)
iex> "HELLO" =~ ~r/hello/
false
iex> "HELLO" =~ ~r/hello/i
true

sigils support 8 different delimiters:

~r/hello/
~r|hello|
~r"hello"
~r'hello'
~r(hello)
~r[hello]
~r{hello}
~r<hello>

This is to provide ease of life:
for e.g. ~r(^https?://)  vs  ~r/^https?:\/\// 

2. ~s (to generate strings, think string literal template with double quotes)

iex> ~s(this is a string with "double" quotes, not 'single' ones)
"this is a string with \"double\" quotes, not 'single' ones"


3. ~c (to generate charlist, with single quotes)

iex> ~c(this is a char list containing 'single quotes')
'this is a char list containing \'single quotes\''

4. ~w (to generate list of words)

iex> ~w(foo bar bat)
["foo", "bar", "bat"]


lower case sigils allow escape codes and interpolation
Upper case sigils does not
iex> ~s(String with escape codes \x26 #{"inter" <> "polation"})
"String with escape codes & interpolation"
iex> ~S(String without escape codes \x26 without #{interpolation})
"String without escape codes \\x26 without \#{interpolation}"

5. ~s""" (heredocs, when writing documentation)
iex> ~s"""   # triple double quotes enable multilines
...> this is
...> a heredoc string
...> """

# to escape \, it will become \\\

iex(5)> ~S"""
...(5)> Some string "\"hey\""
...(5)> """
"Some string \"\\\"hey\\\"\"\n"

6. ~D (for %Date{})
iex(8)> Date.new(1999,2,1)
{:ok, ~D[1999-02-01]}
iex(9)> d = ~D[19999-02-01]
** (ArgumentError) cannot parse "19999-02-01" as Date for Calendar.ISO, reason: :invalid_format
(elixir 1.12.0) lib/kernel.ex:5836: Kernel.maybe_raise!/4
(elixir 1.12.0) lib/kernel.ex:5815: Kernel.parse_with_calendar!/3
(elixir 1.12.0) expanding macro: Kernel.sigil_D/2
iex:9: (file)
iex(9)> d = ~D[1999-02-01]
~D[1999-02-01]
iex(10)> d.month
2

7. ~T (for %Time{})
iex(12)> Time.new(11,0,0,999999)
{:ok, ~T[11:00:00.999999]}
iex(13)> Time.new(11,0,0,999_102)
{:ok, ~T[11:00:00.999102]}
iex(14)> ~T[11:00:00.9]
~T[11:00:00.9]

8. ~N (for %NaiveDateTime{})
iex> ndt = ~N[2019-10-31 23:00:07]
~N[2019-10-31 23:00:07]
(should avoid creating this directly)
(but should not use this since its only native assumption of date time, should use 3rd party calendar library or DateTime)


9. ~U (for %DateTime{})
#by default only has Etc/UTC timezone database, if want to use other TZ, will
need to download additional libraries
https://hexdocs.pm/elixir/DateTime.html#module-time-zone-database

iex> dt = ~U[2019-10-31 19:59:03Z]
~U[2019-10-31 19:59:03Z]
iex> %DateTime{minute: minute, time_zone: time_zone} = dt
~U[2019-10-31 19:59:03Z]
iex> minute
59
iex> time_zone
"Etc/UTC"

-- Custom Sigils

~r/foo/i is equivalent to calling sigil_r

iex> sigil_r(<<"foo">>, 'i')
~r"foo"i

we can define our own custom sigil by following sigil_{character} pattern
# for e.g. we can define a ~i which returns an integer
iex> defmodule MySigils do
...>   def sigil_i(string, []), do: String.to_integer(string)
...>   def sigil_i(string, [?n]), do: -String.to_integer(string)
...> end
iex> import MySigils
iex> ~i(13)
13
iex> ~i(42)n
-42


---------------
Try, catch and rescue (used less frequently in Elixir language)

-- raise/1 - raise runtime error

Can define own error by creating a module and use defexception

iex> defmodule MyError do
iex>   defexception message: "default message"
iex> end
iex> raise MyError
** (MyError) default message
iex> raise MyError, message: "custom message"
** (MyError) custom message

-- try/rescue construct
iex> try do
...>   raise "oops"
...> rescue
...>   e in RuntimeError -> e
...> end
%RuntimeError{message: "oops"}

# but this construct is rarely used, 2 ways to deal with potential exceptions

# either we handle by pattern matching
iex> case File.read("hello") do
...>   {:ok, body} -> IO.puts("Success: #{body}")
...>   {:error, reason} -> IO.puts("Error: #{reason}")
...> end

# or we let it throw error
iex> File.read!("unknown")
** (File.Error) could not read file unknown: no such file or directory
    (elixir) lib/file.ex:272: File.read!/1


There's no exceptions on File.read/1

Standard library has many functions that follow this pattern
1) A function (foo) which returns {:ok, result} or {:error, reason} tuples
2) Another function (foo!, same name but with a trailing !) that takes the same arguments as foo but which raises an exception if there’s an error. foo! should return the result (not wrapped in a tuple) if everything goes fine. 

-- reraise/2
try do
  ... some code ...
rescue
  e ->
    Logger.error(Exception.format(:error, e, __STACKTRACE__))
    reraise e, __STACKTRACE__     # reraise e with same stacktrace
end

# this usecase is mainly for logging out the exception

-- throw / catch
(used to control code flow)

# contrived example
# but is provided incase need to interface with library without proper API
iex> try do
...>   Enum.each(-50..50, fn(x) ->
...>     if rem(x, 13) == 0, do: throw(x)
...>   end)
...>   "Got nothing"
...> catch
...>   x -> "Got #{x}"
...> end
"Got -39"

-- exit
iex> spawn_link(fn -> exit(1) end)
** (EXIT from #PID<0.56.0>) evaluator process exited with reason: 1


the exit signals are for supervisor to monitor

-- after
iex> {:ok, file} = File.open("sample", [:utf8, :write])
iex> try do
...>   IO.write(file, "olá")
...>   raise "oops, something went wrong"
...> after
...>   File.close(file)
...> end
** (RuntimeError) oops, something went wrong

The after clause will be executed regardless of whether or not the tried block succeeds, unless the process exits first
(like Finally)

iex> defmodule RunAfter do
...>   def without_even_trying do
...>     raise "oops"
...>   after
...>     IO.puts "cleaning up!"
...>   end
...> end
iex> RunAfter.without_even_trying
cleaning up!
** (RuntimeError) oops

Elixir will automatically wrap the function body in a try whenever one of after, rescue or catch is specified.

-- else

iex> x = 2
2
iex> try do
...>   1 / x
...> rescue
...>   ArithmeticError ->
...>     :infinity
...> else   # it will match on the results of the try block whenever the try block finishes without a throw or an error
...>   y when y < 1 and y > -1 ->
...>     :small
...>   _ ->
...>     :large
...> end
:small


------------
Types and specs

typespecs
1. declaring typed function signatures (also called specifications);
2. declaring custom types.

 Elixir is a dynamically typed language, and as such, type specifications are never used by the compiler to optimize or modify code. Still, using type specifications is useful because:

1. they provide documentation (for example, tools such as ExDoc show type specifications in the documentation)
2. they're used by tools such as Dialyzer, that can analyze code with typespec to find type inconsistencies and possible bugs

defmodule LousyCalculator do
  @typedoc """
  Just a number followed by a string.
  """
  @type number_with_remark :: {number, String.t}

  @spec add(number, number) :: number_with_remark
  def add(x, y), do: {x + y, "You need a calculator to do that?"}

  @spec multiply(number, number) :: number_with_remark
  def multiply(x, y), do: {x * y, "It is like addition on steroids."}
end

@type can be exported with their module
@typep to keep a type private - @typedoc will be discarded for private type and cannot be checked by `t` in IEx

funny thing is, even if we specify the spec wrongly, it would still compiles and runs
Need to rely on Erlang Dialyzer for static code analysis if want to check inconsistencies

-------
Behaviours

** something like an interface in Java: a set of function signatures that a module has to implement.

** similar nature like protocol but instead of abstraction for each data type, its for modules

defmodule Parser do
  @doc """
  Parses a string.
  """
  @callback parse(String.t) :: {:ok, term} | {:error, String.t}

  @doc """
  Lists all supported file extensions.
  """
  @callback extensions() :: [String.t]
end

# modules adopting Parser's behaviour will need to implement all the functions
# defined with @callback attribute

# term type means any()

# adopting behaviour
defmodule JSONParser do
  @behaviour Parser

  @impl Parser
  def parse(str), do: {:ok, "some json " <> str} # ... parse JSON

  @impl Parser
  def extensions, do: ["json"]
end

defmodule YAMLParser do
  @behaviour Parser

  @impl Parser
  def parse(str), do: {:ok, "some yaml " <> str} # ... parse YAML

  @impl Parser
  def extensions, do: ["yml"]
end


-- Dynamic Dispatching

defmodule Parser do
  @callback parse(String.t) :: {:ok, term} | {:error, String.t}
  @callback extensions() :: [String.t]

  def parse!(implementation, contents) do
    case implementation.parse(contents) do
      {:ok, data} -> data
      {:error, error} -> raise ArgumentError, "parsing error: #{error}"
    end
  end
end

## can only use at parent / top level
iex(7)> Parser.parse!(JSONParser, "Hey")
"some json Hey"
iex(8)> Parser.parse!(JSONParser, "bad")
** (ArgumentError) parsing error: opps
    parser.ex:17: Parser.parse!/2

---------
Debugging

IO.inspect/2

IO.inspect(item, opts \\ [])

# to spy on functions chain
(1..10)
|> IO.inspect
|> Enum.map(fn x -> x * 2 end)
|> IO.inspect
|> Enum.sum
|> IO.inspect

[1, 2, 3]
|> IO.inspect(label: "before")
|> Enum.map(&(&1 * 2))
|> IO.inspect(label: "after")
|> Enum.sum

before: [1, 2, 3]
after: [2, 4, 6]

--
def some_fun(a, b, c) do 
  IO.inspect binding()  # binding() show all bindings in the current context
  ...
end

iex> x = 1
iex> binding()
[x: 1]
iex> x = 2
iex> binding()
[x: 2]


-------
To debug via IEx 
can use IEx.pry/0 and IEx.break!/2

insert `require IEx; IEx.pry()` in code line
type `respawn()` to respawn exit and respawn process

-------
Use Erlang's Debugger

$ elixirc example.ex  # has to first compile
$ iex

iex(1)> :debugger.start()
{:ok, #PID<0.87.0>}
iex(2)> :int.ni(Example)   # use this to load the module
{:module, Example}
iex(3)> :int.break(Example, 3)   # can set break like this, or via the monitor UI
:ok
iex(4)> Example.double_sum(1, 2)


-------
Use Observer to check the whole VM, processes, applications etc

$ iex
iex(1)> :observer.start()



--------
Erlang stdlib http://erlang.org/doc/apps/stdlib/index.html

-- Digraph module

The digraph (directed graph) module

iex> digraph = :digraph.new()
iex> coords = [{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}]
iex> [v0, v1, v2] = (for c <- coords, do: :digraph.add_vertex(digraph, c))
iex> :digraph.add_edge(digraph, v0, v1)  # digraph are mutable in-place
iex> :digraph.add_edge(digraph, v1, v2)
iex> :digraph.get_short_path(digraph, v0, v2)
[{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}]

Directed graphs at stored as ETS (Erlang Term Storage) tables

ets - built in term storage
dets - disk based term storage

(its like redis for Erlang)

ETS lets you create a table containing tuples. By default, ETS tables are protected, which means only the owner process may write to the table but any other process can read. ETS has some functionality to allow a table to be used as a simple database, a key-value store or as a cache mechanism.

ex> table = :ets.new(:ets_test, [])
# Store as tuples with {name, population}
iex> :ets.insert(table, {"China", 1_374_000_000})
iex> :ets.insert(table, {"India", 1_284_000_000})
iex> :ets.insert(table, {"USA", 322_000_000})
iex> :ets.i(table)
<1   > {<<"India">>,1284000000}
<2   > {<<"USA">>,322000000}
<3   > {<<"China">>,1374000000}

# in the tuple, the first value is a `key` the rest are values
# try inserting same `key` will update the values


-- Math Module

iex> angle_45_deg = :math.pi() * 45.0 / 180.0
iex> :math.sin(angle_45_deg)
0.7071067811865475
iex> :math.exp(55.0)
7.694785265142018e23
iex> :math.log(7.694785265142018e23)
55.0


-- Queue Module

iex> q = :queue.new
iex> q = :queue.in("A", q)
iex> q = :queue.in("B", q)
iex> {value, q} = :queue.out(q)
iex> value
{:value, "A"}
iex> {value, q} = :queue.out(q)
iex> value
{:value, "B"}
iex> {value, q} = :queue.out(q)
iex> value
:empty


-- Rand Module

iex> :rand.uniform()
0.8175669086010815
iex> _ = :rand.seed(:exs1024, {123, 123534, 345345})
iex> :rand.uniform()
0.5820506340260994
iex> :rand.uniform(6)
6

-- Zip, Zlib modules

iex> :zip.foldl(fn _, _, _, acc -> acc + 1 end, 0, :binary.bin_to_list("file.zip"))
{:ok, 633}

# data compression in zlib format (gzip command)

iex> song = "
...> Mary had a little lamb,
...> His fleece was white as snow,
...> And everywhere that Mary went,
...> The lamb was sure to go."
iex> compressed = :zlib.compress(song)
iex> byte_size song
110
iex> byte_size compressed
99
iex> :zlib.uncompress(compressed)
"\nMary had a little lamb,\nHis fleece was white as snow,\nAnd everywhere that Mary went,\nThe lamb was sure to go."

-----
Mix

(just) mix  - to compile

mix new kv --module KV   # to specify module name separately, else it will default to Kv

mix compile  # compile, all files under _build

iex -S mix  # start iex session inside project

iex> recompile()  # for new changes, to test in iex

mix test # to run tests

mix test test/kv_test.exs:5  # to run one particular file:line

mix test --trace  # to run trace synchronously, (async: true no effect)

mix format   # will format the files as specify in .formatter.exs

mix format --check-formatted    # to ensure all code follows standard

mix environments
:dev
:test
:prod

# to compile with environment
MIX_ENV=prod mix compile

--
Abstractions for processes in Elixir and OTP
Agent - Simple wrappers around state.
GenServer - “Generic servers” (processes) that encapsulate state, provide sync and async calls, support code reloading, and more.
Task - Asynchronous units of computation that allow spawning a process and potentially retrieving its result at a later time.

---
Agent
All agent processes are the 'server'

Everything that is inside the function we passed to the agent happens in the agent process. In this case, since the agent process is the one receiving and responding to our messages, we say the agent process is the server. Everything outside the function is happening in the client.

def delete(bucket, key) do
  Process.sleep(1000) # puts client to sleep, all processes outside the agent are 'client'
  Agent.get_and_update(bucket, fn dict ->
    Process.sleep(1000) # puts server to sleep
    Map.pop(dict, key)
  end)
end

----
GenServer (generic server processes)
it will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into a supervision tree.

# when we use Agent API
def put(bucket, key, value) do
  # Here is the client code
  Agent.update(bucket, fn state ->
    # Here is the server code
    Map.put(state, key, value)
  end)
  # Back to the client code
end

# in GenServer - client / server side codes are separately
def put(bucket, key, value) do
  # Send the server a :put "instruction"
  GenServer.call(bucket, {:put, key, value})
end

# Server callback
def handle_call({:put, key, value}, _from, state) do
  {:reply, :ok, Map.put(state, key, value)}
end

The GenServer behaviour abstracts the common client-server interaction. 
Developers are only required to implement the callbacks and functionality they are interested in.

2 types of request to GenServer: calls and casts

Calls - synchronous, server must send response back, client will wait for one
Casts - asynchrnous, server wont send response, client wont wait for one 
handle_info is also asynchronous (as there's no response)

defmodule Stack do
  use GenServer

  # Client

  def start_link(default) when is_list(default) do
    GenServer.start_link(__MODULE__, default)
  end

  def push(pid, element) do
    GenServer.cast(pid, {:push, element})
  end

  def pop(pid) do
    GenServer.call(pid, :pop)
  end

  # Server (callbacks)

  @impl true
  def init(stack) do
    {:ok, stack}
  end

  @impl true
  def handle_call(:pop, _from, [head | tail]) do
    {:reply, head, tail}
  end

  @impl true
  def handle_cast({:push, element}, state) do
    {:noreply, [element | state]}
  end
end

The @impl true informs the compiler that our intention for the subsequent function definition is to define a callback. If by any chance we make a mistake in the function name or in the number of arguments, like we define a handle_call/2, the compiler would warn us there isn’t any handle_call/2 to define

GenServer can _monitor_ processes (in which Agent cannot)
https://elixir-lang.org/cheatsheets/gen-server.pdf

iex -S mix
iex> {:ok, pid} = KV.Bucket.start_link([])
{:ok, #PID<0.66.0>}   # child pid
iex> Process.monitor(pid)  # (current) parent process holds a ref to child process
#Reference<0.0.0.551>
iex> Agent.stop(pid)
:ok
iex> flush()
{:DOWN, #Reference<0.0.0.551>, :process, #PID<0.66.0>, :normal}

When to use which?
1. handle_call/3 must be used for synchronous requests. This should be the default choice as waiting for the server reply is a useful backpressure mechanism.

2. handle_cast/2 must be used for asynchronous requests, when you don’t care about a reply. A cast does not even guarantee the server has received the message and, for this reason, should be used sparingly. For example, the create/2 function we have defined in this chapter should have used call/2. We have used cast/2 for didactic purposes.

3. handle_info/2 must be used for all other messages a server may receive that are not sent via GenServer.call/2 or GenServer.cast/2, including regular messages sent with send/2. 
For e.g. message sent by functions such as Kernel.send/2, Process.send_after/4 and similar custom messages
The monitoring :DOWN messages are an example of this.

---
start_link vs start_supervised!
(links vs monitors (i.e. supervisors))

Links are bi-directional. If you link two processes and one of them crashes, the other side will crash too (unless it is trapping exits). A monitor is uni-directional: only the monitoring process will receive notifications about the monitored one. In other words: use links when you want linked crashes, and monitors when you just want to be informed of crashes, exits, and so on.

----
Supervisor

A supervisor is a process which supervises other processes, which we refer to as child processes. The act of supervising a process includes three distinct responsibilities.

1. start child processes
2. restart failed child processes
3. shutting down child processes

children = [ <list of children modules> ]

Supervisor.init(children, strategy: ..
:one_for_one - if a child process terminates, only that process is restarted.

:one_for_all - if a child process terminates, all other child processes are terminated and then all child processes (including the terminated one) are restarted.

:rest_for_one - if a child process terminates, the terminated child process and the rest of the children started after it, are terminated and restarted.

Every module (child process) has a child_spec/1 function
it describes how to start the child process and other details of the process

The child_spec/1 function is automatically defined when we use Agent, use GenServer, use Supervisor

iex(1)> KV.Registry.child_spec([])
%{id: KV.Registry, start: {KV.Registry, :start_link, [[]]}}

iex(18)> KV.Supervisor.start_link([])  # this will call the init() function
{:ok, #PID<0.191.0>}
iex(19)> Supervisor.which_children(pid(0,191,0))
[{KV.Registry, #PID<0.192.0>, :worker, [KV.Registry]}]

# Supervisor automatically restarts child process
iex(3)> KV.Supervisor.start_link([])
{:ok, #PID<0.201.0>}
iex(4)> Process.alive?(pid(0,201,0))
true
iex(5)> Supervisor.which_children(pid(0,201,0))
[{KV.Registry, #PID<0.202.0>, :worker, [KV.Registry]}]
iex(6)> Process.alive?(pid(0,202,0))
true
iex(7)> Process.alive?(pid(0,201,0))
true
iex(8)> GenServer.call(pid(0,202,0), :shitty_input)
** (exit) exited in: GenServer.call(#PID<0.202.0>, :shitty_input, 5000)
** (EXIT) an exception was raised:
       ** (FunctionClauseError) no function clause matching in KV.Registry.handle_call/3
       ....
iex(8)> Supervisor.which_children(pid(0,201,0))  # monitoring process still alive
[{KV.Registry, #PID<0.208.0>, :worker, [KV.Registry]}]  # respawn child process with new pid
iex(9)> Process.alive?(pid(0,201,0))
true



we can init a Supervisor's children with :name option, which will later get passed to GenServer.start_link

def init(:ok) do
    children = [
      {KV.Registry, name: KV.Registry}
    ]

def start_link(opts) do
    GenServer.start_link(__MODULE__, :ok, opts) # as opts
end

iex> KV.Supervisor.start_link([])
{:ok, #PID<0.66.0>}
iex> KV.Registry.create(KV.Registry, "shopping")  # then we would be able to use inplace of <pid>
:ok
iex> KV.Registry.lookup(KV.Registry, "shopping")
{:ok, #PID<0.70.0>}

----
Application > Supervisor > GenServer > Agent

whenever we invoke `iex -S mix`, it automatically starts our application by calling Application.start(:kv)
we could change that by doing `iex -S mix run --no-start`

and start it manually within the iex
iex> Application.start(:kv)
:ok

iex> Application.stop(:kv)
:ok
iex> Application.stop(:logger)
:ok

iex> Application.start(:kv)
{:error, {:not_started, :logger}} # opps, logger is needed as dependency

iex> Application.ensure_all_started(:kv)
{:ok, [:logger, :kv]}

To start Supervisor when Application starts, specify the "application callback module" in mix.exs
 def application do
    [
      extra_applications: [:logger],
      mod: {KV, []} #<--- here, followed by [] arguments to be passed on application start
    ]
  end

after that, we need to define Supervisor.start_link in KV module
defmodule KV do
  use Application

  @impl true
  def start(_type, _args) do
    # Although we don't use the supervisor name below directly,
    # it can be useful when debugging or introspecting the system.
    KV.Supervisor.start_link(name: KV.Supervisor)
  end
end


---------
DynamicSupervisor
For the Supervisor above, we need to pass in a list of children when initializing

The DynamicSupervisor does not expect a list of children during initialization; instead each child is started manually via DynamicSupervisor.start_child/2.


            # arguments - <name of supervisor>  <name of child>
DynamicSupervisor.start_child(KV.BucketSupervisor, KV.Bucket)


--
Querying child spec,
its the same whether self module. child_spec or via Supervisor.child_spec

for e.g
iex(8)> Supervisor.child_spec(KV.Bucket, [])
%{id: KV.Bucket, restart: :temporary, start: {KV.Bucket, :start_link, [[]]}}
iex(13)> KV.Bucket.child_spec([])
%{id: KV.Bucket, restart: :temporary, start: {KV.Bucket, :start_link, [[]]}}


iex(11)> Supervisor.child_spec(KV.Registry, [])
%{id: KV.Registry, start: {KV.Registry, :start_link, [[]]}}
iex(9)> Registry.child_spec([])
%{id: Registry, start: {Registry, :start_link, [[]]}, type: :supervisor}

iex(10)> DynamicSupervisor.child_spec([])
%{
      id: DynamicSupervisor,
        start: {DynamicSupervisor, :start_link, [[]]},
          type: :supervisor
}
iex(12)> Supervisor.child_spec(DynamicSupervisor, [])
%{
      id: DynamicSupervisor,
        start: {DynamicSupervisor, :start_link, [[]]},
          type: :supervisor
}

----
Observer
iex(14)> :observer.start
:ok

to bring up observer, can observe supervision tree


------
Umbrella projects

able to separate different 'applications' within the same repo, under apps/
the 'applications' can be deployed separately if needed
+ kv_umbrella
  + apps
    + kv
    + kv_server

under the apps/ directory, can host many apps 
create by usual `mix new my_app` command

in project root, running `mix compile` or `mix test` will run for each
'application' under apps/ directory


# create a kv_server folder (app), with KVServer module, 
# --sup tell Mix to generate a supervision tree 
mix new kv_server --module KVServer --sup

all applications share the same build, config and lock files

The pattern of keeping multiple applications in the same repository is known as “mono-repo”. 
Umbrella projects maximize this pattern by providing conveniences to compile, test and run multiple applications at once.

But they are still not fully decoupled, as they share the same configuration and same dependencies.

------
DocTest

Test that runs based on @doc example in documentation

  @doc ~S"""
  Parses the given `line` into a command.

  ## Examples

      iex> KVServer.Command.parse("CREATE shopping\r\n")
      {:ok, {:create, "shopping"}}
  """

doctest <module> 
expect the code after `iex>` will be equal to the answer followed immediately
notice the 4 spaces of indentation before iex> prompt
multiple lines can use `...>`, just like in IEx

      # new line defines new doctest - below is 2 doc tests
      iex> KVServer.Command.parse "UNKNOWN shopping eggs\r\n"
      {:error, :unknown_command}

      iex> KVServer.Command.parse "GET shopping\r\n"
      {:error, :unknown_command}

      # this is one doctest
      iex> KVServer.Command.parse "UNKNOWN shopping eggs\r\n"
      {:error, :unknown_command}
      iex> KVServer.Command.parse "GET shopping\r\n"
      {:error, :unknown_command}

-----
Distributed computing

# starting iex with a node name
iex --sname foo
iex> defmodule Hello do
...>   def world, do: IO.puts "hello world"
...> end


# start another iex with a different node name
iex --sname bar
# can spawn aprocess on another node like so
iex> Node.spawn_link :"foo@computer-name", fn -> Hello.world end
#PID<9014.59.0>
hello world

------
Async/await

task = Task.async(fn -> compute_something_expensive() end)
res  = compute_something_else()
res + Task.await(task)  # use await to read the result later on

---
Combining node + async/await knowledge, we can do distributed asynchronous task across nodes

# start a `foo` node in one terminal
iex -sname foo -S mix
iex(foo@alvinvoo)1> node()
:foo@alvinvoo

# start a `bar` node in another terminal
iex -sname bar -S mix
iex(bar@alvinvoo)7> node()
:bar@alvinvoo


# create an async task for foo@alvinvoo
iex(bar@alvinvoo)1> Task.Supervisor.async {KV.RouterTasks, :"foo@alvinvoo"}, fn -> {:ok, node()} end
%Task{
      owner: #PID<0.149.0>,
      pid: #PID<17839.181.0>,
      ref: #Reference<0.1984204966.1083703298.91778>
}
# get result from Task
iex(bar@alvinvoo)2> Task.await(v 1)                                
{:ok, :foo@alvinvoo}

# its much preferable to give the module, function and arguments explicitly
# since anonymous functions require target node to have exactly same code
# version as caller
iex> task = Task.Supervisor.async {KV.RouterTasks, :"foo@computer-name"}, Kernel, :node, []
%Task{owner: #PID<0.122.0>, pid: #PID<12467.89.0>, ref: #Reference<0.0.0.404>}
iex> Task.await(task)
:"foo@computer-name"

--
to run test with live nodes

# might need to spin up an iex with bar node
elixir --sname foo -S mix test

# can only run test with only those tagged
elixir --sname foo -S mix test --only distributed

---------
Configuration (ENV)

config/config.exs - this file is read at build time, before we compile our application and before we even load our dependencies. This means we can’t access the code in our application nor in our dependencies. However, it means we can control how they are compiled.
This file often imports configuration files based on the environment, such as config/dev.exs and config/prod.exs

config/runtime.exs - this file is read after our application and dependencies are compiled and therefore it can configure how our application works at runtime. If you want to read system environment variables (via System.get_env/1) or any sort of external configuration, this is the appropriate place to do so

# example
# lets say in kv/mix.exs
  def application do
    [
      extra_applications: [:logger],
      env: [routing_table: []],    # specify the env variable here
      mod: {KV, []}
    ]
  end

# set default env values here
import Config
config :iex, default_prompt: ">>>"
config :kv, :routing_table, [{?a..?z, node()}]

# inside tests / programs, use Application.get_env and Application.put_env
    current = Application.get_env(:kv, :routing_table)

    Application.put_env(:kv, :routing_table, [
      {?a..?m, :"foo@alvinvoo"},
      {?n..?z, :"bar@alvinvoo"}
    ])

-----
Weird thing noticed
1. When testing, printing out from test scripts EXS is ok, but printing out from within a ex file is not
2. Changing an ex file also seem not to affect, force recompiling before running test seems no effect


3. with setup_all, need to use :ok = Ecto.Adapters.SQL.Sandbox.checkout(ApiGateway.Repo), else cannot find owner
but somehow even though the db is populated in setup_all, in individual test cases, the DB is cleared afreshed again
4. so no choice, but to use `setup` and populate the DB in every round? (since DB is cleared after every test)

